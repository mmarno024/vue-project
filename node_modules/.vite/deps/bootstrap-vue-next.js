import "./chunk-VCZIUQUC.js";
import {
  Fragment,
  Teleport,
  Transition,
  TransitionGroup,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  customRef,
  defineComponent,
  getCurrentInstance,
  getCurrentScope,
  guardReactiveProps,
  h,
  inject,
  isRef,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeUnmount,
  onMounted,
  onScopeDispose,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  readonly,
  ref,
  render,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  shallowReadonly,
  shallowRef,
  toDisplayString,
  toRef,
  toValue,
  unref,
  useAttrs,
  useModel,
  useSlots,
  vModelCheckbox,
  vModelRadio,
  vModelSelect,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-TXANXWBW.js";
import "./chunk-4Q5VUDNE.js";

// node_modules/bootstrap-vue-next/dist/bootstrap-vue-next.mjs
var rs = Object.defineProperty;
var is = (t4, l, e) => l in t4 ? rs(t4, l, { enumerable: true, configurable: true, writable: true, value: e }) : t4[l] = e;
var De = (t4, l, e) => (is(t4, typeof l != "symbol" ? l + "" : l, e), e);
var Xt = (t4) => computed(() => {
  const l = toValue(t4);
  return l ? `justify-content-${l}` : "";
});
var Sa = (t4, l) => computed(() => {
  const e = toValue(t4), o = toValue(l);
  return e === true ? "true" : typeof e == "string" ? e : o === false ? "true" : e === false ? "false" : void 0;
});
var ut = class _ut {
  constructor(l, e = {}) {
    De(this, "cancelable", true);
    De(this, "componentId", null);
    De(this, "_defaultPrevented", false);
    De(this, "eventType", "");
    De(this, "nativeEvent", null);
    De(this, "_preventDefault");
    De(this, "relatedTarget", null);
    De(this, "target", null);
    if (!l)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, _ut.Defaults, e, { eventType: l }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = true);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(l) {
    this._defaultPrevented = l;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(l) {
    this._preventDefault = l;
  }
  static get Defaults() {
    return {
      cancelable: true,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
};
var Ct = class extends ut {
  constructor(e, o = {}) {
    super(e, o);
    De(this, "trigger", null);
    Object.assign(this, ut.Defaults, o, { eventType: e });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
};
var pl = class extends ut {
  constructor(e, o) {
    super(e, o);
    De(this, "from");
    De(this, "to");
    De(this, "direction");
    Object.assign(this, ut.Defaults, o, { eventType: e });
    const { from: a, direction: n, to: r } = o;
    this.from = a, this.to = r, this.direction = n;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
};
var bs = (t4, l = {}) => {
  const e = (a = []) => {
    const { activeElement: n } = document;
    return n && !a.some((r) => r === n) ? n : null;
  }, o = (a) => a === e();
  try {
    t4.focus(l);
  } catch (a) {
    console.error(a);
  }
  return o(t4);
};
var Ne = (t4) => ((t4 == null ? void 0 : t4()) ?? []).length === 0;
var ys = (t4) => {
  if (t4.getAttribute("display") === "none")
    return false;
  const l = t4.getBoundingClientRect();
  return !!(l && l.height > 0 && l.width > 0);
};
var Ma = (t4) => {
  const l = window.getComputedStyle(t4), e = l.transitionDelay.split(",")[0] || "", o = l.transitionDuration.split(",")[0] || "", a = Number(e.slice(0, -1)) * 1e3, n = Number(o.slice(0, -1)) * 1e3;
  return a + n;
};
var no = typeof window < "u" && typeof document < "u" && typeof navigator < "u";
var gs = (t4) => (() => {
  let e = false;
  if (no)
    try {
      const o = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          e = true;
        }
      };
      WINDOW.addEventListener("test", o, o), WINDOW.removeEventListener("test", o, o);
    } catch {
      e = false;
    }
  return e;
})() ? typeof t4 == "object" ? t4 : { capture: !!t4 || false } : typeof t4 == "object" ? t4.capture : t4;
var hs = (t4, l, e, o) => {
  t4 && t4.addEventListener && t4.addEventListener(l, e, gs(o));
};
var Bs = (t4, l, e, o) => {
  t4 && t4.removeEventListener && t4.removeEventListener(l, e, o);
};
var Vo = (t4, l) => {
  (t4 ? hs : Bs)(...l);
};
var _s = ["TD", "TH", "TR"];
var ws = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(",");
var Qt = (t4) => {
  if (!t4 || !t4.target)
    return false;
  const l = t4.target;
  if ("disabled" in l && l.disabled || _s.indexOf(l.tagName) !== -1)
    return false;
  if (l.closest(".dropdown-menu"))
    return true;
  const e = l.tagName === "LABEL" ? l : l.closest("label");
  if (e) {
    const o = e.getAttribute("for"), a = o ? document.getElementById(o) : e.querySelector("input, select, textarea");
    if (a && !a.disabled)
      return true;
  }
  return l.matches(ws);
};
var ml = ["top", "right", "bottom", "left"];
var Ao = ["start", "end"];
var No = ml.reduce((t4, l) => t4.concat(l, l + "-" + Ao[0], l + "-" + Ao[1]), []);
var We = Math.min;
var Pe = Math.max;
var da = Math.round;
var ea = Math.floor;
var pt = (t4) => ({
  x: t4,
  y: t4
});
var Cs = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var ks = {
  start: "end",
  end: "start"
};
function Ha(t4, l, e) {
  return Pe(t4, We(l, e));
}
function ct(t4, l) {
  return typeof t4 == "function" ? t4(l) : t4;
}
function Je(t4) {
  return t4.split("-")[0];
}
function at(t4) {
  return t4.split("-")[1];
}
function bl(t4) {
  return t4 === "x" ? "y" : "x";
}
function so(t4) {
  return t4 === "y" ? "height" : "width";
}
function Rt(t4) {
  return ["top", "bottom"].includes(Je(t4)) ? "y" : "x";
}
function ro(t4) {
  return bl(Rt(t4));
}
function yl(t4, l, e) {
  e === void 0 && (e = false);
  const o = at(t4), a = ro(t4), n = so(a);
  let r = a === "x" ? o === (e ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return l.reference[n] > l.floating[n] && (r = fa(r)), [r, fa(r)];
}
function Ts(t4) {
  const l = fa(t4);
  return [ca(t4), l, ca(l)];
}
function ca(t4) {
  return t4.replace(/start|end/g, (l) => ks[l]);
}
function Ss(t4, l, e) {
  const o = ["left", "right"], a = ["right", "left"], n = ["top", "bottom"], r = ["bottom", "top"];
  switch (t4) {
    case "top":
    case "bottom":
      return e ? l ? a : o : l ? o : a;
    case "left":
    case "right":
      return l ? n : r;
    default:
      return [];
  }
}
function xs(t4, l, e, o) {
  const a = at(t4);
  let n = Ss(Je(t4), e === "start", o);
  return a && (n = n.map((r) => r + "-" + a), l && (n = n.concat(n.map(ca)))), n;
}
function fa(t4) {
  return t4.replace(/left|right|bottom|top/g, (l) => Cs[l]);
}
function $s(t4) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t4
  };
}
function io(t4) {
  return typeof t4 != "number" ? $s(t4) : {
    top: t4,
    right: t4,
    bottom: t4,
    left: t4
  };
}
function Et(t4) {
  return {
    ...t4,
    top: t4.y,
    left: t4.x,
    right: t4.x + t4.width,
    bottom: t4.y + t4.height
  };
}
function Oo(t4, l, e) {
  let {
    reference: o,
    floating: a
  } = t4;
  const n = Rt(l), r = ro(l), u = so(r), i = Je(l), d = n === "y", c = o.x + o.width / 2 - a.width / 2, f = o.y + o.height / 2 - a.height / 2, p = o[u] / 2 - a[u] / 2;
  let v;
  switch (i) {
    case "top":
      v = {
        x: c,
        y: o.y - a.height
      };
      break;
    case "bottom":
      v = {
        x: c,
        y: o.y + o.height
      };
      break;
    case "right":
      v = {
        x: o.x + o.width,
        y: f
      };
      break;
    case "left":
      v = {
        x: o.x - a.width,
        y: f
      };
      break;
    default:
      v = {
        x: o.x,
        y: o.y
      };
  }
  switch (at(l)) {
    case "start":
      v[r] -= p * (e && d ? -1 : 1);
      break;
    case "end":
      v[r] += p * (e && d ? -1 : 1);
      break;
  }
  return v;
}
var Vs = async (t4, l, e) => {
  const {
    placement: o = "bottom",
    strategy: a = "absolute",
    middleware: n = [],
    platform: r
  } = e, u = n.filter(Boolean), i = await (r.isRTL == null ? void 0 : r.isRTL(l));
  let d = await r.getElementRects({
    reference: t4,
    floating: l,
    strategy: a
  }), {
    x: c,
    y: f
  } = Oo(d, o, i), p = o, v = {}, y = 0;
  for (let h2 = 0; h2 < u.length; h2++) {
    const {
      name: w,
      fn: m
    } = u[h2], {
      x: B,
      y: g,
      data: A,
      reset: C
    } = await m({
      x: c,
      y: f,
      initialPlacement: o,
      placement: p,
      strategy: a,
      middlewareData: v,
      rects: d,
      platform: r,
      elements: {
        reference: t4,
        floating: l
      }
    });
    c = B ?? c, f = g ?? f, v = {
      ...v,
      [w]: {
        ...v[w],
        ...A
      }
    }, C && y <= 50 && (y++, typeof C == "object" && (C.placement && (p = C.placement), C.rects && (d = C.rects === true ? await r.getElementRects({
      reference: t4,
      floating: l,
      strategy: a
    }) : C.rects), {
      x: c,
      y: f
    } = Oo(d, p, i)), h2 = -1);
  }
  return {
    x: c,
    y: f,
    placement: p,
    strategy: a,
    middlewareData: v
  };
};
async function Ft(t4, l) {
  var e;
  l === void 0 && (l = {});
  const {
    x: o,
    y: a,
    platform: n,
    rects: r,
    elements: u,
    strategy: i
  } = t4, {
    boundary: d = "clippingAncestors",
    rootBoundary: c = "viewport",
    elementContext: f = "floating",
    altBoundary: p = false,
    padding: v = 0
  } = ct(l, t4), y = io(v), w = u[p ? f === "floating" ? "reference" : "floating" : f], m = Et(await n.getClippingRect({
    element: (e = await (n.isElement == null ? void 0 : n.isElement(w))) == null || e ? w : w.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(u.floating)),
    boundary: d,
    rootBoundary: c,
    strategy: i
  })), B = f === "floating" ? {
    x: o,
    y: a,
    width: r.floating.width,
    height: r.floating.height
  } : r.reference, g = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(u.floating)), A = await (n.isElement == null ? void 0 : n.isElement(g)) ? await (n.getScale == null ? void 0 : n.getScale(g)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, C = Et(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: u,
    rect: B,
    offsetParent: g,
    strategy: i
  }) : B);
  return {
    top: (m.top - C.top + y.top) / A.y,
    bottom: (C.bottom - m.bottom + y.bottom) / A.y,
    left: (m.left - C.left + y.left) / A.x,
    right: (C.right - m.right + y.right) / A.x
  };
}
var As = (t4) => ({
  name: "arrow",
  options: t4,
  async fn(l) {
    const {
      x: e,
      y: o,
      placement: a,
      rects: n,
      platform: r,
      elements: u,
      middlewareData: i
    } = l, {
      element: d,
      padding: c = 0
    } = ct(t4, l) || {};
    if (d == null)
      return {};
    const f = io(c), p = {
      x: e,
      y: o
    }, v = ro(a), y = so(v), h2 = await r.getDimensions(d), w = v === "y", m = w ? "top" : "left", B = w ? "bottom" : "right", g = w ? "clientHeight" : "clientWidth", A = n.reference[y] + n.reference[v] - p[v] - n.floating[y], C = p[v] - n.reference[v], V = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(d));
    let O = V ? V[g] : 0;
    (!O || !await (r.isElement == null ? void 0 : r.isElement(V))) && (O = u.floating[g] || n.floating[y]);
    const Y = A / 2 - C / 2, U = O / 2 - h2[y] / 2 - 1, F = We(f[m], U), j = We(f[B], U), $ = F, N = O - h2[y] - j, H = O / 2 - h2[y] / 2 + Y, k = Ha($, H, N), S = !i.arrow && at(a) != null && H !== k && n.reference[y] / 2 - (H < $ ? F : j) - h2[y] / 2 < 0, E = S ? H < $ ? H - $ : H - N : 0;
    return {
      [v]: p[v] + E,
      data: {
        [v]: k,
        centerOffset: H - k - E,
        ...S && {
          alignmentOffset: E
        }
      },
      reset: S
    };
  }
});
function Ns(t4, l, e) {
  return (t4 ? [...e.filter((a) => at(a) === t4), ...e.filter((a) => at(a) !== t4)] : e.filter((a) => Je(a) === a)).filter((a) => t4 ? at(a) === t4 || (l ? ca(a) !== a : false) : true);
}
var Os = function(t4) {
  return t4 === void 0 && (t4 = {}), {
    name: "autoPlacement",
    options: t4,
    async fn(l) {
      var e, o, a;
      const {
        rects: n,
        middlewareData: r,
        placement: u,
        platform: i,
        elements: d
      } = l, {
        crossAxis: c = false,
        alignment: f,
        allowedPlacements: p = No,
        autoAlignment: v = true,
        ...y
      } = ct(t4, l), h2 = f !== void 0 || p === No ? Ns(f || null, v, p) : p, w = await Ft(l, y), m = ((e = r.autoPlacement) == null ? void 0 : e.index) || 0, B = h2[m];
      if (B == null)
        return {};
      const g = yl(B, n, await (i.isRTL == null ? void 0 : i.isRTL(d.floating)));
      if (u !== B)
        return {
          reset: {
            placement: h2[0]
          }
        };
      const A = [w[Je(B)], w[g[0]], w[g[1]]], C = [...((o = r.autoPlacement) == null ? void 0 : o.overflows) || [], {
        placement: B,
        overflows: A
      }], V = h2[m + 1];
      if (V)
        return {
          data: {
            index: m + 1,
            overflows: C
          },
          reset: {
            placement: V
          }
        };
      const O = C.map((F) => {
        const j = at(F.placement);
        return [F.placement, j && c ? (
          // Check along the mainAxis and main crossAxis side.
          F.overflows.slice(0, 2).reduce(($, N) => $ + N, 0)
        ) : (
          // Check only the mainAxis.
          F.overflows[0]
        ), F.overflows];
      }).sort((F, j) => F[1] - j[1]), U = ((a = O.filter((F) => F[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        at(F[0]) ? 2 : 3
      ).every((j) => j <= 0))[0]) == null ? void 0 : a[0]) || O[0][0];
      return U !== u ? {
        data: {
          index: m + 1,
          overflows: C
        },
        reset: {
          placement: U
        }
      } : {};
    }
  };
};
var Ps = function(t4) {
  return t4 === void 0 && (t4 = {}), {
    name: "flip",
    options: t4,
    async fn(l) {
      var e, o;
      const {
        placement: a,
        middlewareData: n,
        rects: r,
        initialPlacement: u,
        platform: i,
        elements: d
      } = l, {
        mainAxis: c = true,
        crossAxis: f = true,
        fallbackPlacements: p,
        fallbackStrategy: v = "bestFit",
        fallbackAxisSideDirection: y = "none",
        flipAlignment: h2 = true,
        ...w
      } = ct(t4, l);
      if ((e = n.arrow) != null && e.alignmentOffset)
        return {};
      const m = Je(a), B = Je(u) === u, g = await (i.isRTL == null ? void 0 : i.isRTL(d.floating)), A = p || (B || !h2 ? [fa(u)] : Ts(u));
      !p && y !== "none" && A.push(...xs(u, h2, y, g));
      const C = [u, ...A], V = await Ft(l, w), O = [];
      let Y = ((o = n.flip) == null ? void 0 : o.overflows) || [];
      if (c && O.push(V[m]), f) {
        const $ = yl(a, r, g);
        O.push(V[$[0]], V[$[1]]);
      }
      if (Y = [...Y, {
        placement: a,
        overflows: O
      }], !O.every(($) => $ <= 0)) {
        var U, F;
        const $ = (((U = n.flip) == null ? void 0 : U.index) || 0) + 1, N = C[$];
        if (N)
          return {
            data: {
              index: $,
              overflows: Y
            },
            reset: {
              placement: N
            }
          };
        let H = (F = Y.filter((k) => k.overflows[0] <= 0).sort((k, S) => k.overflows[1] - S.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!H)
          switch (v) {
            case "bestFit": {
              var j;
              const k = (j = Y.map((S) => [S.placement, S.overflows.filter((E) => E > 0).reduce((E, M) => E + M, 0)]).sort((S, E) => S[1] - E[1])[0]) == null ? void 0 : j[0];
              k && (H = k);
              break;
            }
            case "initialPlacement":
              H = u;
              break;
          }
        if (a !== H)
          return {
            reset: {
              placement: H
            }
          };
      }
      return {};
    }
  };
};
function Po(t4, l) {
  return {
    top: t4.top - l.height,
    right: t4.right - l.width,
    bottom: t4.bottom - l.height,
    left: t4.left - l.width
  };
}
function Eo(t4) {
  return ml.some((l) => t4[l] >= 0);
}
var Es = function(t4) {
  return t4 === void 0 && (t4 = {}), {
    name: "hide",
    options: t4,
    async fn(l) {
      const {
        rects: e
      } = l, {
        strategy: o = "referenceHidden",
        ...a
      } = ct(t4, l);
      switch (o) {
        case "referenceHidden": {
          const n = await Ft(l, {
            ...a,
            elementContext: "reference"
          }), r = Po(n, e.reference);
          return {
            data: {
              referenceHiddenOffsets: r,
              referenceHidden: Eo(r)
            }
          };
        }
        case "escaped": {
          const n = await Ft(l, {
            ...a,
            altBoundary: true
          }), r = Po(n, e.floating);
          return {
            data: {
              escapedOffsets: r,
              escaped: Eo(r)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function gl(t4) {
  const l = We(...t4.map((n) => n.left)), e = We(...t4.map((n) => n.top)), o = Pe(...t4.map((n) => n.right)), a = Pe(...t4.map((n) => n.bottom));
  return {
    x: l,
    y: e,
    width: o - l,
    height: a - e
  };
}
function Fs(t4) {
  const l = t4.slice().sort((a, n) => a.y - n.y), e = [];
  let o = null;
  for (let a = 0; a < l.length; a++) {
    const n = l[a];
    !o || n.y - o.y > o.height / 2 ? e.push([n]) : e[e.length - 1].push(n), o = n;
  }
  return e.map((a) => Et(gl(a)));
}
var Is = function(t4) {
  return t4 === void 0 && (t4 = {}), {
    name: "inline",
    options: t4,
    async fn(l) {
      const {
        placement: e,
        elements: o,
        rects: a,
        platform: n,
        strategy: r
      } = l, {
        padding: u = 2,
        x: i,
        y: d
      } = ct(t4, l), c = Array.from(await (n.getClientRects == null ? void 0 : n.getClientRects(o.reference)) || []), f = Fs(c), p = Et(gl(c)), v = io(u);
      function y() {
        if (f.length === 2 && f[0].left > f[1].right && i != null && d != null)
          return f.find((w) => i > w.left - v.left && i < w.right + v.right && d > w.top - v.top && d < w.bottom + v.bottom) || p;
        if (f.length >= 2) {
          if (Rt(e) === "y") {
            const F = f[0], j = f[f.length - 1], $ = Je(e) === "top", N = F.top, H = j.bottom, k = $ ? F.left : j.left, S = $ ? F.right : j.right, E = S - k, M = H - N;
            return {
              top: N,
              bottom: H,
              left: k,
              right: S,
              width: E,
              height: M,
              x: k,
              y: N
            };
          }
          const w = Je(e) === "left", m = Pe(...f.map((F) => F.right)), B = We(...f.map((F) => F.left)), g = f.filter((F) => w ? F.left === B : F.right === m), A = g[0].top, C = g[g.length - 1].bottom, V = B, O = m, Y = O - V, U = C - A;
          return {
            top: A,
            bottom: C,
            left: V,
            right: O,
            width: Y,
            height: U,
            x: V,
            y: A
          };
        }
        return p;
      }
      const h2 = await n.getElementRects({
        reference: {
          getBoundingClientRect: y
        },
        floating: o.floating,
        strategy: r
      });
      return a.reference.x !== h2.reference.x || a.reference.y !== h2.reference.y || a.reference.width !== h2.reference.width || a.reference.height !== h2.reference.height ? {
        reset: {
          rects: h2
        }
      } : {};
    }
  };
};
async function Ls(t4, l) {
  const {
    placement: e,
    platform: o,
    elements: a
  } = t4, n = await (o.isRTL == null ? void 0 : o.isRTL(a.floating)), r = Je(e), u = at(e), i = Rt(e) === "y", d = ["left", "top"].includes(r) ? -1 : 1, c = n && i ? -1 : 1, f = ct(l, t4);
  let {
    mainAxis: p,
    crossAxis: v,
    alignmentAxis: y
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...f
  };
  return u && typeof y == "number" && (v = u === "end" ? y * -1 : y), i ? {
    x: v * c,
    y: p * d
  } : {
    x: p * d,
    y: v * c
  };
}
var Rs = function(t4) {
  return t4 === void 0 && (t4 = 0), {
    name: "offset",
    options: t4,
    async fn(l) {
      var e, o;
      const {
        x: a,
        y: n,
        placement: r,
        middlewareData: u
      } = l, i = await Ls(l, t4);
      return r === ((e = u.offset) == null ? void 0 : e.placement) && (o = u.arrow) != null && o.alignmentOffset ? {} : {
        x: a + i.x,
        y: n + i.y,
        data: {
          ...i,
          placement: r
        }
      };
    }
  };
};
var zs = function(t4) {
  return t4 === void 0 && (t4 = {}), {
    name: "shift",
    options: t4,
    async fn(l) {
      const {
        x: e,
        y: o,
        placement: a
      } = l, {
        mainAxis: n = true,
        crossAxis: r = false,
        limiter: u = {
          fn: (w) => {
            let {
              x: m,
              y: B
            } = w;
            return {
              x: m,
              y: B
            };
          }
        },
        ...i
      } = ct(t4, l), d = {
        x: e,
        y: o
      }, c = await Ft(l, i), f = Rt(Je(a)), p = bl(f);
      let v = d[p], y = d[f];
      if (n) {
        const w = p === "y" ? "top" : "left", m = p === "y" ? "bottom" : "right", B = v + c[w], g = v - c[m];
        v = Ha(B, v, g);
      }
      if (r) {
        const w = f === "y" ? "top" : "left", m = f === "y" ? "bottom" : "right", B = y + c[w], g = y - c[m];
        y = Ha(B, y, g);
      }
      const h2 = u.fn({
        ...l,
        [p]: v,
        [f]: y
      });
      return {
        ...h2,
        data: {
          x: h2.x - e,
          y: h2.y - o
        }
      };
    }
  };
};
var Ms = function(t4) {
  return t4 === void 0 && (t4 = {}), {
    name: "size",
    options: t4,
    async fn(l) {
      const {
        placement: e,
        rects: o,
        platform: a,
        elements: n
      } = l, {
        apply: r = () => {
        },
        ...u
      } = ct(t4, l), i = await Ft(l, u), d = Je(e), c = at(e), f = Rt(e) === "y", {
        width: p,
        height: v
      } = o.floating;
      let y, h2;
      d === "top" || d === "bottom" ? (y = d, h2 = c === (await (a.isRTL == null ? void 0 : a.isRTL(n.floating)) ? "start" : "end") ? "left" : "right") : (h2 = d, y = c === "end" ? "top" : "bottom");
      const w = v - i.top - i.bottom, m = p - i.left - i.right, B = We(v - i[y], w), g = We(p - i[h2], m), A = !l.middlewareData.shift;
      let C = B, V = g;
      if (f ? V = c || A ? We(g, m) : m : C = c || A ? We(B, w) : w, A && !c) {
        const Y = Pe(i.left, 0), U = Pe(i.right, 0), F = Pe(i.top, 0), j = Pe(i.bottom, 0);
        f ? V = p - 2 * (Y !== 0 || U !== 0 ? Y + U : Pe(i.left, i.right)) : C = v - 2 * (F !== 0 || j !== 0 ? F + j : Pe(i.top, i.bottom));
      }
      await r({
        ...l,
        availableWidth: V,
        availableHeight: C
      });
      const O = await a.getDimensions(n.floating);
      return p !== O.width || v !== O.height ? {
        reset: {
          rects: true
        }
      } : {};
    }
  };
};
function kt(t4) {
  return uo(t4) ? (t4.nodeName || "").toLowerCase() : "#document";
}
function Ge(t4) {
  var l;
  return (t4 == null || (l = t4.ownerDocument) == null ? void 0 : l.defaultView) || window;
}
function ft(t4) {
  var l;
  return (l = (uo(t4) ? t4.ownerDocument : t4.document) || window.document) == null ? void 0 : l.documentElement;
}
function uo(t4) {
  return t4 instanceof Node || t4 instanceof Ge(t4).Node;
}
function nt(t4) {
  return t4 instanceof Element || t4 instanceof Ge(t4).Element;
}
function st(t4) {
  return t4 instanceof HTMLElement || t4 instanceof Ge(t4).HTMLElement;
}
function Fo(t4) {
  return typeof ShadowRoot > "u" ? false : t4 instanceof ShadowRoot || t4 instanceof Ge(t4).ShadowRoot;
}
function Yt(t4) {
  const {
    overflow: l,
    overflowX: e,
    overflowY: o,
    display: a
  } = ot(t4);
  return /auto|scroll|overlay|hidden|clip/.test(l + o + e) && !["inline", "contents"].includes(a);
}
function Hs(t4) {
  return ["table", "td", "th"].includes(kt(t4));
}
function co(t4) {
  const l = fo(), e = ot(t4);
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : false) || !l && (e.backdropFilter ? e.backdropFilter !== "none" : false) || !l && (e.filter ? e.filter !== "none" : false) || ["transform", "perspective", "filter"].some((o) => (e.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (e.contain || "").includes(o));
}
function Ds(t4) {
  let l = mt(t4);
  for (; st(l) && !It(l); ) {
    if (co(l))
      return l;
    l = mt(l);
  }
  return null;
}
function fo() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
function It(t4) {
  return ["html", "body", "#document"].includes(kt(t4));
}
function ot(t4) {
  return Ge(t4).getComputedStyle(t4);
}
function xa(t4) {
  return nt(t4) ? {
    scrollLeft: t4.scrollLeft,
    scrollTop: t4.scrollTop
  } : {
    scrollLeft: t4.pageXOffset,
    scrollTop: t4.pageYOffset
  };
}
function mt(t4) {
  if (kt(t4) === "html")
    return t4;
  const l = (
    // Step into the shadow DOM of the parent of a slotted node.
    t4.assignedSlot || // DOM Element detected.
    t4.parentNode || // ShadowRoot detected.
    Fo(t4) && t4.host || // Fallback.
    ft(t4)
  );
  return Fo(l) ? l.host : l;
}
function hl(t4) {
  const l = mt(t4);
  return It(l) ? t4.ownerDocument ? t4.ownerDocument.body : t4.body : st(l) && Yt(l) ? l : hl(l);
}
function Wt(t4, l, e) {
  var o;
  l === void 0 && (l = []), e === void 0 && (e = true);
  const a = hl(t4), n = a === ((o = t4.ownerDocument) == null ? void 0 : o.body), r = Ge(a);
  return n ? l.concat(r, r.visualViewport || [], Yt(a) ? a : [], r.frameElement && e ? Wt(r.frameElement) : []) : l.concat(a, Wt(a, [], e));
}
function Bl(t4) {
  const l = ot(t4);
  let e = parseFloat(l.width) || 0, o = parseFloat(l.height) || 0;
  const a = st(t4), n = a ? t4.offsetWidth : e, r = a ? t4.offsetHeight : o, u = da(e) !== n || da(o) !== r;
  return u && (e = n, o = r), {
    width: e,
    height: o,
    $: u
  };
}
function vo(t4) {
  return nt(t4) ? t4 : t4.contextElement;
}
function Pt(t4) {
  const l = vo(t4);
  if (!st(l))
    return pt(1);
  const e = l.getBoundingClientRect(), {
    width: o,
    height: a,
    $: n
  } = Bl(l);
  let r = (n ? da(e.width) : e.width) / o, u = (n ? da(e.height) : e.height) / a;
  return (!r || !Number.isFinite(r)) && (r = 1), (!u || !Number.isFinite(u)) && (u = 1), {
    x: r,
    y: u
  };
}
var js = pt(0);
function _l(t4) {
  const l = Ge(t4);
  return !fo() || !l.visualViewport ? js : {
    x: l.visualViewport.offsetLeft,
    y: l.visualViewport.offsetTop
  };
}
function qs(t4, l, e) {
  return l === void 0 && (l = false), !e || l && e !== Ge(t4) ? false : l;
}
function ht(t4, l, e, o) {
  l === void 0 && (l = false), e === void 0 && (e = false);
  const a = t4.getBoundingClientRect(), n = vo(t4);
  let r = pt(1);
  l && (o ? nt(o) && (r = Pt(o)) : r = Pt(t4));
  const u = qs(n, e, o) ? _l(n) : pt(0);
  let i = (a.left + u.x) / r.x, d = (a.top + u.y) / r.y, c = a.width / r.x, f = a.height / r.y;
  if (n) {
    const p = Ge(n), v = o && nt(o) ? Ge(o) : o;
    let y = p, h2 = y.frameElement;
    for (; h2 && o && v !== y; ) {
      const w = Pt(h2), m = h2.getBoundingClientRect(), B = ot(h2), g = m.left + (h2.clientLeft + parseFloat(B.paddingLeft)) * w.x, A = m.top + (h2.clientTop + parseFloat(B.paddingTop)) * w.y;
      i *= w.x, d *= w.y, c *= w.x, f *= w.y, i += g, d += A, y = Ge(h2), h2 = y.frameElement;
    }
  }
  return Et({
    width: c,
    height: f,
    x: i,
    y: d
  });
}
var Ws = [":popover-open", ":modal"];
function po(t4) {
  return Ws.some((l) => {
    try {
      return t4.matches(l);
    } catch {
      return false;
    }
  });
}
function Gs(t4) {
  let {
    elements: l,
    rect: e,
    offsetParent: o,
    strategy: a
  } = t4;
  const n = a === "fixed", r = ft(o), u = l ? po(l.floating) : false;
  if (o === r || u && n)
    return e;
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = pt(1);
  const c = pt(0), f = st(o);
  if ((f || !f && !n) && ((kt(o) !== "body" || Yt(r)) && (i = xa(o)), st(o))) {
    const p = ht(o);
    d = Pt(o), c.x = p.x + o.clientLeft, c.y = p.y + o.clientTop;
  }
  return {
    width: e.width * d.x,
    height: e.height * d.y,
    x: e.x * d.x - i.scrollLeft * d.x + c.x,
    y: e.y * d.y - i.scrollTop * d.y + c.y
  };
}
function Us(t4) {
  return Array.from(t4.getClientRects());
}
function wl(t4) {
  return ht(ft(t4)).left + xa(t4).scrollLeft;
}
function Ks(t4) {
  const l = ft(t4), e = xa(t4), o = t4.ownerDocument.body, a = Pe(l.scrollWidth, l.clientWidth, o.scrollWidth, o.clientWidth), n = Pe(l.scrollHeight, l.clientHeight, o.scrollHeight, o.clientHeight);
  let r = -e.scrollLeft + wl(t4);
  const u = -e.scrollTop;
  return ot(o).direction === "rtl" && (r += Pe(l.clientWidth, o.clientWidth) - a), {
    width: a,
    height: n,
    x: r,
    y: u
  };
}
function Xs(t4, l) {
  const e = Ge(t4), o = ft(t4), a = e.visualViewport;
  let n = o.clientWidth, r = o.clientHeight, u = 0, i = 0;
  if (a) {
    n = a.width, r = a.height;
    const d = fo();
    (!d || d && l === "fixed") && (u = a.offsetLeft, i = a.offsetTop);
  }
  return {
    width: n,
    height: r,
    x: u,
    y: i
  };
}
function Ys(t4, l) {
  const e = ht(t4, true, l === "fixed"), o = e.top + t4.clientTop, a = e.left + t4.clientLeft, n = st(t4) ? Pt(t4) : pt(1), r = t4.clientWidth * n.x, u = t4.clientHeight * n.y, i = a * n.x, d = o * n.y;
  return {
    width: r,
    height: u,
    x: i,
    y: d
  };
}
function Io(t4, l, e) {
  let o;
  if (l === "viewport")
    o = Xs(t4, e);
  else if (l === "document")
    o = Ks(ft(t4));
  else if (nt(l))
    o = Ys(l, e);
  else {
    const a = _l(t4);
    o = {
      ...l,
      x: l.x - a.x,
      y: l.y - a.y
    };
  }
  return Et(o);
}
function Cl(t4, l) {
  const e = mt(t4);
  return e === l || !nt(e) || It(e) ? false : ot(e).position === "fixed" || Cl(e, l);
}
function Zs(t4, l) {
  const e = l.get(t4);
  if (e)
    return e;
  let o = Wt(t4, [], false).filter((u) => nt(u) && kt(u) !== "body"), a = null;
  const n = ot(t4).position === "fixed";
  let r = n ? mt(t4) : t4;
  for (; nt(r) && !It(r); ) {
    const u = ot(r), i = co(r);
    !i && u.position === "fixed" && (a = null), (n ? !i && !a : !i && u.position === "static" && !!a && ["absolute", "fixed"].includes(a.position) || Yt(r) && !i && Cl(t4, r)) ? o = o.filter((c) => c !== r) : a = u, r = mt(r);
  }
  return l.set(t4, o), o;
}
function Js(t4) {
  let {
    element: l,
    boundary: e,
    rootBoundary: o,
    strategy: a
  } = t4;
  const r = [...e === "clippingAncestors" ? po(l) ? [] : Zs(l, this._c) : [].concat(e), o], u = r[0], i = r.reduce((d, c) => {
    const f = Io(l, c, a);
    return d.top = Pe(f.top, d.top), d.right = We(f.right, d.right), d.bottom = We(f.bottom, d.bottom), d.left = Pe(f.left, d.left), d;
  }, Io(l, u, a));
  return {
    width: i.right - i.left,
    height: i.bottom - i.top,
    x: i.left,
    y: i.top
  };
}
function Qs(t4) {
  const {
    width: l,
    height: e
  } = Bl(t4);
  return {
    width: l,
    height: e
  };
}
function er(t4, l, e) {
  const o = st(l), a = ft(l), n = e === "fixed", r = ht(t4, true, n, l);
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const i = pt(0);
  if (o || !o && !n)
    if ((kt(l) !== "body" || Yt(a)) && (u = xa(l)), o) {
      const f = ht(l, true, n, l);
      i.x = f.x + l.clientLeft, i.y = f.y + l.clientTop;
    } else
      a && (i.x = wl(a));
  const d = r.left + u.scrollLeft - i.x, c = r.top + u.scrollTop - i.y;
  return {
    x: d,
    y: c,
    width: r.width,
    height: r.height
  };
}
function Oa(t4) {
  return ot(t4).position === "static";
}
function Lo(t4, l) {
  return !st(t4) || ot(t4).position === "fixed" ? null : l ? l(t4) : t4.offsetParent;
}
function kl(t4, l) {
  const e = Ge(t4);
  if (po(t4))
    return e;
  if (!st(t4)) {
    let a = mt(t4);
    for (; a && !It(a); ) {
      if (nt(a) && !Oa(a))
        return a;
      a = mt(a);
    }
    return e;
  }
  let o = Lo(t4, l);
  for (; o && Hs(o) && Oa(o); )
    o = Lo(o, l);
  return o && It(o) && Oa(o) && !co(o) ? e : o || Ds(t4) || e;
}
var tr = async function(t4) {
  const l = this.getOffsetParent || kl, e = this.getDimensions, o = await e(t4.floating);
  return {
    reference: er(t4.reference, await l(t4.floating), t4.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function ar(t4) {
  return ot(t4).direction === "rtl";
}
var or = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Gs,
  getDocumentElement: ft,
  getClippingRect: Js,
  getOffsetParent: kl,
  getElementRects: tr,
  getClientRects: Us,
  getDimensions: Qs,
  getScale: Pt,
  isElement: nt,
  isRTL: ar
};
function lr(t4, l) {
  let e = null, o;
  const a = ft(t4);
  function n() {
    var u;
    clearTimeout(o), (u = e) == null || u.disconnect(), e = null;
  }
  function r(u, i) {
    u === void 0 && (u = false), i === void 0 && (i = 1), n();
    const {
      left: d,
      top: c,
      width: f,
      height: p
    } = t4.getBoundingClientRect();
    if (u || l(), !f || !p)
      return;
    const v = ea(c), y = ea(a.clientWidth - (d + f)), h2 = ea(a.clientHeight - (c + p)), w = ea(d), B = {
      rootMargin: -v + "px " + -y + "px " + -h2 + "px " + -w + "px",
      threshold: Pe(0, We(1, i)) || 1
    };
    let g = true;
    function A(C) {
      const V = C[0].intersectionRatio;
      if (V !== i) {
        if (!g)
          return r();
        V ? r(false, V) : o = setTimeout(() => {
          r(false, 1e-7);
        }, 1e3);
      }
      g = false;
    }
    try {
      e = new IntersectionObserver(A, {
        ...B,
        // Handle <iframe>s
        root: a.ownerDocument
      });
    } catch {
      e = new IntersectionObserver(A, B);
    }
    e.observe(t4);
  }
  return r(true), n;
}
function Tl(t4, l, e, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: a = true,
    ancestorResize: n = true,
    elementResize: r = typeof ResizeObserver == "function",
    layoutShift: u = typeof IntersectionObserver == "function",
    animationFrame: i = false
  } = o, d = vo(t4), c = a || n ? [...d ? Wt(d) : [], ...Wt(l)] : [];
  c.forEach((m) => {
    a && m.addEventListener("scroll", e, {
      passive: true
    }), n && m.addEventListener("resize", e);
  });
  const f = d && u ? lr(d, e) : null;
  let p = -1, v = null;
  r && (v = new ResizeObserver((m) => {
    let [B] = m;
    B && B.target === d && v && (v.unobserve(l), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var g;
      (g = v) == null || g.observe(l);
    })), e();
  }), d && !i && v.observe(d), v.observe(l));
  let y, h2 = i ? ht(t4) : null;
  i && w();
  function w() {
    const m = ht(t4);
    h2 && (m.x !== h2.x || m.y !== h2.y || m.width !== h2.width || m.height !== h2.height) && e(), h2 = m, y = requestAnimationFrame(w);
  }
  return e(), () => {
    var m;
    c.forEach((B) => {
      a && B.removeEventListener("scroll", e), n && B.removeEventListener("resize", e);
    }), f == null || f(), (m = v) == null || m.disconnect(), v = null, i && cancelAnimationFrame(y);
  };
}
var Sl = Rs;
var nr = Os;
var xl = zs;
var $l = Ps;
var Vl = Ms;
var sr = Es;
var rr = As;
var ir = Is;
var ur = (t4, l, e) => {
  const o = /* @__PURE__ */ new Map(), a = {
    platform: or,
    ...e
  }, n = {
    ...a.platform,
    _c: o
  };
  return Vs(t4, l, {
    ...a,
    platform: n
  });
};
function dr(t4) {
  return t4 != null && typeof t4 == "object" && "$el" in t4;
}
function Da(t4) {
  if (dr(t4)) {
    const l = t4.$el;
    return uo(l) && kt(l) === "#comment" ? null : l;
  }
  return t4;
}
function cr(t4) {
  return {
    name: "arrow",
    options: t4,
    fn(l) {
      const e = Da(unref(t4.element));
      return e == null ? {} : rr({
        element: e,
        padding: t4.padding
      }).fn(l);
    }
  };
}
function Al(t4) {
  return typeof window > "u" ? 1 : (t4.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Ro(t4, l) {
  const e = Al(t4);
  return Math.round(l * e) / e;
}
function Nl(t4, l, e) {
  e === void 0 && (e = {});
  const o = e.whileElementsMounted, a = computed(() => {
    var O;
    return (O = unref(e.open)) != null ? O : true;
  }), n = computed(() => unref(e.middleware)), r = computed(() => {
    var O;
    return (O = unref(e.placement)) != null ? O : "bottom";
  }), u = computed(() => {
    var O;
    return (O = unref(e.strategy)) != null ? O : "absolute";
  }), i = computed(() => {
    var O;
    return (O = unref(e.transform)) != null ? O : true;
  }), d = computed(() => Da(t4.value)), c = computed(() => Da(l.value)), f = ref(0), p = ref(0), v = ref(u.value), y = ref(r.value), h2 = shallowRef({}), w = ref(false), m = computed(() => {
    const O = {
      position: v.value,
      left: "0",
      top: "0"
    };
    if (!c.value)
      return O;
    const Y = Ro(c.value, f.value), U = Ro(c.value, p.value);
    return i.value ? {
      ...O,
      transform: "translate(" + Y + "px, " + U + "px)",
      ...Al(c.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: v.value,
      left: Y + "px",
      top: U + "px"
    };
  });
  let B;
  function g() {
    d.value == null || c.value == null || ur(d.value, c.value, {
      middleware: n.value,
      placement: r.value,
      strategy: u.value
    }).then((O) => {
      f.value = O.x, p.value = O.y, v.value = O.strategy, y.value = O.placement, h2.value = O.middlewareData, w.value = true;
    });
  }
  function A() {
    typeof B == "function" && (B(), B = void 0);
  }
  function C() {
    if (A(), o === void 0) {
      g();
      return;
    }
    if (d.value != null && c.value != null) {
      B = o(d.value, c.value, g);
      return;
    }
  }
  function V() {
    a.value || (w.value = false);
  }
  return watch([n, r, u], g, {
    flush: "sync"
  }), watch([d, c], C, {
    flush: "sync"
  }), watch(a, V, {
    flush: "sync"
  }), getCurrentScope() && onScopeDispose(A), {
    x: shallowReadonly(f),
    y: shallowReadonly(p),
    strategy: shallowReadonly(v),
    placement: shallowReadonly(y),
    middlewareData: shallowReadonly(h2),
    isPositioned: shallowReadonly(w),
    floatingStyles: m,
    update: g
  };
}
var fr = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]);
var vr = /^aria-[\w-]*$/i;
var pr = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
var mr = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
var br = (t4, l) => {
  const e = t4.nodeName.toLowerCase();
  return l.includes(e) ? fr.has(e) ? !!(pr.test(t4.nodeValue || "") || mr.test(t4.nodeValue || "")) : true : l.filter((o) => o instanceof RegExp).some((o) => o.test(e));
};
var At = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", vr],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
var Nt = (t4, l, e) => {
  if (!t4.length)
    return t4;
  if (e && typeof e == "function")
    return e(t4);
  const a = new window.DOMParser().parseFromString(t4, "text/html"), n = a.body.querySelectorAll("*");
  for (const r of n) {
    const u = r.nodeName.toLowerCase();
    if (!Object.keys(l).includes(u)) {
      r.remove();
      continue;
    }
    const i = r.attributes, d = [...l["*"] || [], ...l[u] || []];
    for (const c of i)
      br(c, d) || r.removeAttribute(c.nodeName);
  }
  return a.body.innerHTML;
};
function rt(t4) {
  return getCurrentScope() ? (onScopeDispose(t4), true) : false;
}
function yr(t4, l) {
  if (typeof Symbol < "u") {
    const e = { ...t4 };
    return Object.defineProperty(e, Symbol.iterator, {
      enumerable: false,
      value() {
        let o = 0;
        return {
          next: () => ({
            value: l[o++],
            done: o > l.length
          })
        };
      }
    }), e;
  } else
    return Object.assign([...l], t4);
}
function Fe(t4) {
  return typeof t4 == "function" ? t4() : unref(t4);
}
var va = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
var Ol = (t4) => t4 != null;
var gr = Object.prototype.toString;
var hr = (t4) => gr.call(t4) === "[object Object]";
var Ze = () => {
};
var ja = Br();
function Br() {
  var t4, l;
  return va && ((t4 = window == null ? void 0 : window.navigator) == null ? void 0 : t4.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((l = window == null ? void 0 : window.navigator) == null ? void 0 : l.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function Pl(t4, l) {
  function e(...o) {
    return new Promise((a, n) => {
      Promise.resolve(t4(() => l.apply(this, o), { fn: l, thisArg: this, args: o })).then(a).catch(n);
    });
  }
  return e;
}
var El = (t4) => t4();
function _r(t4, l = {}) {
  let e, o, a = Ze;
  const n = (u) => {
    clearTimeout(u), a(), a = Ze;
  };
  return (u) => {
    const i = Fe(t4), d = Fe(l.maxWait);
    return e && n(e), i <= 0 || d !== void 0 && d <= 0 ? (o && (n(o), o = null), Promise.resolve(u())) : new Promise((c, f) => {
      a = l.rejectOnCancel ? f : c, d && !o && (o = setTimeout(() => {
        e && n(e), o = null, c(u());
      }, d)), e = setTimeout(() => {
        o && n(o), o = null, c(u());
      }, i);
    });
  };
}
function wr(t4 = El) {
  const l = ref(true);
  function e() {
    l.value = false;
  }
  function o() {
    l.value = true;
  }
  const a = (...n) => {
    l.value && t4(...n);
  };
  return { isActive: readonly(l), pause: e, resume: o, eventFilter: a };
}
function Cr(t4) {
  const l = /* @__PURE__ */ Object.create(null);
  return (e) => l[e] || (l[e] = t4(e));
}
var kr = /-(\w)/g;
var Tr = Cr((t4) => t4.replace(kr, (l, e) => e ? e.toUpperCase() : ""));
function Sr(t4, l) {
  var e;
  if (typeof t4 == "number")
    return t4 + l;
  const o = ((e = t4.match(/^-?\d+\.?\d*/)) == null ? void 0 : e[0]) || "", a = t4.slice(o.length), n = Number.parseFloat(o) + l;
  return Number.isNaN(n) ? t4 : n + a;
}
function xr(t4) {
  return t4 || getCurrentInstance();
}
function Fl(...t4) {
  if (t4.length !== 1)
    return toRef(...t4);
  const l = t4[0];
  return typeof l == "function" ? readonly(customRef(() => ({ get: l, set: Ze }))) : ref(l);
}
function $r(t4, l = 200, e = {}) {
  return Pl(
    _r(l, e),
    t4
  );
}
function Vr(t4, l, e = {}) {
  const {
    eventFilter: o = El,
    ...a
  } = e;
  return watch(
    t4,
    Pl(
      o,
      l
    ),
    a
  );
}
function qa(t4, l, e = {}) {
  const {
    eventFilter: o,
    ...a
  } = e, { eventFilter: n, pause: r, resume: u, isActive: i } = wr(o);
  return { stop: Vr(
    t4,
    l,
    {
      ...a,
      eventFilter: n
    }
  ), pause: r, resume: u, isActive: i };
}
function Wa(t4, l, ...[e]) {
  const {
    flush: o = "sync",
    deep: a = false,
    immediate: n = true,
    direction: r = "both",
    transform: u = {}
  } = e || {}, i = [], d = "ltr" in u && u.ltr || ((p) => p), c = "rtl" in u && u.rtl || ((p) => p);
  return (r === "both" || r === "ltr") && i.push(qa(
    t4,
    (p) => {
      i.forEach((v) => v.pause()), l.value = d(p), i.forEach((v) => v.resume());
    },
    { flush: o, deep: a, immediate: n }
  )), (r === "both" || r === "rtl") && i.push(qa(
    l,
    (p) => {
      i.forEach((v) => v.pause()), t4.value = c(p), i.forEach((v) => v.resume());
    },
    { flush: o, deep: a, immediate: n }
  )), () => {
    i.forEach((p) => p.stop());
  };
}
function Il(t4, l = true, e) {
  xr() ? onMounted(t4, e) : l ? t4() : nextTick(t4);
}
function Ll(t4, l = 1e3, e = {}) {
  const {
    immediate: o = true,
    immediateCallback: a = false
  } = e;
  let n = null;
  const r = ref(false);
  function u() {
    n && (clearInterval(n), n = null);
  }
  function i() {
    r.value = false, u();
  }
  function d() {
    const c = Fe(l);
    c <= 0 || (r.value = true, a && t4(), u(), n = setInterval(t4, c));
  }
  if (o && va && d(), isRef(l) || typeof l == "function") {
    const c = watch(l, () => {
      r.value && va && d();
    });
    rt(c);
  }
  return rt(i), {
    isActive: r,
    pause: i,
    resume: d
  };
}
function _e(t4, l = {}) {
  const {
    method: e = "parseFloat",
    radix: o,
    nanToZero: a
  } = l;
  return computed(() => {
    let n = Fe(t4);
    return typeof n == "string" && (n = Number[e](n, o)), a && Number.isNaN(n) && (n = 0), n;
  });
}
function pa(t4 = {}) {
  const {
    inheritAttrs: l = true
  } = t4, e = shallowRef(), o = defineComponent({
    setup(n, { slots: r }) {
      return () => {
        e.value = r.default;
      };
    }
  }), a = defineComponent({
    inheritAttrs: l,
    setup(n, { attrs: r, slots: u }) {
      return () => {
        var i;
        if (!e.value && true)
          throw new Error("[VueUse] Failed to find the definition of reusable template");
        const d = (i = e.value) == null ? void 0 : i.call(e, { ...Ar(r), $slots: u });
        return l && (d == null ? void 0 : d.length) === 1 ? d[0] : d;
      };
    }
  });
  return yr(
    { define: o, reuse: a },
    [o, a]
  );
}
function Ar(t4) {
  const l = {};
  for (const e in t4)
    l[Tr(e)] = t4[e];
  return l;
}
function Le(t4) {
  var l;
  const e = Fe(t4);
  return (l = e == null ? void 0 : e.$el) != null ? l : e;
}
var Me = va ? window : void 0;
function Ve(...t4) {
  let l, e, o, a;
  if (typeof t4[0] == "string" || Array.isArray(t4[0]) ? ([e, o, a] = t4, l = Me) : [l, e, o, a] = t4, !l)
    return Ze;
  Array.isArray(e) || (e = [e]), Array.isArray(o) || (o = [o]);
  const n = [], r = () => {
    n.forEach((c) => c()), n.length = 0;
  }, u = (c, f, p, v) => (c.addEventListener(f, p, v), () => c.removeEventListener(f, p, v)), i = watch(
    () => [Le(l), Fe(a)],
    ([c, f]) => {
      if (r(), !c)
        return;
      const p = hr(f) ? { ...f } : f;
      n.push(
        ...e.flatMap((v) => o.map((y) => u(c, v, y, p)))
      );
    },
    { immediate: true, flush: "post" }
  ), d = () => {
    i(), r();
  };
  return rt(d), d;
}
var zo = false;
function Rl(t4, l, e = {}) {
  const { window: o = Me, ignore: a = [], capture: n = true, detectIframe: r = false } = e;
  if (!o)
    return Ze;
  ja && !zo && (zo = true, Array.from(o.document.body.children).forEach((p) => p.addEventListener("click", Ze)), o.document.documentElement.addEventListener("click", Ze));
  let u = true;
  const i = (p) => a.some((v) => {
    if (typeof v == "string")
      return Array.from(o.document.querySelectorAll(v)).some((y) => y === p.target || p.composedPath().includes(y));
    {
      const y = Le(v);
      return y && (p.target === y || p.composedPath().includes(y));
    }
  }), c = [
    Ve(o, "click", (p) => {
      const v = Le(t4);
      if (!(!v || v === p.target || p.composedPath().includes(v))) {
        if (p.detail === 0 && (u = !i(p)), !u) {
          u = true;
          return;
        }
        l(p);
      }
    }, { passive: true, capture: n }),
    Ve(o, "pointerdown", (p) => {
      const v = Le(t4);
      u = !i(p) && !!(v && !p.composedPath().includes(v));
    }, { passive: true }),
    r && Ve(o, "blur", (p) => {
      setTimeout(() => {
        var v;
        const y = Le(t4);
        ((v = o.document.activeElement) == null ? void 0 : v.tagName) === "IFRAME" && !(y != null && y.contains(o.document.activeElement)) && l(p);
      }, 0);
    })
  ].filter(Boolean);
  return () => c.forEach((p) => p());
}
function Nr(t4) {
  return typeof t4 == "function" ? t4 : typeof t4 == "string" ? (l) => l.key === t4 : Array.isArray(t4) ? (l) => t4.includes(l.key) : () => true;
}
function qe(...t4) {
  let l, e, o = {};
  t4.length === 3 ? (l = t4[0], e = t4[1], o = t4[2]) : t4.length === 2 ? typeof t4[1] == "object" ? (l = true, e = t4[0], o = t4[1]) : (l = t4[0], e = t4[1]) : (l = true, e = t4[0]);
  const {
    target: a = Me,
    eventName: n = "keydown",
    passive: r = false,
    dedupe: u = false
  } = o, i = Nr(l);
  return Ve(a, n, (c) => {
    c.repeat && Fe(u) || i(c) && e(c);
  }, r);
}
function Or() {
  const t4 = ref(false), l = getCurrentInstance();
  return l && onMounted(() => {
    t4.value = true;
  }, l), t4;
}
function mo(t4) {
  const l = Or();
  return computed(() => (l.value, !!t4()));
}
function Pr(t4, l, e = {}) {
  const { window: o = Me, ...a } = e;
  let n;
  const r = mo(() => o && "MutationObserver" in o), u = () => {
    n && (n.disconnect(), n = void 0);
  }, i = computed(() => {
    const p = Fe(t4), v = (Array.isArray(p) ? p : [p]).map(Le).filter(Ol);
    return new Set(v);
  }), d = watch(
    () => i.value,
    (p) => {
      u(), r.value && p.size && (n = new MutationObserver(l), p.forEach((v) => n.observe(v, a)));
    },
    { immediate: true, flush: "post" }
  ), c = () => n == null ? void 0 : n.takeRecords(), f = () => {
    u(), d();
  };
  return rt(f), {
    isSupported: r,
    stop: f,
    takeRecords: c
  };
}
function Vt(t4, l = {}) {
  const { window: e = Me } = l, o = mo(() => e && "matchMedia" in e && typeof e.matchMedia == "function");
  let a;
  const n = ref(false), r = (d) => {
    n.value = d.matches;
  }, u = () => {
    a && ("removeEventListener" in a ? a.removeEventListener("change", r) : a.removeListener(r));
  }, i = watchEffect(() => {
    o.value && (u(), a = e.matchMedia(Fe(t4)), "addEventListener" in a ? a.addEventListener("change", r) : a.addListener(r), n.value = a.matches);
  });
  return rt(() => {
    i(), u(), a = void 0;
  }), n;
}
var Er = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200,
  xxl: 1400
};
function Fr(t4, l = {}) {
  function e(c, f) {
    let p = Fe(t4[Fe(c)]);
    return f != null && (p = Sr(p, f)), typeof p == "number" && (p = `${p}px`), p;
  }
  const { window: o = Me, strategy: a = "min-width" } = l;
  function n(c) {
    return o ? o.matchMedia(c).matches : false;
  }
  const r = (c) => Vt(() => `(min-width: ${e(c)})`, l), u = (c) => Vt(() => `(max-width: ${e(c)})`, l), i = Object.keys(t4).reduce((c, f) => (Object.defineProperty(c, f, {
    get: () => a === "min-width" ? r(f) : u(f),
    enumerable: true,
    configurable: true
  }), c), {});
  function d() {
    const c = Object.keys(t4).map((f) => [f, r(f)]);
    return computed(() => c.filter(([, f]) => f.value).map(([f]) => f));
  }
  return Object.assign(i, {
    greaterOrEqual: r,
    smallerOrEqual: u,
    greater(c) {
      return Vt(() => `(min-width: ${e(c, 0.1)})`, l);
    },
    smaller(c) {
      return Vt(() => `(max-width: ${e(c, -0.1)})`, l);
    },
    between(c, f) {
      return Vt(() => `(min-width: ${e(c)}) and (max-width: ${e(f, -0.1)})`, l);
    },
    isGreater(c) {
      return n(`(min-width: ${e(c, 0.1)})`);
    },
    isGreaterOrEqual(c) {
      return n(`(min-width: ${e(c)})`);
    },
    isSmaller(c) {
      return n(`(max-width: ${e(c, -0.1)})`);
    },
    isSmallerOrEqual(c) {
      return n(`(max-width: ${e(c)})`);
    },
    isInBetween(c, f) {
      return n(`(min-width: ${e(c)}) and (max-width: ${e(f, -0.1)})`);
    },
    current: d,
    active() {
      const c = d();
      return computed(() => c.value.length === 0 ? "" : c.value.at(-1));
    }
  });
}
var ta = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var aa = "__vueuse_ssr_handlers__";
var Ir = Lr();
function Lr() {
  return aa in ta || (ta[aa] = ta[aa] || {}), ta[aa];
}
function bo(t4, l) {
  return Ir[t4] || l;
}
function Rr(t4) {
  return t4 == null ? "any" : t4 instanceof Set ? "set" : t4 instanceof Map ? "map" : t4 instanceof Date ? "date" : typeof t4 == "boolean" ? "boolean" : typeof t4 == "string" ? "string" : typeof t4 == "object" ? "object" : Number.isNaN(t4) ? "any" : "number";
}
var zr = {
  boolean: {
    read: (t4) => t4 === "true",
    write: (t4) => String(t4)
  },
  object: {
    read: (t4) => JSON.parse(t4),
    write: (t4) => JSON.stringify(t4)
  },
  number: {
    read: (t4) => Number.parseFloat(t4),
    write: (t4) => String(t4)
  },
  any: {
    read: (t4) => t4,
    write: (t4) => String(t4)
  },
  string: {
    read: (t4) => t4,
    write: (t4) => String(t4)
  },
  map: {
    read: (t4) => new Map(JSON.parse(t4)),
    write: (t4) => JSON.stringify(Array.from(t4.entries()))
  },
  set: {
    read: (t4) => new Set(JSON.parse(t4)),
    write: (t4) => JSON.stringify(Array.from(t4))
  },
  date: {
    read: (t4) => new Date(t4),
    write: (t4) => t4.toISOString()
  }
};
var Mo = "vueuse-storage";
function Mr(t4, l, e, o = {}) {
  var a;
  const {
    flush: n = "pre",
    deep: r = true,
    listenToStorageChanges: u = true,
    writeDefaults: i = true,
    mergeDefaults: d = false,
    shallow: c,
    window: f = Me,
    eventFilter: p,
    onError: v = (F) => {
      console.error(F);
    },
    initOnMounted: y
  } = o, h2 = (c ? shallowRef : ref)(typeof l == "function" ? l() : l);
  if (!e)
    try {
      e = bo("getDefaultStorage", () => {
        var F;
        return (F = Me) == null ? void 0 : F.localStorage;
      })();
    } catch (F) {
      v(F);
    }
  if (!e)
    return h2;
  const w = Fe(l), m = Rr(w), B = (a = o.serializer) != null ? a : zr[m], { pause: g, resume: A } = qa(
    h2,
    () => V(h2.value),
    { flush: n, deep: r, eventFilter: p }
  );
  f && u && Il(() => {
    Ve(f, "storage", Y), Ve(f, Mo, U), y && Y();
  }), y || Y();
  function C(F, j) {
    f && f.dispatchEvent(new CustomEvent(Mo, {
      detail: {
        key: t4,
        oldValue: F,
        newValue: j,
        storageArea: e
      }
    }));
  }
  function V(F) {
    try {
      const j = e.getItem(t4);
      if (F == null)
        C(j, null), e.removeItem(t4);
      else {
        const $ = B.write(F);
        j !== $ && (e.setItem(t4, $), C(j, $));
      }
    } catch (j) {
      v(j);
    }
  }
  function O(F) {
    const j = F ? F.newValue : e.getItem(t4);
    if (j == null)
      return i && w != null && e.setItem(t4, B.write(w)), w;
    if (!F && d) {
      const $ = B.read(j);
      return typeof d == "function" ? d($, w) : m === "object" && !Array.isArray($) ? { ...w, ...$ } : $;
    } else
      return typeof j != "string" ? j : B.read(j);
  }
  function Y(F) {
    if (!(F && F.storageArea !== e)) {
      if (F && F.key == null) {
        h2.value = w;
        return;
      }
      if (!(F && F.key !== t4)) {
        g();
        try {
          (F == null ? void 0 : F.newValue) !== B.write(h2.value) && (h2.value = O(F));
        } catch (j) {
          v(j);
        } finally {
          F ? nextTick(A) : A();
        }
      }
    }
  }
  function U(F) {
    Y(F.detail);
  }
  return h2;
}
function Hr(t4) {
  return Vt("(prefers-color-scheme: dark)", t4);
}
function Dr(t4 = {}) {
  const {
    selector: l = "html",
    attribute: e = "class",
    initialValue: o = "auto",
    window: a = Me,
    storage: n,
    storageKey: r = "vueuse-color-scheme",
    listenToStorageChanges: u = true,
    storageRef: i,
    emitAuto: d,
    disableTransition: c = true
  } = t4, f = {
    auto: "",
    light: "light",
    dark: "dark",
    ...t4.modes || {}
  }, p = Hr({ window: a }), v = computed(() => p.value ? "dark" : "light"), y = i || (r == null ? Fl(o) : Mr(r, o, n, { window: a, listenToStorageChanges: u })), h2 = computed(() => y.value === "auto" ? v.value : y.value), w = bo(
    "updateHTMLAttrs",
    (A, C, V) => {
      const O = typeof A == "string" ? a == null ? void 0 : a.document.querySelector(A) : Le(A);
      if (!O)
        return;
      let Y;
      if (c && (Y = a.document.createElement("style"), Y.appendChild(document.createTextNode("*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}")), a.document.head.appendChild(Y)), C === "class") {
        const U = V.split(/\s/g);
        Object.values(f).flatMap((F) => (F || "").split(/\s/g)).filter(Boolean).forEach((F) => {
          U.includes(F) ? O.classList.add(F) : O.classList.remove(F);
        });
      } else
        O.setAttribute(C, V);
      c && (a.getComputedStyle(Y).opacity, document.head.removeChild(Y));
    }
  );
  function m(A) {
    var C;
    w(l, e, (C = f[A]) != null ? C : A);
  }
  function B(A) {
    t4.onChanged ? t4.onChanged(A, m) : m(A);
  }
  watch(h2, B, { flush: "post", immediate: true }), Il(() => B(h2.value));
  const g = computed({
    get() {
      return d ? y.value : h2.value;
    },
    set(A) {
      y.value = A;
    }
  });
  try {
    return Object.assign(g, { store: y, system: v, state: h2 });
  } catch {
    return g;
  }
}
function yo(t4, l = {}) {
  const {
    delayEnter: e = 0,
    delayLeave: o = 0,
    window: a = Me
  } = l, n = ref(false);
  let r;
  const u = (i) => {
    const d = i ? e : o;
    r && (clearTimeout(r), r = void 0), d ? r = setTimeout(() => n.value = i, d) : n.value = i;
  };
  return a && (Ve(t4, "mouseenter", () => u(true), { passive: true }), Ve(t4, "mouseleave", () => u(false), { passive: true })), n;
}
function jr(t4, l, e = {}) {
  const {
    root: o,
    rootMargin: a = "0px",
    threshold: n = 0.1,
    window: r = Me,
    immediate: u = true
  } = e, i = mo(() => r && "IntersectionObserver" in r), d = computed(() => {
    const y = Fe(t4);
    return (Array.isArray(y) ? y : [y]).map(Le).filter(Ol);
  });
  let c = Ze;
  const f = ref(u), p = i.value ? watch(
    () => [d.value, Le(o), f.value],
    ([y, h2]) => {
      if (c(), !f.value || !y.length)
        return;
      const w = new IntersectionObserver(
        l,
        {
          root: Le(h2),
          rootMargin: a,
          threshold: n
        }
      );
      y.forEach((m) => m && w.observe(m)), c = () => {
        w.disconnect(), c = Ze;
      };
    },
    { immediate: u, flush: "post" }
  ) : Ze, v = () => {
    c(), p(), f.value = false;
  };
  return rt(v), {
    isSupported: i,
    isActive: f,
    pause() {
      c(), f.value = false;
    },
    resume() {
      f.value = true;
    },
    stop: v
  };
}
function Re(t4, l = {}) {
  const { initialValue: e = false, focusVisible: o = false, preventScroll: a = false } = l, n = ref(false), r = computed(() => Le(t4));
  Ve(r, "focus", (i) => {
    var d, c;
    (!o || (c = (d = i.target).matches) != null && c.call(d, ":focus-visible")) && (n.value = true);
  }), Ve(r, "blur", () => n.value = false);
  const u = computed({
    get: () => n.value,
    set(i) {
      var d, c;
      !i && n.value ? (d = r.value) == null || d.blur() : i && !n.value && ((c = r.value) == null || c.focus({ preventScroll: a }));
    }
  });
  return watch(
    r,
    () => {
      u.value = e;
    },
    { immediate: true, flush: "post" }
  ), { focused: u };
}
function Pa(t4) {
  return typeof Window < "u" && t4 instanceof Window ? t4.document.documentElement : typeof Document < "u" && t4 instanceof Document ? t4.documentElement : t4;
}
var qr = {
  page: (t4) => [t4.pageX, t4.pageY],
  client: (t4) => [t4.clientX, t4.clientY],
  screen: (t4) => [t4.screenX, t4.screenY],
  movement: (t4) => t4 instanceof Touch ? null : [t4.movementX, t4.movementY]
};
function Wr(t4 = {}) {
  const {
    type: l = "page",
    touch: e = true,
    resetOnTouchEnds: o = false,
    initialValue: a = { x: 0, y: 0 },
    window: n = Me,
    target: r = n,
    scroll: u = true,
    eventFilter: i
  } = t4;
  let d = null;
  const c = ref(a.x), f = ref(a.y), p = ref(null), v = typeof l == "function" ? l : qr[l], y = (C) => {
    const V = v(C);
    d = C, V && ([c.value, f.value] = V, p.value = "mouse");
  }, h2 = (C) => {
    if (C.touches.length > 0) {
      const V = v(C.touches[0]);
      V && ([c.value, f.value] = V, p.value = "touch");
    }
  }, w = () => {
    if (!d || !n)
      return;
    const C = v(d);
    d instanceof MouseEvent && C && (c.value = C[0] + n.scrollX, f.value = C[1] + n.scrollY);
  }, m = () => {
    c.value = a.x, f.value = a.y;
  }, B = i ? (C) => i(() => y(C), {}) : (C) => y(C), g = i ? (C) => i(() => h2(C), {}) : (C) => h2(C), A = i ? () => i(() => w(), {}) : () => w();
  if (r) {
    const C = { passive: true };
    Ve(r, ["mousemove", "dragover"], B, C), e && l !== "movement" && (Ve(r, ["touchstart", "touchmove"], g, C), o && Ve(r, "touchend", m, C)), u && l === "page" && Ve(n, "scroll", A, { passive: true });
  }
  return {
    x: c,
    y: f,
    sourceType: p
  };
}
function Ho(t4, l = {}) {
  const {
    handleOutside: e = true,
    window: o = Me
  } = l, a = l.type || "page", { x: n, y: r, sourceType: u } = Wr(l), i = ref(t4 ?? (o == null ? void 0 : o.document.body)), d = ref(0), c = ref(0), f = ref(0), p = ref(0), v = ref(0), y = ref(0), h2 = ref(true);
  let w = () => {
  };
  return o && (w = watch(
    [i, n, r],
    () => {
      const m = Le(i);
      if (!m)
        return;
      const {
        left: B,
        top: g,
        width: A,
        height: C
      } = m.getBoundingClientRect();
      f.value = B + (a === "page" ? o.pageXOffset : 0), p.value = g + (a === "page" ? o.pageYOffset : 0), v.value = C, y.value = A;
      const V = n.value - f.value, O = r.value - p.value;
      h2.value = A === 0 || C === 0 || V < 0 || O < 0 || V > A || O > C, (e || !h2.value) && (d.value = V, c.value = O);
    },
    { immediate: true }
  ), Ve(document, "mouseleave", () => {
    h2.value = true;
  })), {
    x: n,
    y: r,
    sourceType: u,
    elementX: d,
    elementY: c,
    elementPositionX: f,
    elementPositionY: p,
    elementHeight: v,
    elementWidth: y,
    isOutside: h2,
    stop: w
  };
}
function zl(t4) {
  const l = window.getComputedStyle(t4);
  if (l.overflowX === "scroll" || l.overflowY === "scroll" || l.overflowX === "auto" && t4.clientWidth < t4.scrollWidth || l.overflowY === "auto" && t4.clientHeight < t4.scrollHeight)
    return true;
  {
    const e = t4.parentNode;
    return !e || e.tagName === "BODY" ? false : zl(e);
  }
}
function Gr(t4) {
  const l = t4 || window.event, e = l.target;
  return zl(e) ? false : l.touches.length > 1 ? true : (l.preventDefault && l.preventDefault(), false);
}
var Ea = /* @__PURE__ */ new WeakMap();
function Ur(t4, l = false) {
  const e = ref(l);
  let o = null, a = "";
  watch(Fl(t4), (u) => {
    const i = Pa(Fe(u));
    if (i) {
      const d = i;
      if (Ea.get(d) || Ea.set(d, d.style.overflow), d.style.overflow !== "hidden" && (a = d.style.overflow), d.style.overflow === "hidden")
        return e.value = true;
      if (e.value)
        return d.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const n = () => {
    const u = Pa(Fe(t4));
    !u || e.value || (ja && (o = Ve(
      u,
      "touchmove",
      (i) => {
        Gr(i);
      },
      { passive: false }
    )), u.style.overflow = "hidden", e.value = true);
  }, r = () => {
    const u = Pa(Fe(t4));
    !u || !e.value || (ja && (o == null || o()), u.style.overflow = a, Ea.delete(u), e.value = false);
  };
  return rt(r), computed({
    get() {
      return e.value;
    },
    set(u) {
      u ? n() : r();
    }
  });
}
function Kr(t4, l = {}) {
  const {
    threshold: e = 50,
    onSwipe: o,
    onSwipeEnd: a,
    onSwipeStart: n,
    passive: r = true,
    window: u = Me
  } = l, i = reactive({ x: 0, y: 0 }), d = reactive({ x: 0, y: 0 }), c = computed(() => i.x - d.x), f = computed(() => i.y - d.y), { max: p, abs: v } = Math, y = computed(() => p(v(c.value), v(f.value)) >= e), h2 = ref(false), w = computed(() => y.value ? v(c.value) > v(f.value) ? c.value > 0 ? "left" : "right" : f.value > 0 ? "up" : "down" : "none"), m = (U) => [U.touches[0].clientX, U.touches[0].clientY], B = (U, F) => {
    i.x = U, i.y = F;
  }, g = (U, F) => {
    d.x = U, d.y = F;
  };
  let A;
  const C = Xr(u == null ? void 0 : u.document);
  r ? A = C ? { passive: true } : { capture: false } : A = C ? { passive: false, capture: true } : { capture: true };
  const V = (U) => {
    h2.value && (a == null || a(U, w.value)), h2.value = false;
  }, O = [
    Ve(t4, "touchstart", (U) => {
      if (U.touches.length !== 1)
        return;
      A.capture && !A.passive && U.preventDefault();
      const [F, j] = m(U);
      B(F, j), g(F, j), n == null || n(U);
    }, A),
    Ve(t4, "touchmove", (U) => {
      if (U.touches.length !== 1)
        return;
      const [F, j] = m(U);
      g(F, j), !h2.value && y.value && (h2.value = true), h2.value && (o == null || o(U));
    }, A),
    Ve(t4, ["touchend", "touchcancel"], V, A)
  ];
  return {
    isPassiveEventSupported: C,
    isSwiping: h2,
    direction: w,
    coordsStart: i,
    coordsEnd: d,
    lengthX: c,
    lengthY: f,
    stop: () => O.forEach((U) => U())
  };
}
function Xr(t4) {
  if (!t4)
    return false;
  let l = false;
  const e = {
    get passive() {
      return l = true, false;
    }
  };
  return t4.addEventListener("x", Ze, e), t4.removeEventListener("x", Ze), l;
}
var Yr = ["id"];
var Zr = ["id"];
var Jr = ["innerHTML"];
var Qr = ["innerHTML"];
var go = defineComponent({
  inheritAttrs: false,
  __name: "BPopover",
  props: mergeModels({
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    click: { type: Boolean, default: false },
    content: { default: void 0 },
    customClass: { default: "" },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    floatingMiddleware: { default: void 0 },
    html: { type: Boolean, default: false },
    id: { default: void 0 },
    inline: { type: Boolean, default: false },
    manual: { type: Boolean, default: false },
    modelValue: { type: Boolean },
    noAutoClose: { type: Boolean, default: false },
    noFade: { type: Boolean, default: false },
    noFlip: { type: Boolean, default: false },
    noHide: { type: Boolean, default: false },
    noShift: { type: Boolean, default: false },
    noSize: { type: Boolean, default: false },
    noninteractive: { type: Boolean, default: false },
    offset: { default: null },
    placement: { default: "top" },
    persistent: { type: Boolean, default: false },
    realtime: { type: Boolean, default: false },
    reference: { default: null },
    strategy: { default: "absolute" },
    target: { default: null },
    title: { default: void 0 },
    tooltip: { type: Boolean, default: false },
    variant: { default: null },
    teleportDisabled: { default: false },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: false },
    modelModifiers: {}
  }),
  emits: mergeModels(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BPopover"), n = e, r = useModel(t4, "modelValue"), u = ref(r.value), i = ref(r.value);
    watchEffect(() => {
      r.value = u.value;
    }), watch(r, (K) => {
      K !== u.value && (K ? I() : z(new Event("update:modelValue")));
    });
    const d = ke(() => a.id, "popover"), c = ref(false), f = ref(null), p = ref(null), v = ref(null), y = ref(null), h2 = ref(null), w = computed(
      () => a.title ? Nt(a.title, At) : ""
    ), m = computed(
      () => a.content ? Nt(a.content, At) : ""
    ), B = toRef(() => a.placement.startsWith("auto")), g = _e(() => a.offset ?? NaN), A = computed(
      () => a.boundary === "document" || a.boundary === "viewport" ? void 0 : a.boundary
    ), C = computed(
      () => a.boundary === "document" || a.boundary === "viewport" ? a.boundary : void 0
    ), V = ref({}), O = computed(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const K = a.offset !== null ? g.value : a.tooltip ? 6 : 8, ne = [Sl(K)];
      return a.noFlip === false && !B.value && ne.push(
        $l({
          boundary: A.value,
          rootBoundary: C.value,
          padding: a.boundaryPadding
        })
      ), B.value && ne.push(
        nr({
          alignment: a.placement.split("-")[1] || void 0,
          boundary: A.value,
          rootBoundary: C.value,
          padding: a.boundaryPadding
        })
      ), a.noShift === false && ne.push(
        xl({
          boundary: A.value,
          rootBoundary: C.value,
          padding: a.boundaryPadding
        })
      ), a.noHide === false && ne.push(
        sr({
          boundary: A.value,
          rootBoundary: C.value,
          padding: a.boundaryPadding
        })
      ), a.inline === true && ne.push(ir()), ne.push(cr({ element: v, padding: 10 })), a.noSize === false && ne.push(
        Vl({
          boundary: A.value,
          rootBoundary: C.value,
          padding: a.boundaryPadding,
          apply({ availableWidth: re, availableHeight: Q }) {
            V.value = {
              maxHeight: Q ? `${Q}px` : void 0,
              maxWidth: re ? `${re}px` : void 0
            };
          }
        })
      ), ne;
    }), Y = toRef(
      () => B.value ? void 0 : a.placement
    ), { floatingStyles: U, middlewareData: F, placement: j, update: $ } = Nl(p, f, {
      placement: Y,
      middleware: O,
      strategy: toRef(() => a.strategy),
      whileElementsMounted: (...K) => Tl(...K, { animationFrame: a.realtime })
    }), N = ref({ position: "absolute" });
    watch(F, () => {
      var K;
      if (a.noHide === false && ((K = F.value.hide) != null && K.referenceHidden ? c.value = true : c.value = false), F.value.arrow) {
        const { x: ne, y: re } = F.value.arrow;
        N.value = {
          position: "absolute",
          top: re ? `${re}px` : "",
          left: ne ? `${ne}px` : ""
        };
      }
    });
    const H = computed(() => {
      const K = a.tooltip ? "tooltip" : "popover";
      return [
        K,
        `b-${K}`,
        {
          [`b-${K}-${a.variant}`]: a.variant !== null,
          show: u.value && !c.value,
          "pe-none": !u.value,
          fade: !a.noFade,
          "d-none": !u.value && a.noFade,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${K}-${ti(j.value)}`]: j.value !== void 0
        }
      ];
    }), { isOutside: k } = Ho(f), { isOutside: S } = Ho(y), E = (K) => {
      const ne = K ?? new Event("click");
      u.value ? z(ne) : I();
    }, M = (K, ne = {}) => new Ct(K, {
      cancelable: false,
      target: f.value || null,
      relatedTarget: null,
      trigger: null,
      ...ne,
      componentId: d.value
    });
    let X;
    const I = () => {
      const K = M("show", { cancelable: true });
      if (n("show", K), K.defaultPrevented) {
        n("show-prevented");
        return;
      }
      i.value = true, nextTick(() => {
        var ne;
        $(), X = setTimeout(
          () => {
            $(), u.value = true, nextTick(() => {
              n("shown", M("shown"));
            });
          },
          typeof a.delay == "number" ? a.delay : ((ne = a.delay) == null ? void 0 : ne.show) || 0
        );
      });
    }, z = (K) => {
      var Q;
      const ne = M("hide", { cancelable: true });
      if (n("hide", ne), ne.defaultPrevented) {
        n("hide-prevented");
        return;
      }
      X && (clearTimeout(X), X = void 0);
      const re = typeof a.delay == "number" ? a.delay : ((Q = a.delay) == null ? void 0 : Q.hide) || 0;
      setTimeout(() => {
        var fe, de;
        (K == null ? void 0 : K.type) === "click" || (K == null ? void 0 : K.type) === "forceHide" || (K == null ? void 0 : K.type) === "update:modelValue" && a.manual || !a.noninteractive && k.value && S.value && !((fe = f.value) != null && fe.contains(document == null ? void 0 : document.activeElement)) && !((de = y.value) != null && de.contains(document == null ? void 0 : document.activeElement)) || a.noninteractive && S.value ? (u.value = false, nextTick(() => {
          setTimeout(
            () => {
              i.value = false;
            },
            f.value ? Ma(f.value) : 150
          ), n("hidden", M("hidden"));
        })) : setTimeout(
          () => {
            z(K);
          },
          re < 50 ? 50 : re
        );
      }, re);
    };
    l({
      hide: z,
      show: I,
      toggle: E
    });
    const te = () => {
      var K;
      if (a.target) {
        const ne = yt(a.target);
        ne ? y.value = ne : console.warn("Target element not found", a.target);
      } else
        y.value = (K = h2.value) == null ? void 0 : K.nextElementSibling;
      if (a.reference) {
        const ne = yt(a.reference);
        ne ? p.value = ne : console.warn("Reference element not found", a.reference);
      } else
        p.value = y.value;
      if (!(!y.value || a.manual) && no) {
        if (y.value.addEventListener("forceHide", z), a.click) {
          y.value.addEventListener("click", E);
          return;
        }
        y.value.addEventListener("pointerenter", I), y.value.addEventListener("pointerleave", z), y.value.addEventListener("focus", I), y.value.addEventListener("blur", z);
      }
    }, ae = () => {
      y.value && (y.value.removeEventListener("forceHide", z), y.value.removeEventListener("click", E), y.value.removeEventListener("pointerenter", I), y.value.removeEventListener("pointerleave", z), y.value.removeEventListener("focus", I), y.value.removeEventListener("blur", z));
    };
    return Rl(
      f,
      () => {
        u.value && a.click && !a.noAutoClose && !a.manual && z(new Event("clickOutside"));
      },
      { ignore: [y] }
    ), watch([() => a.click, () => a.target, () => a.reference], () => {
      ae(), te();
    }), onMounted(te), onBeforeUnmount(ae), (K, ne) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("span", {
        id: unref(d) + "_placeholder",
        ref_key: "placeholder",
        ref: h2
      }, null, 8, Yr),
      renderSlot(K.$slots, "target", {
        show: I,
        hide: z,
        toggle: E,
        showState: u.value
      }),
      (openBlock(), createBlock(Teleport, {
        to: unref(a).teleportTo,
        disabled: !unref(a).teleportTo || unref(a).teleportDisabled
      }, [
        i.value || unref(a).persistent ? (openBlock(), createElementBlock("div", mergeProps({
          key: 0,
          id: unref(d)
        }, K.$attrs, {
          ref_key: "element",
          ref: f,
          class: H.value,
          role: "tooltip",
          tabindex: "-1",
          style: unref(U)
        }), [
          createBaseVNode("div", {
            ref_key: "arrow",
            ref: v,
            class: normalizeClass(`${unref(a).tooltip ? "tooltip" : "popover"}-arrow`),
            style: normalizeStyle(N.value),
            "data-popper-arrow": ""
          }, null, 6),
          createBaseVNode("div", {
            class: "overflow-auto",
            style: normalizeStyle(V.value)
          }, [
            unref(a).title || K.$slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              unref(a).html ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(["position-sticky top-0", unref(a).tooltip ? "tooltip-inner" : "popover-header"]),
                innerHTML: w.value
              }, null, 10, Jr)) : (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["position-sticky top-0", unref(a).tooltip ? "tooltip-inner" : "popover-header"])
              }, [
                renderSlot(K.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(unref(a).title), 1)
                ])
              ], 2))
            ], 64)) : createCommentVNode("", true),
            unref(a).tooltip && !K.$slots.title && !unref(a).title || !unref(a).tooltip ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              unref(a).html ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(a).tooltip ? "tooltip-inner" : "popover-body"),
                innerHTML: m.value
              }, null, 10, Qr)) : (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(a).tooltip ? "tooltip-inner" : "popover-body")
              }, [
                renderSlot(K.$slots, "default", {}, () => [
                  createTextVNode(toDisplayString(unref(a).content), 1)
                ])
              ], 2))
            ], 64)) : createCommentVNode("", true)
          ], 4)
        ], 16, Zr)) : createCommentVNode("", true)
      ], 8, ["to", "disabled"]))
    ], 64));
  }
});
var ei = ({
  top: t4,
  end: l,
  start: e,
  alignCenter: o,
  alignEnd: a
}) => {
  const n = t4 ? "top" : e ? "left" : l ? "right" : "bottom", r = a ? "end" : o ? null : "start";
  return `${n}${r ? `-${r}` : ""}`;
};
var ti = (t4) => {
  const [l] = t4.split("-");
  switch (l) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return l;
  }
};
var Gt = (t4) => typeof t4 != "object" || t4.active !== false;
var ma = (t4, l) => {
  if (!Gt(t4))
    return {};
  const o = typeof t4 > "u" || typeof t4 == "object" && !t4.title && !t4.content, a = l.getAttribute("title") || l.getAttribute("data-original-title");
  return o ? a ? (l.removeAttribute("title"), l.setAttribute("data-original-title", a), {
    content: Nt(a, At)
  }) : {} : typeof t4 == "string" ? {
    content: Nt(t4, At)
  } : {
    title: t4 != null && t4.title ? Nt(t4 == null ? void 0 : t4.title, At) : void 0,
    content: t4 != null && t4.content ? Nt(t4 == null ? void 0 : t4.content, At) : void 0
  };
};
var ba = (t4, l) => ({
  target: l,
  modelValue: t4.modifiers.show,
  inline: t4.modifiers.inline,
  click: t4.modifiers.click,
  realtime: t4.modifiers.realtime,
  persistent: t4.modifiers.persistent,
  placement: t4.modifiers.left ? "left" : t4.modifiers.right ? "right" : t4.modifiers.bottom ? "bottom" : t4.modifiers.top ? "top" : void 0,
  html: true,
  ...typeof t4.value == "object" ? t4.value : {},
  ...t4.modifiers.interactive ? { noninteractive: false } : {},
  title: null,
  content: null
});
var ya = (t4, l, e) => {
  var a;
  const o = document.createElement("span");
  l.modifiers.body ? document.body.appendChild(o) : l.modifiers.child ? t4.appendChild(o) : (a = t4.parentNode) == null || a.insertBefore(o, t4.nextSibling), render(h(go, e), o), t4.$__element = o;
};
var ga = (t4) => {
  const l = t4.$__element;
  l && render(null, l), setTimeout(() => {
    l == null || l.remove();
  }, 0), delete t4.$__element;
};
var Ga = (t4, l, e) => {
  const o = Ie(t4, l);
  return e && typeof e == "function" ? e(o, l, t4) : o;
};
var la = (t4, l, e, o = e) => l.reduce((a, n) => (t4[n] && a.push(
  [o, n.replace(e, ""), t4[n]].filter((r) => r && typeof r != "boolean").join("-").toLowerCase()
), a), []);
var yt = (t4) => {
  if (t4)
    return typeof t4 == "string" ? typeof document > "u" ? void 0 : document.getElementById(t4) ?? document.querySelector(t4) ?? void 0 : t4.$el ?? t4;
};
var ai = (t4, l) => ((t4 == null ? void 0 : t4()) ?? []).reduce((e, o) => (typeof o.type == "symbol" ? e = e.concat(o.children) : e.push(o), e), []).filter((e) => {
  var o;
  return ((o = e.type) == null ? void 0 : o.__name) === l;
});
var Ml = /_/g;
var Hl = /([a-z])([A-Z])/g;
var oi = /^[0-9]*\.?[0-9]+$/;
var li = /(\s|^)(\w)/g;
var ni = /(\s|^)(\w)/;
var na = /\s+/;
var si = /^#/;
var ri = /^#[A-Za-z]+[\w\-:.]*$/;
var ii = /[-/\\^$*+?.()|[\]{}]/g;
var ui = /[\s\uFEFF\xA0]+/g;
var Fa = (t4) => t4.replace(Ml, " ").replace(Hl, (l, e, o) => `${e} ${o}`).replace(ni, (l, e, o) => e + o.toUpperCase());
var Do = (t4) => t4.replace(Ml, " ").replace(Hl, (l, e, o) => `${e} ${o}`).replace(li, (l, e, o) => e + o.toUpperCase());
var di = (t4) => {
  const l = t4.trim();
  return l.charAt(0).toUpperCase() + l.slice(1);
};
var ci = (t4) => t4.replace(ii, "\\$&");
var fi = (t4) => ci(t4).replace(ui, "\\s");
var sa = (t4) => typeof t4 == "string" ? Do(t4) : t4.label !== void 0 ? t4.label : typeof t4.key == "string" ? Do(t4.key) : t4.key;
var vi = (t4) => !!(t4.href || t4.to);
var Dl = Symbol("bvn::carousel");
var jl = Symbol("bvn::tabs");
var ql = Symbol("bvn::progress");
var Wl = Symbol("bvn::listGroup");
var Gl = Symbol("bvn::avatarGroup");
var Ul = Symbol("bvn::accordion");
var Kl = Symbol("bvn::checkboxGroup");
var Xl = Symbol("bvn::radioGroup");
var ho = Symbol("bvn::collapse");
var Yl = Symbol("bvn::collapse");
var Bo = Symbol("bvn::navbar");
var Zl = Symbol("bvn::toastPlugin");
var Jl = Symbol("bvn::rtlPlugin");
var Ql = Symbol("bvn::breadcrumbPlugin");
var en = Symbol("bvn::modalControllerPlugin");
var tn = Symbol("bvn::modalManagerPlugin");
var an = Symbol("bvn::idPluginKey");
var ra = Symbol("bvn::defaults");
var on = Symbol("bvn::inputGroup");
var Mt = (t4, l = {}, e = {}) => {
  const o = [t4];
  let a;
  for (let n = 0; n < o.length && !a; n++) {
    const r = o[n];
    a = e[r];
  }
  return a && typeof a == "function" ? a(l) : a;
};
var $a = (t4, l) => Object.keys(t4).filter((e) => !l.map((o) => o.toString()).includes(e)).reduce((e, o) => ({ ...e, [o]: t4[o] }), {});
var _o = (t4, l) => [...l].reduce(
  (e, o) => (e[o] = t4[o], e),
  {}
);
var Ie = (t4, l, e) => {
  const o = l.split(/[.[\]]/g);
  let a = t4;
  for (const n of o) {
    if (a === null || a === void 0)
      return e;
    n.trim() !== "" && (a = a[n]);
  }
  return a === void 0 ? e : a;
};
var pi = (t4, l, e) => {
  const o = (i) => {
    if (((f) => f == null || typeof f != "object" && typeof f != "function")(i))
      return i;
    if (typeof i == "function")
      return i.bind({});
    const c = new i.constructor();
    return Object.getOwnPropertyNames(i).forEach((f) => {
      c[f] = i[f];
    }), c;
  }, a = (i, d) => {
    const c = d === void 0 ? 0 : d;
    if (i == null)
      return c;
    const f = Number.parseInt(i);
    return Number.isNaN(f) ? c : f;
  };
  if (!t4)
    return {};
  if (!l || e === void 0)
    return t4;
  const n = l.split(/[.[\]]/g).filter((i) => !!i.trim()), r = (i) => {
    if (n.length > 1) {
      const d = n.shift(), c = a(n[0], null) !== null;
      i[d] = i[d] === void 0 ? c ? [] : {} : i[d], r(i[d]);
    } else
      i[n[0]] = e;
  }, u = o(t4);
  return r(u), u;
};
var ha = (t4, l) => {
  const { all: e, ...o } = t4, a = {};
  e && l.forEach((r) => {
    a[r] = e;
  });
  const n = { ...a, ...o };
  return Object.entries(n).filter(([r, u]) => !!u && l.includes(r)).map(([r]) => r);
};
var jo = (t4, l) => l + (t4 ? di(t4) : "");
var mi = {
  "top-start": "top-0 start-0",
  "top-center": "top-0 start-50 translate-middle-x",
  "top-end": "top-0 end-0",
  "middle-start": "top-50 start-0 translate-middle-y",
  "middle-center": "top-50 start-50 translate-middle",
  "middle-end": "top-50 end-0 translate-middle-y",
  "bottom-start": "bottom-0 start-0",
  "bottom-center": "bottom-0 start-50 translate-middle-x",
  "bottom-end": "bottom-0 end-0"
};
var Tt = (t4, l) => {
  const e = toRef(l), o = toRef(t4), a = toRef(() => vi(o.value)), n = computed(
    () => a.value ? _o(
      o.value,
      e.value ?? [
        "active",
        "activeClass",
        "append",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover"
      ]
    ) : {}
  );
  return { computedLink: a, computedLinkProps: n };
};
var ln = () => ({ ...inject(Ql) });
var bi = (t4 = {}) => {
  const l = t4.persist ?? false, e = "data-bs-theme", o = "body";
  return Dr({
    attribute: e,
    selector: o,
    storageKey: l === true ? `bv-color-${t4.attribute ?? e}-${t4.selector ?? o}` : null,
    ...t4
  });
};
var lt = (t4) => computed(() => {
  let l = toValue(t4);
  return l = {
    ...l,
    variant: l.variant ?? null,
    bgVariant: l.bgVariant ?? null,
    textVariant: l.textVariant ?? null
  }, {
    [`text-bg-${l.variant}`]: l.variant !== null,
    [`text-${l.textVariant}`]: l.textVariant !== null && l.variant === null,
    [`bg-${l.bgVariant}`]: l.bgVariant !== null && l.variant === null
  };
});
var yi = (t4) => computed(() => {
  const l = toValue(t4);
  return {
    container: l === true,
    [`container-${l}`]: typeof l == "string"
  };
});
var nn = (t4, l = ref(1e3), e = {}) => {
  const o = readonly(toRef(t4)), a = readonly(toRef(l)), n = ref(false), r = ref(0), u = toRef(() => Math.ceil(o.value / a.value)), i = toRef(
    () => f.value || n.value ? Math.round(o.value - r.value * a.value) : 0
  ), { pause: d, resume: c, isActive: f } = Ll(
    () => {
      r.value = r.value + 1;
    },
    l,
    e
  ), p = () => {
    n.value = false, r.value = 0, c();
  }, v = () => {
    n.value = false, r.value = u.value;
  };
  watchEffect(() => {
    r.value > u.value && (r.value = u.value), r.value === u.value && d();
  }), watch([a, o], () => {
    v(), p();
  });
  const y = () => {
    f.value !== false && (n.value = true, d());
  }, h2 = () => {
    r.value !== u.value && (n.value = false, c());
  };
  return {
    isActive: readonly(f),
    isPaused: readonly(n),
    restart: p,
    stop: v,
    pause: y,
    resume: h2,
    value: i
  };
};
function gi(t4, l = sn("injectSelf")) {
  const { provides: e } = l;
  if (e && t4 in e)
    return e[t4];
}
function sn(t4, l) {
  const e = getCurrentInstance();
  if (!e)
    throw new Error(`[Bvn] ${t4} ${l || "must be called from inside a setup function"}`);
  return e;
}
var hi = (t4 = "") => t4.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
var qo = (t4) => t4 !== null && typeof t4 == "object" && !Array.isArray(t4);
function rn(t4 = {}, l = {}, e) {
  const o = {};
  for (const a in t4)
    o[a] = t4[a];
  for (const a in l) {
    const n = t4[a], r = l[a];
    if (qo(n) && qo(r)) {
      o[a] = rn(n, r, e);
      continue;
    }
    if (Array.isArray(n) && Array.isArray(r) && e) {
      o[a] = e(n, r);
      continue;
    }
    o[a] = r;
  }
  return o;
}
var Bi = (t4, l) => {
  var e, o;
  return typeof ((e = t4.props) == null ? void 0 : e[l]) < "u" || typeof ((o = t4.props) == null ? void 0 : o[hi(l)]) < "u";
};
function _i(t4 = {}, l) {
  const e = inject(ra, ref({})), o = sn("useDefaults");
  if (l = l ?? o.type.name ?? o.type.__name, !l)
    throw new Error("[Bvn] Could not determine component name");
  const a = computed(() => {
    var i;
    return (i = e.value) == null ? void 0 : i[t4._as ?? l];
  }), n = new Proxy(t4, {
    get(i, d) {
      var f, p, v, y;
      const c = Reflect.get(i, d);
      return d === "class" || d === "style" ? [(f = a.value) == null ? void 0 : f[d], c].filter((h2) => h2 != null) : typeof d == "string" && !Bi(o.vnode, d) ? ((p = a.value) == null ? void 0 : p[d]) ?? ((y = (v = e.value) == null ? void 0 : v.global) == null ? void 0 : y[d]) ?? c : c;
    }
  }), r = shallowRef();
  watchEffect(() => {
    if (a.value) {
      const i = Object.entries(a.value).filter(
        ([d]) => d.startsWith(d[0].toUpperCase())
      );
      r.value = i.length ? Object.fromEntries(i) : void 0;
    } else
      r.value = void 0;
  });
  function u() {
    const i = gi(ra, o);
    provide(
      ra,
      computed(
        () => r.value ? rn((i == null ? void 0 : i.value) ?? {}, r.value) : i == null ? void 0 : i.value
      )
    );
  }
  return { props: n, provideSubDefaults: u };
}
function G(t4, l) {
  const { props: e, provideSubDefaults: o } = _i(t4, l);
  return o(), e;
}
var St = (t4) => computed(() => {
  const l = toValue(t4);
  return l === true ? "is-valid" : l === false ? "is-invalid" : null;
});
var un = (t4) => computed(() => {
  const l = toValue(t4);
  return {
    "form-check": l.plain === false && l.button === false && l.hasDefaultSlot,
    "form-check-reverse": l.reverse === true,
    "form-check-inline": l.inline === true,
    "form-switch": l.switch === true,
    [`form-control-${l.size}`]: l.size !== void 0 && l.size !== "md" && l.button === false
  };
});
var dn = (t4) => {
  const l = toRef(t4), e = St(() => l.value.state ?? null);
  return computed(() => [
    e.value,
    {
      "form-check-input": l.value.plain === false && l.value.button === false,
      "btn-check": l.value.button === true
    }
  ]);
};
var cn = (t4) => computed(() => {
  const l = toValue(t4);
  return {
    "form-check-label": l.plain === false && l.button === false,
    btn: l.button === true,
    [`btn-${l.buttonVariant}`]: l.button === true && l.buttonVariant !== void 0 && l.buttonVariant !== null,
    [`btn-${l.size}`]: l.button && l.size && l.size !== "md"
  };
});
var fn = (t4) => {
  const l = toRef(t4), e = Sa(
    () => l.value.ariaInvalid,
    () => l.value.state
  );
  return computed(() => ({
    "aria-invalid": e.value,
    "aria-required": l.value.required === true ? true : void 0
  }));
};
var vn = (t4) => computed(() => {
  const l = toValue(t4);
  return {
    "was-validated": l.validated === true,
    "btn-group": l.buttons === true && l.stacked === false,
    "btn-group-vertical": l.stacked === true && l.buttons === true,
    [`btn-group-${l.size}`]: l.size !== void 0
  };
});
var ke = (t4, l) => computed(() => toValue(t4) || wi(l));
var wi = (t4 = "") => `__BVID__${inject(an, () => Math.random().toString().slice(2, 8))()}___BV_${t4}__`;
var pn = (t4, l, e) => {
  const o = ref(null), a = ke(() => t4.id, "input"), n = _e(() => t4.debounce ?? 0), r = _e(() => t4.debounceMaxWait ?? NaN), u = $r(
    (m) => {
      l.value = m;
    },
    () => e.lazy === true ? 0 : n.value,
    { maxWait: () => e.lazy === true ? NaN : r.value }
  ), i = (m, B = false) => {
    e.lazy === true && B === false || u(m);
  }, { focused: d } = Re(o, {
    initialValue: t4.autofocus
  }), c = (m, B, g = false) => t4.formatter !== void 0 && (!t4.lazyFormatter || g) ? t4.formatter(m, B) : m;
  onMounted(() => {
    var m;
    o.value && (o.value.value = ((m = l.value) == null ? void 0 : m.toString()) ?? "");
  }), onActivated(() => {
    nextTick(() => {
      t4.autofocus && (d.value = true);
    });
  });
  const f = Sa(
    () => t4.ariaInvalid,
    () => t4.state
  );
  return {
    input: o,
    computedId: a,
    computedAriaInvalid: f,
    onInput: (m) => {
      const { value: B } = m.target, g = c(B, m);
      if (m.defaultPrevented) {
        m.preventDefault();
        return;
      }
      i(g);
    },
    onChange: (m) => {
      const { value: B } = m.target, g = c(B, m);
      if (m.defaultPrevented) {
        m.preventDefault();
        return;
      }
      const A = g;
      l.value !== A && i(g, true);
    },
    onBlur: (m) => {
      if (!e.lazy && !t4.lazyFormatter)
        return;
      const { value: B } = m.target, g = c(B, m, true), A = g;
      l.value !== A && i(g, true);
    },
    focus: () => {
      t4.disabled || (d.value = true);
    },
    blur: () => {
      t4.disabled || (d.value = false);
    }
  };
};
var mn = (t4, l) => {
  const e = (r) => typeof r == "object" && r !== null && "label" in r, o = (r) => {
    if (typeof r == "string")
      return { value: r, text: r };
    if (typeof r == "number")
      return { value: r, text: `${r}` };
    if (r instanceof Date)
      return { value: r, text: r.toLocaleString() };
    const u = Ie(r, l.valueField), i = Ie(r, l.textField), d = Ie(r, l.htmlField), c = Ie(r, l.disabledField), f = l.optionsField ? Ie(r, l.optionsField) : void 0;
    return f !== void 0 ? {
      label: Ie(r, l.labelField) || i,
      options: f
    } : {
      value: u,
      text: i,
      html: d,
      disabled: c
    };
  }, a = (r) => r.map((u) => o(u));
  return { normalizedOptions: computed(() => a(toValue(t4))), isComplex: e };
};
var Ia = "modal-open";
var wo = () => {
  const t4 = inject(tn), l = (o) => {
    t4 == null || t4.removeStack(o), t4 == null || t4.removeRegistry(o);
  }, e = bo("updateHTMLAttrs", (o, a, n) => {
    const r = typeof o == "string" ? window == null ? void 0 : window.document.querySelector(o) : Le(o);
    r && (a === "class" ? r.classList.toggle(Ia, n === Ia) : r.setAttribute(a, n));
  });
  return rt(() => {
    e("body", "class", "");
  }), watch(
    () => t4 == null ? void 0 : t4.countStack.value,
    (o) => {
      o !== void 0 && e("body", "class", o > 0 ? Ia : "");
    }
  ), {
    ...t4,
    dispose: l
  };
};
var Ci = (t4, l) => {
  const { pushRegistry: e, pushStack: o, removeStack: a, stack: n, dispose: r, countStack: u } = wo(), i = getCurrentInstance();
  if (!i || i.type.__name !== "BModal")
    throw new Error("useModalManager must only use in BModal component");
  e == null || e(i), rt(() => {
    r(i);
  });
  const d = (c, f) => {
    c ? o == null || o(i) : f && !c && (a == null || a(i));
  };
  return d(l, l), watch(t4, d), {
    activePosition: computed(
      () => n == null ? void 0 : n.value.findIndex((c) => {
        var f, p;
        return ((f = c.exposed) == null ? void 0 : f.id) === ((p = i.exposed) == null ? void 0 : p.id);
      })
    ),
    activeModalCount: u,
    stackWithoutSelf: computed(
      () => (n == null ? void 0 : n.value.filter((c) => {
        var f, p;
        return ((f = c.exposed) == null ? void 0 : f.id) !== ((p = i.exposed) == null ? void 0 : p.id);
      })) ?? []
    )
  };
};
var ki = (t4 = void 0) => {
  const { registry: l } = wo(), e = getCurrentInstance(), o = (r) => r.parent ? r.parent.type.__name === "BModal" ? r.parent : o(r.parent) : null, a = computed(() => {
    const r = toValue(t4);
    return r ? (l == null ? void 0 : l.value.find((u) => {
      var i;
      return ((i = u.exposed) == null ? void 0 : i.id.value) === r;
    })) || null : e ? o(e) : null;
  }), n = toRef(() => {
    var r;
    return (r = a.value) == null ? void 0 : r.proxy;
  });
  return {
    show() {
      var r, u;
      (u = (r = a.value) == null ? void 0 : r.exposed) == null || u.show();
    },
    hide(r = "") {
      var u, i;
      (i = (u = a.value) == null ? void 0 : u.exposed) == null || i.hide(r);
    },
    modal: n
  };
};
var bn = () => {
  const { lastStack: t4, stack: l } = wo();
  return {
    ...inject(en),
    hide: (n = "") => {
      var r;
      t4 != null && t4.value && ((r = t4 == null ? void 0 : t4.value.exposed) == null || r.hide(n));
    },
    hideAll: (n = "") => {
      l == null || l.value.forEach((r) => {
        var u;
        (u = r.exposed) == null || u.hide(n);
      });
    }
    // Todo: Supports listening events globally in the future
  };
};
var Ba = (t4, l = "px") => computed(() => {
  const e = toValue(t4), o = toValue(l);
  return oi.test(String(e)) ? `${Number(e)}${o}` : e;
});
var Co = (t4) => {
  const l = (e, o) => {
    const a = o === null ? "" : `${o}-`;
    return e === "circle" ? `${a}rounded-circle` : e === "pill" ? `${a}rounded-pill` : typeof e == "number" || e === "0" || e === "1" || e === "2" || e === "3" || e === "4" || e === "5" ? `${a}rounded-${e}` : e === "none" ? `${a}rounded-0` : e === "sm" ? `${a}rounded-1` : e === "lg" ? `${a}rounded-5` : `${a}rounded`;
  };
  return computed(() => {
    const e = toValue(t4);
    return {
      [`${l(e.rounded, null)}`]: !!e.rounded,
      [`${l(e.roundedTop, "top")}`]: !!e.roundedTop,
      [`${l(e.roundedBottom, "bottom")}`]: !!e.roundedBottom,
      [`${l(e.roundedStart, "start")}`]: !!e.roundedStart,
      [`${l(e.roundedEnd, "end")}`]: !!e.roundedEnd
    };
  });
};
var Ti = () => {
  const t4 = inject(Jl);
  return onMounted(() => {
    watch(
      [() => t4 == null ? void 0 : t4.isRtl.value, () => t4 == null ? void 0 : t4.locale.value],
      ([l, e]) => {
        const o = document.documentElement;
        o.setAttribute("dir", l ?? false ? "rtl" : "ltr"), o.setAttribute("lang", e ?? "");
      },
      { immediate: true }
    );
  }), { ...t4 };
};
var yn = (t4, l) => {
  const e = readonly(toRef(t4)), o = readonly(toRef(l)), a = toRef(() => !o.value);
  onMounted(() => {
    const n = Ur(
      document.body,
      e.value && a.value
    );
    watch([e, a], ([r, u]) => {
      n.value = r && u;
    });
  });
};
var gn = (t4, l, e = {}) => {
  const o = toRef(t4), a = toRef(l), n = ref(yt(o.value)), r = ref(yt(a.value));
  watch([o, a], () => {
    B();
  });
  const {
    contentQuery: u = ":scope > [id]",
    targetQuery: i = "[href]",
    manual: d = false,
    root: c,
    rootMargin: f = "0px 0px -25%",
    threshold: p = [0.1, 0.5, 1],
    watchChanges: v = true
  } = e, y = ref(null), h2 = ref([]), w = ref([]);
  getCurrentInstance() ? onMounted(() => {
    Wa(o, n, {
      transform: {
        ltr: (F) => yt(F)
      },
      direction: "ltr",
      immediate: true
    }), Wa(a, r, {
      transform: {
        ltr: (F) => yt(F)
      },
      direction: "ltr",
      immediate: true
    }), B();
  }) : nextTick(() => {
    B();
  });
  const B = () => {
    w.value = n.value ? Array.from(n.value.querySelectorAll(u)) : [], h2.value = w.value.map((F) => ({
      id: F.id,
      el: F,
      visible: false,
      text: F.textContent
    }));
  };
  let g = true, A = 0;
  const C = computed(
    () => n.value && getComputedStyle(n.value).overflowY === "visible" ? null : n.value
  ), V = jr(
    w,
    (F) => {
      var N, H, k, S;
      const j = (N = C.value || (document == null ? void 0 : document.documentElement)) == null ? void 0 : N.scrollTop;
      g = j > A, A = j, F.forEach((E) => {
        if (E.isIntersecting) {
          h2.value.forEach((M) => {
            M.el === E.target && (M.visible = true);
          });
          return;
        }
        h2.value.forEach((M) => {
          M.el === E.target && (M.visible = false);
        });
      });
      let $ = null;
      g ? $ = ((H = [...h2.value].reverse().find((E) => E.visible)) == null ? void 0 : H.id) || null : $ = ((k = h2.value.find((E) => E.visible)) == null ? void 0 : k.id) || null, $ !== null && (y.value = $), y.value || (y.value = ((S = h2.value[0]) == null ? void 0 : S.id) || null);
    },
    {
      root: c ? yt(c) : C,
      rootMargin: f,
      threshold: p
    }
  );
  watch(y, (F) => {
    var H;
    if (d)
      return;
    const j = (H = r.value) == null ? void 0 : H.querySelectorAll(i);
    if (j === void 0)
      return;
    let $ = false, N = null;
    j.forEach((k) => {
      var E, M, X, I, z, te, ae, K, ne, re, Q;
      const S = k.closest(".dropdown");
      if ((E = k.getAttribute("href")) != null && E.includes(`#${F}`)) {
        N = k, k.classList.add("active"), S && ((M = S == null ? void 0 : S.querySelector(".dropdown-toggle")) == null || M.classList.add("active"), $ = true);
        let fe = (X = k.closest(".nav")) == null ? void 0 : X.previousSibling;
        for (; (I = fe == null ? void 0 : fe.classList) != null && I.contains("nav-item"); )
          $ = true, (z = fe.querySelector(".nav-link")) == null || z.classList.add("active"), fe = (te = fe.closest(".nav")) == null ? void 0 : te.previousSibling;
      } else if (k.classList.remove("active"), S && !$ && ((ae = S == null ? void 0 : S.querySelector(".dropdown-toggle")) == null || ae.classList.remove("active")), !$) {
        let fe = (K = k.closest(".nav")) == null ? void 0 : K.previousSibling;
        for (; (ne = fe == null ? void 0 : fe.classList) != null && ne.contains("nav-item"); )
          $ = true, fe.querySelector(".nav-link") !== N && ((re = fe.querySelector(".nav-link")) == null || re.classList.remove("active")), fe = (Q = fe.closest(".nav")) == null ? void 0 : Q.previousSibling;
      }
    });
  });
  const O = v ? Pr(
    n,
    () => {
      B();
    },
    {
      childList: true
    }
  ) : { stop: () => {
  } }, Y = (F, j = false) => {
    var H, k;
    F.preventDefault();
    const $ = (k = (H = F.target) == null ? void 0 : H.getAttribute) == null ? void 0 : k.call(H, "href"), N = $ ? document == null ? void 0 : document.querySelector($) : null;
    N && n.value && (n.value.scrollTo ? n.value.scrollTo({ top: N.offsetTop, behavior: j ? "smooth" : "auto" }) : n.value.scrollTop = N.offsetTop);
  }, U = () => {
    V.stop(), O.stop();
  };
  return {
    current: readonly(y),
    list: h2,
    content: n,
    target: r,
    scrollIntoView: Y,
    updateList: B,
    cleanup: U
  };
};
var hn = () => ({ ...inject(Zl) });
var Si = (t4) => computed(() => {
  const l = {
    name: "",
    enterActiveClass: "",
    enterToClass: "",
    leaveActiveClass: "",
    leaveToClass: "showing",
    enterFromClass: "showing",
    leaveFromClass: "",
    css: true
  }, e = {
    ...l,
    name: "fade",
    enterActiveClass: "fade showing",
    leaveActiveClass: "fade showing"
  };
  return toValue(t4) ? l : e;
});
var Va = defineComponent({
  __name: "BTransition",
  props: {
    appear: { type: Boolean, default: false },
    mode: { default: void 0 },
    noFade: { type: Boolean, default: false },
    transProps: { default: void 0 }
  },
  emits: ["after-appear", "after-enter", "after-leave", "appear", "before-appear", "before-enter", "before-leave", "enter", "appear-cancelled", "enter-cancelled", "leave", "leave-cancelled"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BTransition"), a = l, n = computed(() => {
      const u = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, i = {
        ...u,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return o.noFade ? u : i;
    }), r = computed(() => ({ mode: o.mode, css: true, ...n.value }));
    return (u, i) => (openBlock(), createBlock(Transition, mergeProps({ ...r.value, ...unref(o).transProps }, {
      appear: unref(o).appear,
      onAfterAppear: i[0] || (i[0] = (d) => a("after-appear", d)),
      onAfterEnter: i[1] || (i[1] = (d) => a("after-enter", d)),
      onAfterLeave: i[2] || (i[2] = (d) => a("after-leave", d)),
      onAppear: i[3] || (i[3] = (d) => a("appear", d)),
      onBeforeAppear: i[4] || (i[4] = (d) => a("before-appear", d)),
      onBeforeEnter: i[5] || (i[5] = (d) => a("before-enter", d)),
      onBeforeLeave: i[6] || (i[6] = (d) => a("before-leave", d)),
      onEnter: i[7] || (i[7] = (d) => a("enter", d)),
      onAppearCancelled: i[8] || (i[8] = (d) => a("appear-cancelled", d)),
      onEnterCancelled: i[9] || (i[9] = (d) => a("enter-cancelled", d)),
      onLeave: i[10] || (i[10] = (d) => a("leave", d)),
      onLeaveCancelled: i[11] || (i[11] = (d) => a("leave-cancelled", d))
    }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["appear"]));
  }
});
var xi = ["type", "disabled", "aria-label"];
var zt = defineComponent({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { type: Boolean, default: false },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BCloseButton"), a = l;
    return (n, r) => (openBlock(), createElementBlock("button", {
      type: unref(o).type,
      class: "btn-close",
      disabled: unref(o).disabled,
      "aria-label": unref(o).ariaLabel,
      onClick: r[0] || (r[0] = (u) => a("click", u))
    }, null, 8, xi));
  }
});
var Wo = "active";
var it = defineComponent({
  __name: "BLink",
  props: {
    active: { type: Boolean, default: void 0 },
    activeClass: { default: "router-link-active" },
    disabled: { type: Boolean, default: false },
    exactActiveClass: { default: "router-link-exact-active" },
    href: { default: void 0 },
    icon: { type: Boolean, default: false },
    stretched: { type: Boolean, default: false },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: false },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: null },
    variant: { default: null },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  emits: ["click"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BLink"), a = l, n = useAttrs(), r = inject(ho, null), u = inject(Bo, null), i = getCurrentInstance(), d = computed(() => {
      const h2 = o.routerComponentName.split("-").map((m) => m.charAt(0).toUpperCase() + m.slice(1)).join("");
      return !((i == null ? void 0 : i.appContext.app.component(h2)) !== void 0) || o.disabled || !o.to ? "a" : o.routerComponentName;
    }), c = computed(() => {
      const h2 = "#";
      if (o.href)
        return o.href;
      if (typeof o.to == "string")
        return o.to || h2;
      const { to: w } = o;
      if (w !== void 0 && "path" in w) {
        const m = w.path || "", B = w.query ? `?${Object.keys(w.query).map((A) => {
          var C;
          return `${A}=${(C = w.query) == null ? void 0 : C[A]}`;
        }).join("=")}` : "", g = !w.hash || w.hash.charAt(0) === "#" ? w.hash || "" : `#${w.hash}`;
        return `${m}${B}${g}` || h2;
      }
      return h2;
    }), f = computed(() => ({
      [`link-${o.variant}`]: o.variant !== null,
      [`link-opacity-${o.opacity}`]: o.opacity !== void 0,
      [`link-opacity-${o.opacityHover}-hover`]: o.opacityHover !== void 0,
      [`link-underline-${o.underlineVariant}`]: o.underlineVariant !== null,
      [`link-offset-${o.underlineOffset}`]: o.underlineOffset !== void 0,
      [`link-offset-${o.underlineOffsetHover}-hover`]: o.underlineOffsetHover !== void 0,
      [`link-underline-opacity-${o.underlineOpacity}`]: o.underlineOpacity !== void 0,
      [`link-underline-opacity-${o.underlineOpacityHover}-hover`]: o.underlineOpacityHover !== void 0,
      "icon-link": o.icon === true,
      "stretched-link": o.stretched === true
    })), p = computed(() => ({
      class: f.value,
      to: o.to,
      replace: o.replace,
      href: c.value,
      target: o.target,
      rel: o.target === "_blank" ? o.rel ?? "noopener" : void 0,
      tabindex: o.disabled ? "-1" : typeof n.tabindex > "u" ? null : n.tabindex,
      "aria-disabled": o.disabled ? true : null
    })), v = computed(() => ({
      [Wo]: o.active,
      disabled: o.disabled
    })), y = (h2) => {
      var w, m, B;
      if (o.disabled) {
        h2.preventDefault(), h2.stopImmediatePropagation();
        return;
      }
      (((w = r == null ? void 0 : r.isNav) == null ? void 0 : w.value) === true && u === null || u !== null && ((m = u.autoClose) == null ? void 0 : m.value) === true) && ((B = r == null ? void 0 : r.hide) == null || B.call(r)), a("click", h2);
    };
    return (h2, w) => d.value === "router-link" ? (openBlock(), createBlock(resolveDynamicComponent(d.value), mergeProps({ key: 0 }, p.value, { custom: "" }), {
      default: withCtx(({ href: m, navigate: B, isActive: g, isExactActive: A }) => [
        (openBlock(), createBlock(resolveDynamicComponent(unref(o).routerTag), mergeProps({
          href: m,
          class: {
            [Wo]: unref(o).active,
            [unref(o).activeClass]: g,
            [unref(o).exactActiveClass]: A
          }
        }, h2.$attrs, {
          onClick: (C) => {
            B(C), y(C);
          }
        }), {
          default: withCtx(() => [
            renderSlot(h2.$slots, "default")
          ]),
          _: 2
        }, 1040, ["href", "class", "onClick"]))
      ]),
      _: 3
    }, 16)) : (openBlock(), createBlock(resolveDynamicComponent(d.value), mergeProps({
      key: 1,
      class: v.value
    }, p.value, { onClick: y }), {
      default: withCtx(() => [
        renderSlot(h2.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var $i = ["aria-valuenow", "aria-valuemax"];
var Bn = defineComponent({
  __name: "BProgressBar",
  props: {
    animated: { type: Boolean, default: false },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { type: Boolean, default: false },
    showValue: { type: Boolean, default: false },
    striped: { type: Boolean, default: false },
    value: { default: 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BProgressBar"), o = inject(ql, null), a = lt(e), n = computed(() => [
      a.value,
      {
        "progress-bar-animated": e.animated || (o == null ? void 0 : o.animated.value),
        "progress-bar-striped": e.striped || (o == null ? void 0 : o.striped.value) || e.animated || (o == null ? void 0 : o.animated.value)
      }
    ]), r = _e(() => e.precision), u = _e(() => e.value), i = _e(() => e.max ?? NaN), d = _e(() => (o == null ? void 0 : o.max.value) ?? NaN), c = computed(
      () => e.labelHtml !== void 0 ? e.labelHtml : e.showValue || o != null && o.showValue.value ? u.value.toFixed(r.value) : e.showProgress || o != null && o.showProgress.value ? (u.value * 100 / (i.value || 100)).toFixed(r.value) : e.label !== void 0 ? e.label : ""
    ), f = computed(
      () => d.value ? `${u.value * 100 / d.value}%` : i.value ? `${u.value * 100 / i.value}%` : typeof e.value == "string" ? e.value : `${e.value}%`
    );
    return (p, v) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["progress-bar", n.value]),
      role: "progressbar",
      "aria-valuenow": unref(e).value,
      "aria-valuemin": "0",
      "aria-valuemax": unref(e).max,
      style: normalizeStyle({ width: f.value })
    }, [
      renderSlot(p.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(c.value), 1)
      ])
    ], 14, $i));
  }
});
var _n = defineComponent({
  __name: "BProgress",
  props: {
    height: { default: void 0 },
    animated: { type: Boolean, default: void 0 },
    max: { default: 100 },
    precision: { default: void 0 },
    showProgress: { type: Boolean, default: void 0 },
    showValue: { type: Boolean, default: void 0 },
    striped: { type: Boolean, default: void 0 },
    value: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BProgress");
    return provide(ql, {
      animated: toRef(() => e.animated),
      max: toRef(() => e.max),
      showProgress: toRef(() => e.showProgress),
      showValue: toRef(() => e.showValue),
      striped: toRef(() => e.striped)
    }), (o, a) => (openBlock(), createElementBlock("div", {
      class: "progress",
      style: normalizeStyle({ height: unref(e).height })
    }, [
      renderSlot(o.$slots, "default", {}, () => [
        createVNode(Bn, {
          animated: unref(e).animated,
          max: unref(e).max,
          precision: unref(e).precision,
          "show-progress": unref(e).showProgress,
          "show-value": unref(e).showValue,
          striped: unref(e).striped,
          value: unref(e).value,
          variant: unref(e).variant,
          "text-variant": unref(e).textVariant,
          "bg-variant": unref(e).bgVariant
        }, null, 8, ["animated", "max", "precision", "show-progress", "show-value", "striped", "value", "variant", "text-variant", "bg-variant"])
      ])
    ], 4));
  }
});
var Vi = ["id", "role", "aria-live", "aria-atomic"];
var Ai = { class: "me-auto" };
var wn = defineComponent({
  __name: "BToast",
  props: mergeModels({
    body: { default: void 0 },
    bodyClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "div" },
    id: { default: void 0 },
    interval: { default: 1e3 },
    isStatus: { type: Boolean, default: false },
    modelValue: { type: [Boolean, Number] },
    noCloseButton: { type: Boolean, default: false },
    noFade: { type: Boolean, default: false },
    noHoverPause: { type: Boolean, default: false },
    progressProps: { default: void 0 },
    showOnPause: { type: Boolean, default: true },
    solid: { type: Boolean, default: false },
    title: { default: void 0 },
    toastClass: { default: void 0 },
    transProps: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: null },
    textVariant: { default: null },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: false },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  }, {
    modelValue: { type: [Boolean, Number], default: false },
    modelModifiers: {}
  }),
  emits: mergeModels(["close", "close-countdown", "hide", "hidden", "show", "shown", "show-prevented", "hide-prevented"], ["update:modelValue"]),
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BToast"), n = e, r = ref(null), u = yo(r), i = useModel(t4, "modelValue"), { computedLink: d, computedLinkProps: c } = Tt(a), f = _e(() => a.interval), p = lt(a), v = toRef(() => typeof i.value == "boolean" ? 0 : i.value), {
      isActive: y,
      pause: h2,
      restart: w,
      resume: m,
      stop: B,
      isPaused: g,
      value: A
    } = nn(v, f, {
      immediate: typeof i.value == "number"
    });
    watchEffect(() => {
      n("close-countdown", A.value);
    });
    const C = toRef(() => d.value ? it : "div"), V = toRef(
      () => typeof i.value == "boolean" ? i.value : y.value || a.showOnPause && g.value
    ), O = computed(() => [
      p.value,
      {
        show: V.value
      }
    ]), Y = () => {
      a.noHoverPause || h2();
    };
    watch(u, (k) => {
      if (k) {
        Y();
        return;
      }
      m();
    });
    const U = (k, S = {}) => new Ct(k, {
      cancelable: false,
      target: r.value || null,
      relatedTarget: null,
      trigger: null,
      ...S,
      componentId: a.id
    }), F = () => {
      const k = U("show", { cancelable: true });
      if (n("show", k), k.defaultPrevented) {
        i.value && (i.value = false), n("show-prevented");
        return;
      }
      i.value || (i.value = true);
    }, j = (k = "") => {
      const S = U("hide", { cancelable: k !== "", trigger: k });
      if (n("hide", S), k === "close" && n("close", S), S.defaultPrevented) {
        n("hide-prevented"), i.value || (i.value = true);
        return;
      }
      typeof i.value == "boolean" ? i.value = false : (i.value = 0, B());
    }, $ = () => {
      F();
    }, N = () => {
      n("shown", U("shown"));
    }, H = () => {
      n("hidden", U("hidden"));
    };
    return watch(y, (k) => {
      k === false && g.value === false && i.value && j();
    }), onBeforeUnmount(B), l({
      pause: h2,
      restart: w,
      resume: m,
      stop: B
    }), (k, S) => (openBlock(), createBlock(Va, mergeProps({
      "no-fade": unref(a).noFade
    }, unref(a).transProps, {
      onBeforeEnter: $,
      onAfterEnter: N,
      onAfterLeave: H
    }), {
      default: withCtx(() => [
        V.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          id: unref(a).id,
          ref_key: "element",
          ref: r,
          class: normalizeClass(["toast", [unref(a).toastClass, O.value]]),
          tabindex: "0",
          role: V.value ? unref(a).isStatus ? "status" : "alert" : void 0,
          "aria-live": V.value ? unref(a).isStatus ? "polite" : "assertive" : void 0,
          "aria-atomic": V.value ? true : void 0
        }, [
          k.$slots.title || unref(a).title ? (openBlock(), createBlock(resolveDynamicComponent(unref(a).headerTag), {
            key: 0,
            class: normalizeClass(["toast-header", unref(a).headerClass])
          }, {
            default: withCtx(() => [
              renderSlot(k.$slots, "title", { hide: j }, () => [
                createBaseVNode("strong", Ai, toDisplayString(unref(a).title), 1)
              ]),
              unref(a).noCloseButton ? createCommentVNode("", true) : (openBlock(), createBlock(zt, {
                key: 0,
                onClick: S[0] || (S[0] = (E) => j("close"))
              }))
            ]),
            _: 3
          }, 8, ["class"])) : createCommentVNode("", true),
          k.$slots.default || unref(a).body ? (openBlock(), createBlock(resolveDynamicComponent(C.value), mergeProps({
            key: 1,
            class: ["toast-body", unref(a).bodyClass],
            style: { display: "block" }
          }, unref(c), {
            onClick: S[1] || (S[1] = (E) => unref(d) ? j() : () => {
            })
          }), {
            default: withCtx(() => [
              renderSlot(k.$slots, "default", { hide: j }, () => [
                createTextVNode(toDisplayString(unref(a).body), 1)
              ])
            ]),
            _: 3
          }, 16, ["class"])) : createCommentVNode("", true),
          typeof i.value == "number" && unref(a).progressProps !== void 0 ? (openBlock(), createBlock(_n, {
            key: 2,
            animated: unref(a).progressProps.animated,
            precision: unref(a).progressProps.precision,
            "show-progress": unref(a).progressProps.showProgress,
            "show-value": unref(a).progressProps.showValue,
            striped: unref(a).progressProps.striped,
            variant: unref(a).progressProps.variant,
            max: i.value,
            value: unref(A),
            height: "4px"
          }, null, 8, ["animated", "precision", "show-progress", "show-value", "striped", "variant", "max", "value"])) : createCommentVNode("", true)
        ], 10, Vi)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16, ["no-fade"]));
  }
});
var Ni = "top-end";
var Cn = {
  install(t4) {
    const l = ref([]), e = ref(false), o = (u) => {
      e.value = u;
    }, a = (u) => {
      var f;
      const i = Symbol(), d = ref(((f = toValue(u.props)) == null ? void 0 : f.value) || 5e3), c = computed({
        get: () => {
          const p = toValue(u.props);
          return {
            component: toValue(u.component) ?? wn,
            props: {
              ...p,
              pos: (p == null ? void 0 : p.pos) || Ni,
              _modelValue: d.value,
              _self: i
            }
          };
        },
        set: (p) => {
          d.value = p.props._modelValue;
        }
      });
      return (c.value.props.appendToast !== void 0 ? c.value.props.appendToast : e.value) ? l.value.push(c) : l.value.unshift(c), i;
    }, n = (u) => {
      l.value = l.value.filter((i) => i.value.props._self !== u);
    }, r = (u) => {
      const i = l.value.find((d) => d.value.props._self === u);
      i !== void 0 && (i.value = {
        ...i.value,
        props: {
          ...i.value.props,
          _modelValue: false
        }
      });
    };
    t4.provide(Zl, {
      _setIsAppend: o,
      toasts: l,
      show: a,
      remove: n,
      leave: r
    });
  }
};
var kn = {
  install(t4) {
    const l = ref([]), e = () => {
      l.value.splice(0, l.value.length);
    };
    t4.provide(Ql, { items: l, reset: e });
  }
};
var Tn = {
  install(t4, l) {
    (l == null ? void 0 : l.id) instanceof Object && typeof l.id.getId == "function" && t4.provide(an, l.id.getId);
  }
};
var Sn = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var _a = Sn.join(",");
var xn = typeof Element > "u";
var Bt = xn ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var wa = !xn && Element.prototype.getRootNode ? function(t4) {
  var l;
  return t4 == null || (l = t4.getRootNode) === null || l === void 0 ? void 0 : l.call(t4);
} : function(t4) {
  return t4 == null ? void 0 : t4.ownerDocument;
};
var Ca = function t(l, e) {
  var o;
  e === void 0 && (e = true);
  var a = l == null || (o = l.getAttribute) === null || o === void 0 ? void 0 : o.call(l, "inert"), n = a === "" || a === "true", r = n || e && l && t(l.parentNode);
  return r;
};
var Oi = function(l) {
  var e, o = l == null || (e = l.getAttribute) === null || e === void 0 ? void 0 : e.call(l, "contenteditable");
  return o === "" || o === "true";
};
var $n = function(l, e, o) {
  if (Ca(l))
    return [];
  var a = Array.prototype.slice.apply(l.querySelectorAll(_a));
  return e && Bt.call(l, _a) && a.unshift(l), a = a.filter(o), a;
};
var Vn = function t2(l, e, o) {
  for (var a = [], n = Array.from(l); n.length; ) {
    var r = n.shift();
    if (!Ca(r, false))
      if (r.tagName === "SLOT") {
        var u = r.assignedElements(), i = u.length ? u : r.children, d = t2(i, true, o);
        o.flatten ? a.push.apply(a, d) : a.push({
          scopeParent: r,
          candidates: d
        });
      } else {
        var c = Bt.call(r, _a);
        c && o.filter(r) && (e || !l.includes(r)) && a.push(r);
        var f = r.shadowRoot || // check for an undisclosed shadow
        typeof o.getShadowRoot == "function" && o.getShadowRoot(r), p = !Ca(f, false) && (!o.shadowRootFilter || o.shadowRootFilter(r));
        if (f && p) {
          var v = t2(f === true ? r.children : f.children, true, o);
          o.flatten ? a.push.apply(a, v) : a.push({
            scopeParent: r,
            candidates: v
          });
        } else
          n.unshift.apply(n, r.children);
      }
  }
  return a;
};
var An = function(l) {
  return !isNaN(parseInt(l.getAttribute("tabindex"), 10));
};
var gt = function(l) {
  if (!l)
    throw new Error("No node provided");
  return l.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(l.tagName) || Oi(l)) && !An(l) ? 0 : l.tabIndex;
};
var Pi = function(l, e) {
  var o = gt(l);
  return o < 0 && e && !An(l) ? 0 : o;
};
var Ei = function(l, e) {
  return l.tabIndex === e.tabIndex ? l.documentOrder - e.documentOrder : l.tabIndex - e.tabIndex;
};
var Nn = function(l) {
  return l.tagName === "INPUT";
};
var Fi = function(l) {
  return Nn(l) && l.type === "hidden";
};
var Ii = function(l) {
  var e = l.tagName === "DETAILS" && Array.prototype.slice.apply(l.children).some(function(o) {
    return o.tagName === "SUMMARY";
  });
  return e;
};
var Li = function(l, e) {
  for (var o = 0; o < l.length; o++)
    if (l[o].checked && l[o].form === e)
      return l[o];
};
var Ri = function(l) {
  if (!l.name)
    return true;
  var e = l.form || wa(l), o = function(u) {
    return e.querySelectorAll('input[type="radio"][name="' + u + '"]');
  }, a;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    a = o(window.CSS.escape(l.name));
  else
    try {
      a = o(l.name);
    } catch (r) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", r.message), false;
    }
  var n = Li(a, l.form);
  return !n || n === l;
};
var zi = function(l) {
  return Nn(l) && l.type === "radio";
};
var Mi = function(l) {
  return zi(l) && !Ri(l);
};
var Hi = function(l) {
  var e, o = l && wa(l), a = (e = o) === null || e === void 0 ? void 0 : e.host, n = false;
  if (o && o !== l) {
    var r, u, i;
    for (n = !!((r = a) !== null && r !== void 0 && (u = r.ownerDocument) !== null && u !== void 0 && u.contains(a) || l != null && (i = l.ownerDocument) !== null && i !== void 0 && i.contains(l)); !n && a; ) {
      var d, c, f;
      o = wa(a), a = (d = o) === null || d === void 0 ? void 0 : d.host, n = !!((c = a) !== null && c !== void 0 && (f = c.ownerDocument) !== null && f !== void 0 && f.contains(a));
    }
  }
  return n;
};
var Go = function(l) {
  var e = l.getBoundingClientRect(), o = e.width, a = e.height;
  return o === 0 && a === 0;
};
var Di = function(l, e) {
  var o = e.displayCheck, a = e.getShadowRoot;
  if (getComputedStyle(l).visibility === "hidden")
    return true;
  var n = Bt.call(l, "details>summary:first-of-type"), r = n ? l.parentElement : l;
  if (Bt.call(r, "details:not([open]) *"))
    return true;
  if (!o || o === "full" || o === "legacy-full") {
    if (typeof a == "function") {
      for (var u = l; l; ) {
        var i = l.parentElement, d = wa(l);
        if (i && !i.shadowRoot && a(i) === true)
          return Go(l);
        l.assignedSlot ? l = l.assignedSlot : !i && d !== l.ownerDocument ? l = d.host : l = i;
      }
      l = u;
    }
    if (Hi(l))
      return !l.getClientRects().length;
    if (o !== "legacy-full")
      return true;
  } else if (o === "non-zero-area")
    return Go(l);
  return false;
};
var ji = function(l) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(l.tagName))
    for (var e = l.parentElement; e; ) {
      if (e.tagName === "FIELDSET" && e.disabled) {
        for (var o = 0; o < e.children.length; o++) {
          var a = e.children.item(o);
          if (a.tagName === "LEGEND")
            return Bt.call(e, "fieldset[disabled] *") ? true : !a.contains(l);
        }
        return true;
      }
      e = e.parentElement;
    }
  return false;
};
var ka = function(l, e) {
  return !(e.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  Ca(e) || Fi(e) || Di(e, l) || // For a details element with a summary, the summary element gets the focus
  Ii(e) || ji(e));
};
var Ua = function(l, e) {
  return !(Mi(e) || gt(e) < 0 || !ka(l, e));
};
var qi = function(l) {
  var e = parseInt(l.getAttribute("tabindex"), 10);
  return !!(isNaN(e) || e >= 0);
};
var Wi = function t3(l) {
  var e = [], o = [];
  return l.forEach(function(a, n) {
    var r = !!a.scopeParent, u = r ? a.scopeParent : a, i = Pi(u, r), d = r ? t3(a.candidates) : u;
    i === 0 ? r ? e.push.apply(e, d) : e.push(u) : o.push({
      documentOrder: n,
      tabIndex: i,
      item: a,
      isScope: r,
      content: d
    });
  }), o.sort(Ei).reduce(function(a, n) {
    return n.isScope ? a.push.apply(a, n.content) : a.push(n.content), a;
  }, []).concat(e);
};
var Gi = function(l, e) {
  e = e || {};
  var o;
  return e.getShadowRoot ? o = Vn([l], e.includeContainer, {
    filter: Ua.bind(null, e),
    flatten: false,
    getShadowRoot: e.getShadowRoot,
    shadowRootFilter: qi
  }) : o = $n(l, e.includeContainer, Ua.bind(null, e)), Wi(o);
};
var Ui = function(l, e) {
  e = e || {};
  var o;
  return e.getShadowRoot ? o = Vn([l], e.includeContainer, {
    filter: ka.bind(null, e),
    flatten: true,
    getShadowRoot: e.getShadowRoot
  }) : o = $n(l, e.includeContainer, ka.bind(null, e)), o;
};
var $t = function(l, e) {
  if (e = e || {}, !l)
    throw new Error("No node provided");
  return Bt.call(l, _a) === false ? false : Ua(e, l);
};
var Ki = Sn.concat("iframe").join(",");
var La = function(l, e) {
  if (e = e || {}, !l)
    throw new Error("No node provided");
  return Bt.call(l, Ki) === false ? false : ka(e, l);
};
function Uo(t4, l) {
  var e = Object.keys(t4);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(t4);
    l && (o = o.filter(function(a) {
      return Object.getOwnPropertyDescriptor(t4, a).enumerable;
    })), e.push.apply(e, o);
  }
  return e;
}
function Ko(t4) {
  for (var l = 1; l < arguments.length; l++) {
    var e = arguments[l] != null ? arguments[l] : {};
    l % 2 ? Uo(Object(e), true).forEach(function(o) {
      Xi(t4, o, e[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t4, Object.getOwnPropertyDescriptors(e)) : Uo(Object(e)).forEach(function(o) {
      Object.defineProperty(t4, o, Object.getOwnPropertyDescriptor(e, o));
    });
  }
  return t4;
}
function Xi(t4, l, e) {
  return l = Zi(l), l in t4 ? Object.defineProperty(t4, l, {
    value: e,
    enumerable: true,
    configurable: true,
    writable: true
  }) : t4[l] = e, t4;
}
function Yi(t4, l) {
  if (typeof t4 != "object" || t4 === null)
    return t4;
  var e = t4[Symbol.toPrimitive];
  if (e !== void 0) {
    var o = e.call(t4, l || "default");
    if (typeof o != "object")
      return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (l === "string" ? String : Number)(t4);
}
function Zi(t4) {
  var l = Yi(t4, "string");
  return typeof l == "symbol" ? l : String(l);
}
var Xo = {
  activateTrap: function(l, e) {
    if (l.length > 0) {
      var o = l[l.length - 1];
      o !== e && o.pause();
    }
    var a = l.indexOf(e);
    a === -1 || l.splice(a, 1), l.push(e);
  },
  deactivateTrap: function(l, e) {
    var o = l.indexOf(e);
    o !== -1 && l.splice(o, 1), l.length > 0 && l[l.length - 1].unpause();
  }
};
var Ji = function(l) {
  return l.tagName && l.tagName.toLowerCase() === "input" && typeof l.select == "function";
};
var Qi = function(l) {
  return (l == null ? void 0 : l.key) === "Escape" || (l == null ? void 0 : l.key) === "Esc" || (l == null ? void 0 : l.keyCode) === 27;
};
var qt = function(l) {
  return (l == null ? void 0 : l.key) === "Tab" || (l == null ? void 0 : l.keyCode) === 9;
};
var eu = function(l) {
  return qt(l) && !l.shiftKey;
};
var tu = function(l) {
  return qt(l) && l.shiftKey;
};
var Yo = function(l) {
  return setTimeout(l, 0);
};
var Zo = function(l, e) {
  var o = -1;
  return l.every(function(a, n) {
    return e(a) ? (o = n, false) : true;
  }), o;
};
var Ht = function(l) {
  for (var e = arguments.length, o = new Array(e > 1 ? e - 1 : 0), a = 1; a < e; a++)
    o[a - 1] = arguments[a];
  return typeof l == "function" ? l.apply(void 0, o) : l;
};
var oa = function(l) {
  return l.target.shadowRoot && typeof l.composedPath == "function" ? l.composedPath()[0] : l.target;
};
var au = [];
var ou = function(l, e) {
  var o = (e == null ? void 0 : e.document) || document, a = (e == null ? void 0 : e.trapStack) || au, n = Ko({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward: eu,
    isKeyBackward: tu
  }, e), r = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  }, u, i = function($, N, H) {
    return $ && $[N] !== void 0 ? $[N] : n[H || N];
  }, d = function($, N) {
    var H = typeof (N == null ? void 0 : N.composedPath) == "function" ? N.composedPath() : void 0;
    return r.containerGroups.findIndex(function(k) {
      var S = k.container, E = k.tabbableNodes;
      return S.contains($) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (H == null ? void 0 : H.includes(S)) || E.find(function(M) {
        return M === $;
      });
    });
  }, c = function($) {
    var N = n[$];
    if (typeof N == "function") {
      for (var H = arguments.length, k = new Array(H > 1 ? H - 1 : 0), S = 1; S < H; S++)
        k[S - 1] = arguments[S];
      N = N.apply(void 0, k);
    }
    if (N === true && (N = void 0), !N) {
      if (N === void 0 || N === false)
        return N;
      throw new Error("`".concat($, "` was specified but was not a node, or did not return a node"));
    }
    var E = N;
    if (typeof N == "string" && (E = o.querySelector(N), !E))
      throw new Error("`".concat($, "` as selector refers to no known node"));
    return E;
  }, f = function() {
    var $ = c("initialFocus");
    if ($ === false)
      return false;
    if ($ === void 0 || !La($, n.tabbableOptions))
      if (d(o.activeElement) >= 0)
        $ = o.activeElement;
      else {
        var N = r.tabbableGroups[0], H = N && N.firstTabbableNode;
        $ = H || c("fallbackFocus");
      }
    if (!$)
      throw new Error("Your focus-trap needs to have at least one focusable element");
    return $;
  }, p = function() {
    if (r.containerGroups = r.containers.map(function($) {
      var N = Gi($, n.tabbableOptions), H = Ui($, n.tabbableOptions), k = N.length > 0 ? N[0] : void 0, S = N.length > 0 ? N[N.length - 1] : void 0, E = H.find(function(I) {
        return $t(I);
      }), M = H.slice().reverse().find(function(I) {
        return $t(I);
      }), X = !!N.find(function(I) {
        return gt(I) > 0;
      });
      return {
        container: $,
        tabbableNodes: N,
        focusableNodes: H,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound: X,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode: k,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode: S,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode: E,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode: M,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function(z) {
          var te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, ae = N.indexOf(z);
          return ae < 0 ? te ? H.slice(H.indexOf(z) + 1).find(function(K) {
            return $t(K);
          }) : H.slice(0, H.indexOf(z)).reverse().find(function(K) {
            return $t(K);
          }) : N[ae + (te ? 1 : -1)];
        }
      };
    }), r.tabbableGroups = r.containerGroups.filter(function($) {
      return $.tabbableNodes.length > 0;
    }), r.tabbableGroups.length <= 0 && !c("fallbackFocus"))
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    if (r.containerGroups.find(function($) {
      return $.posTabIndexesFound;
    }) && r.containerGroups.length > 1)
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
  }, v = function j($) {
    var N = $.activeElement;
    if (N)
      return N.shadowRoot && N.shadowRoot.activeElement !== null ? j(N.shadowRoot) : N;
  }, y = function j($) {
    if ($ !== false && $ !== v(document)) {
      if (!$ || !$.focus) {
        j(f());
        return;
      }
      $.focus({
        preventScroll: !!n.preventScroll
      }), r.mostRecentlyFocusedNode = $, Ji($) && $.select();
    }
  }, h2 = function($) {
    var N = c("setReturnFocus", $);
    return N || (N === false ? false : $);
  }, w = function($) {
    var N = $.target, H = $.event, k = $.isBackward, S = k === void 0 ? false : k;
    N = N || oa(H), p();
    var E = null;
    if (r.tabbableGroups.length > 0) {
      var M = d(N, H), X = M >= 0 ? r.containerGroups[M] : void 0;
      if (M < 0)
        S ? E = r.tabbableGroups[r.tabbableGroups.length - 1].lastTabbableNode : E = r.tabbableGroups[0].firstTabbableNode;
      else if (S) {
        var I = Zo(r.tabbableGroups, function(re) {
          var Q = re.firstTabbableNode;
          return N === Q;
        });
        if (I < 0 && (X.container === N || La(N, n.tabbableOptions) && !$t(N, n.tabbableOptions) && !X.nextTabbableNode(N, false)) && (I = M), I >= 0) {
          var z = I === 0 ? r.tabbableGroups.length - 1 : I - 1, te = r.tabbableGroups[z];
          E = gt(N) >= 0 ? te.lastTabbableNode : te.lastDomTabbableNode;
        } else
          qt(H) || (E = X.nextTabbableNode(N, false));
      } else {
        var ae = Zo(r.tabbableGroups, function(re) {
          var Q = re.lastTabbableNode;
          return N === Q;
        });
        if (ae < 0 && (X.container === N || La(N, n.tabbableOptions) && !$t(N, n.tabbableOptions) && !X.nextTabbableNode(N)) && (ae = M), ae >= 0) {
          var K = ae === r.tabbableGroups.length - 1 ? 0 : ae + 1, ne = r.tabbableGroups[K];
          E = gt(N) >= 0 ? ne.firstTabbableNode : ne.firstDomTabbableNode;
        } else
          qt(H) || (E = X.nextTabbableNode(N));
      }
    } else
      E = c("fallbackFocus");
    return E;
  }, m = function($) {
    var N = oa($);
    if (!(d(N, $) >= 0)) {
      if (Ht(n.clickOutsideDeactivates, $)) {
        u.deactivate({
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked (and if not focusable, to "nothing"); by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node), whether the
          //  outside click was on a focusable node or not
          returnFocus: n.returnFocusOnDeactivate
        });
        return;
      }
      Ht(n.allowOutsideClick, $) || $.preventDefault();
    }
  }, B = function($) {
    var N = oa($), H = d(N, $) >= 0;
    if (H || N instanceof Document)
      H && (r.mostRecentlyFocusedNode = N);
    else {
      $.stopImmediatePropagation();
      var k, S = true;
      if (r.mostRecentlyFocusedNode)
        if (gt(r.mostRecentlyFocusedNode) > 0) {
          var E = d(r.mostRecentlyFocusedNode), M = r.containerGroups[E].tabbableNodes;
          if (M.length > 0) {
            var X = M.findIndex(function(I) {
              return I === r.mostRecentlyFocusedNode;
            });
            X >= 0 && (n.isKeyForward(r.recentNavEvent) ? X + 1 < M.length && (k = M[X + 1], S = false) : X - 1 >= 0 && (k = M[X - 1], S = false));
          }
        } else
          r.containerGroups.some(function(I) {
            return I.tabbableNodes.some(function(z) {
              return gt(z) > 0;
            });
          }) || (S = false);
      else
        S = false;
      S && (k = w({
        // move FROM the MRU node, not event-related node (which will be the node that is
        //  outside the trap causing the focus escape we're trying to fix)
        target: r.mostRecentlyFocusedNode,
        isBackward: n.isKeyBackward(r.recentNavEvent)
      })), y(k || r.mostRecentlyFocusedNode || f());
    }
    r.recentNavEvent = void 0;
  }, g = function($) {
    var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    r.recentNavEvent = $;
    var H = w({
      event: $,
      isBackward: N
    });
    H && (qt($) && $.preventDefault(), y(H));
  }, A = function($) {
    if (Qi($) && Ht(n.escapeDeactivates, $) !== false) {
      $.preventDefault(), u.deactivate();
      return;
    }
    (n.isKeyForward($) || n.isKeyBackward($)) && g($, n.isKeyBackward($));
  }, C = function($) {
    var N = oa($);
    d(N, $) >= 0 || Ht(n.clickOutsideDeactivates, $) || Ht(n.allowOutsideClick, $) || ($.preventDefault(), $.stopImmediatePropagation());
  }, V = function() {
    if (r.active)
      return Xo.activateTrap(a, u), r.delayInitialFocusTimer = n.delayInitialFocus ? Yo(function() {
        y(f());
      }) : y(f()), o.addEventListener("focusin", B, true), o.addEventListener("mousedown", m, {
        capture: true,
        passive: false
      }), o.addEventListener("touchstart", m, {
        capture: true,
        passive: false
      }), o.addEventListener("click", C, {
        capture: true,
        passive: false
      }), o.addEventListener("keydown", A, {
        capture: true,
        passive: false
      }), u;
  }, O = function() {
    if (r.active)
      return o.removeEventListener("focusin", B, true), o.removeEventListener("mousedown", m, true), o.removeEventListener("touchstart", m, true), o.removeEventListener("click", C, true), o.removeEventListener("keydown", A, true), u;
  }, Y = function($) {
    var N = $.some(function(H) {
      var k = Array.from(H.removedNodes);
      return k.some(function(S) {
        return S === r.mostRecentlyFocusedNode;
      });
    });
    N && y(f());
  }, U = typeof window < "u" && "MutationObserver" in window ? new MutationObserver(Y) : void 0, F = function() {
    U && (U.disconnect(), r.active && !r.paused && r.containers.map(function($) {
      U.observe($, {
        subtree: true,
        childList: true
      });
    }));
  };
  return u = {
    get active() {
      return r.active;
    },
    get paused() {
      return r.paused;
    },
    activate: function($) {
      if (r.active)
        return this;
      var N = i($, "onActivate"), H = i($, "onPostActivate"), k = i($, "checkCanFocusTrap");
      k || p(), r.active = true, r.paused = false, r.nodeFocusedBeforeActivation = o.activeElement, N == null || N();
      var S = function() {
        k && p(), V(), F(), H == null || H();
      };
      return k ? (k(r.containers.concat()).then(S, S), this) : (S(), this);
    },
    deactivate: function($) {
      if (!r.active)
        return this;
      var N = Ko({
        onDeactivate: n.onDeactivate,
        onPostDeactivate: n.onPostDeactivate,
        checkCanReturnFocus: n.checkCanReturnFocus
      }, $);
      clearTimeout(r.delayInitialFocusTimer), r.delayInitialFocusTimer = void 0, O(), r.active = false, r.paused = false, F(), Xo.deactivateTrap(a, u);
      var H = i(N, "onDeactivate"), k = i(N, "onPostDeactivate"), S = i(N, "checkCanReturnFocus"), E = i(N, "returnFocus", "returnFocusOnDeactivate");
      H == null || H();
      var M = function() {
        Yo(function() {
          E && y(h2(r.nodeFocusedBeforeActivation)), k == null || k();
        });
      };
      return E && S ? (S(h2(r.nodeFocusedBeforeActivation)).then(M, M), this) : (M(), this);
    },
    pause: function($) {
      if (r.paused || !r.active)
        return this;
      var N = i($, "onPause"), H = i($, "onPostPause");
      return r.paused = true, N == null || N(), O(), F(), H == null || H(), this;
    },
    unpause: function($) {
      if (!r.paused || !r.active)
        return this;
      var N = i($, "onUnpause"), H = i($, "onPostUnpause");
      return r.paused = false, N == null || N(), p(), V(), F(), H == null || H(), this;
    },
    updateContainerElements: function($) {
      var N = [].concat($).filter(Boolean);
      return r.containers = N.map(function(H) {
        return typeof H == "string" ? o.querySelector(H) : H;
      }), r.active && p(), F(), this;
    }
  }, u.updateContainerElements(l), u;
};
function lu(t4, l = {}) {
  let e;
  const { immediate: o, ...a } = l, n = ref(false), r = ref(false), u = (f) => e && e.activate(f), i = (f) => e && e.deactivate(f), d = () => {
    e && (e.pause(), r.value = true);
  }, c = () => {
    e && (e.unpause(), r.value = false);
  };
  return watch(
    () => Le(t4),
    (f) => {
      f && (e = ou(f, {
        ...a,
        onActivate() {
          n.value = true, l.onActivate && l.onActivate();
        },
        onDeactivate() {
          n.value = false, l.onDeactivate && l.onDeactivate();
        }
      }), o && u());
    },
    { flush: "post" }
  ), rt(() => i()), {
    hasFocus: n,
    isPaused: r,
    activate: u,
    deactivate: i,
    pause: d,
    unpause: c
  };
}
var nu = {
  key: 0,
  class: "visually-hidden"
};
var Aa = defineComponent({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { type: Boolean, default: false },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BSpinner"), o = useSlots(), a = computed(() => [
      `spinner-${e.type}`,
      {
        [`spinner-${e.type}-sm`]: e.small,
        [`text-${e.variant}`]: e.variant !== null
      }
    ]), n = toRef(() => !Ne(o.label));
    return (r, u) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(a.value),
      role: unref(e).label || n.value ? unref(e).role : null,
      "aria-hidden": unref(e).label || n.value ? null : true
    }, {
      default: withCtx(() => [
        unref(e).label || n.value ? (openBlock(), createElementBlock("span", nu, [
          renderSlot(r.$slots, "label", {}, () => [
            createTextVNode(toDisplayString(unref(e).label), 1)
          ])
        ])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
});
var vt = defineComponent({
  __name: "BButton",
  props: mergeModels({
    loading: { type: Boolean, default: false },
    loadingFill: { type: Boolean, default: false },
    loadingText: { default: "Loading..." },
    pill: { type: Boolean, default: false },
    pressed: { type: Boolean },
    size: { default: "md" },
    squared: { type: Boolean, default: false },
    tag: { default: "button" },
    type: { default: "button" },
    variant: { default: "secondary" },
    active: { type: Boolean, default: false },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: false },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    routerTag: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  }, {
    pressed: { type: Boolean, default: void 0 },
    pressedModifiers: {}
  }),
  emits: mergeModels(["click"], ["update:pressed"]),
  setup(t4, { emit: l }) {
    const o = G(t4, "BButton"), a = l, n = useModel(t4, "pressed"), { computedLink: r, computedLinkProps: u } = Tt(o, [
      "active-class",
      "exact-active-class",
      "replace",
      "routerComponentName",
      "routerTag"
    ]), i = toRef(() => typeof o.pressed == "boolean"), d = toRef(
      () => o.tag === "button" && o.href === void 0 && o.to === void 0
    ), c = toRef(() => o.to !== void 0), f = toRef(() => o.href !== void 0 ? false : !d.value), p = computed(() => c.value ? u.value : []), v = computed(() => [
      [`btn-${o.size}`],
      {
        [`btn-${o.variant}`]: o.variant !== null,
        active: o.active || o.pressed,
        "rounded-pill": o.pill,
        "rounded-0": o.squared,
        disabled: o.disabled
      }
    ]), y = toRef(() => c.value ? it : o.href ? "a" : o.tag), h2 = (w) => {
      if (o.disabled) {
        w.preventDefault(), w.stopPropagation();
        return;
      }
      a("click", w), i.value && (n.value = !o.pressed);
    };
    return (w, m) => (openBlock(), createBlock(resolveDynamicComponent(y.value), mergeProps({ class: "btn" }, p.value, {
      class: v.value,
      "aria-disabled": f.value ? unref(o).disabled : null,
      "aria-pressed": i.value ? unref(o).pressed : null,
      autocomplete: i.value ? "off" : null,
      disabled: d.value ? unref(o).disabled : null,
      href: unref(o).href,
      rel: unref(r) ? unref(o).rel : null,
      role: f.value || unref(r) ? "button" : null,
      target: unref(r) ? unref(o).target : null,
      type: d.value ? unref(o).type : null,
      to: d.value ? null : unref(o).to,
      onClick: h2
    }), {
      default: withCtx(() => [
        unref(o).loading ? renderSlot(w.$slots, "loading", { key: 0 }, () => [
          unref(o).loadingFill ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(unref(o).loadingText), 1)
          ], 64)),
          renderSlot(w.$slots, "loading-spinner", {}, () => [
            createVNode(Aa, {
              small: unref(o).size !== "lg",
              label: unref(o).loadingFill ? unref(o).loadingText : void 0
            }, null, 8, ["small", "label"])
          ])
        ]) : renderSlot(w.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 16, ["class", "aria-disabled", "aria-pressed", "autocomplete", "disabled", "href", "rel", "role", "target", "type", "to"]));
  }
});
var Zt = defineComponent({
  name: "RenderComponentOrSkip",
  inheritAttrs: false,
  slots: Object,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    to: {
      type: [String, Object],
      default: null
    },
    skip: {
      type: Boolean,
      default: false
    }
  },
  setup(t4, { slots: l, attrs: e }) {
    return () => {
      var o, a, n;
      return t4.skip ? (o = l.default) == null ? void 0 : o.call(l) : t4.tag === "Teleport" ? h(Teleport, { to: t4.to }, [(a = l.default) == null ? void 0 : a.call(l)]) : h(t4.tag, { ...e }, [(n = l.default) == null ? void 0 : n.call(l)]);
    };
  }
});
var Na = defineComponent({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { type: Boolean, default: false },
    noCenter: { type: Boolean, default: false },
    noFade: { type: Boolean, default: false },
    noSpinner: { type: Boolean, default: false },
    noWrap: { type: Boolean, default: false },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    show: { type: Boolean, default: false },
    spinnerSmall: { type: Boolean, default: false },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 },
    rounded: { type: [Boolean, String, Number], default: false },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  emits: ["click", "hidden", "shown"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BOverlay"), a = l, n = { top: 0, left: 0, bottom: 0, right: 0 }, r = Co(() => ({
      rounded: o.rounded,
      roundedTop: o.roundedTop,
      roundedBottom: o.roundedBottom,
      roundedStart: o.roundedStart,
      roundedEnd: o.roundedEnd
    })), u = toRef(
      () => o.variant !== null && !o.bgColor ? `bg-${o.variant}` : ""
    ), i = toRef(() => o.show ? true : null), d = computed(() => ({
      type: o.spinnerType,
      variant: o.spinnerVariant,
      small: o.spinnerSmall
    })), c = computed(() => ({
      ...n,
      zIndex: o.zIndex || 10
    })), f = computed(() => ({
      "position-absolute": !o.noWrap || !o.fixed,
      "position-fixed": o.noWrap && o.fixed
    })), p = computed(() => [u.value, r.value]), v = computed(() => ({
      ...n,
      opacity: o.opacity,
      backgroundColor: o.bgColor || void 0,
      backdropFilter: o.blur ? `blur(${o.blur})` : void 0
    })), y = computed(
      () => o.noCenter ? n : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (h2, w) => (openBlock(), createBlock(Zt, {
      tag: unref(o).wrapTag,
      class: "b-overlay-wrap position-relative",
      "aria-busy": i.value,
      skip: unref(o).noWrap
    }, {
      default: withCtx(() => [
        renderSlot(h2.$slots, "default"),
        createVNode(Va, {
          "no-fade": unref(o).noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onAfterEnter: w[1] || (w[1] = (m) => a("shown")),
          onAfterLeave: w[2] || (w[2] = (m) => a("hidden"))
        }, {
          default: withCtx(() => [
            unref(o).show ? (openBlock(), createBlock(resolveDynamicComponent(unref(o).overlayTag), {
              key: 0,
              class: normalizeClass(["b-overlay", f.value]),
              style: normalizeStyle(c.value),
              onClick: w[0] || (w[0] = (m) => a("click", m))
            }, {
              default: withCtx(() => [
                createBaseVNode("div", {
                  class: normalizeClass(["position-absolute", p.value]),
                  style: normalizeStyle(v.value)
                }, null, 6),
                createBaseVNode("div", {
                  class: "position-absolute",
                  style: normalizeStyle(y.value)
                }, [
                  renderSlot(h2.$slots, "overlay", normalizeProps(guardReactiveProps(d.value)), () => [
                    unref(o).noSpinner ? createCommentVNode("", true) : (openBlock(), createBlock(Aa, normalizeProps(mergeProps({ key: 0 }, d.value)), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["tag", "aria-busy", "skip"]));
  }
});
var su = ["id", "aria-labelledby", "aria-describedby"];
var ru = ["id"];
var Jo = 1056;
var iu = defineComponent({
  inheritAttrs: false,
  __name: "BModal",
  props: mergeModels({
    autoFocus: { type: Boolean, default: true },
    autoFocusButton: { default: void 0 },
    body: { default: void 0 },
    backdropVariant: { default: void 0 },
    bodyAttrs: { default: void 0 },
    bodyBgVariant: { default: null },
    bodyClass: { default: null },
    bodyScrolling: { type: Boolean, default: false },
    bodyTextVariant: { default: null },
    bodyVariant: { default: null },
    busy: { type: Boolean, default: false },
    buttonSize: { default: "md" },
    cancelDisabled: { type: Boolean, default: false },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { type: Boolean, default: false },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: null },
    footerBorderVariant: { default: null },
    footerClass: { default: void 0 },
    footerTextVariant: { default: null },
    footerVariant: { default: null },
    fullscreen: { type: [Boolean, String], default: false },
    headerBgVariant: { default: null },
    headerBorderVariant: { default: null },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    headerTextVariant: { default: null },
    headerVariant: { default: null },
    hideBackdrop: { type: Boolean, default: false },
    hideFooter: { type: Boolean, default: false },
    hideHeader: { type: Boolean, default: false },
    hideHeaderClose: { type: Boolean, default: false },
    id: { default: void 0 },
    lazy: { type: Boolean, default: false },
    modalClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean, default: false },
    noCloseOnEsc: { type: Boolean, default: false },
    noFade: { type: Boolean, default: false },
    noStacking: { type: Boolean },
    okDisabled: { type: Boolean, default: false },
    okOnly: { type: Boolean, default: false },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { type: Boolean, default: false },
    size: { default: "md" },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { type: Boolean, default: false },
    titleTag: { default: "h5" },
    transProps: { default: void 0 },
    teleportDisabled: { default: false },
    teleportTo: { default: "body" }
  }, {
    modelValue: { type: Boolean, default: false },
    modelModifiers: {}
  }),
  emits: mergeModels(["cancel", "close", "hidden", "hide", "hide-prevented", "ok", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BModal"), n = e, r = useSlots(), u = ke(() => a.id, "modal"), i = useModel(t4, "modelValue"), d = ref(null), c = ref(null), f = ref(null), p = ref(null), v = ref(false), y = ref(false), { activate: h2, deactivate: w } = lu(d);
    watch(v, (pe) => {
      pe ? h2() : w();
    });
    const m = Si(true);
    qe(
      "Escape",
      () => {
        te("esc");
      },
      { target: d }
    ), yn(i, () => a.bodyScrolling);
    const { focused: B } = Re(d, {
      initialValue: i.value && a.autoFocusButton === void 0
    }), { focused: g } = Re(c, {
      initialValue: i.value && a.autoFocusButton === "ok"
    }), { focused: A } = Re(f, {
      initialValue: i.value && a.autoFocusButton === "cancel"
    }), { focused: C } = Re(p, {
      initialValue: i.value && a.autoFocusButton === "close"
    }), V = computed(() => [
      a.modalClass,
      {
        fade: !a.noFade,
        show: v.value
      }
    ]), O = toRef(
      () => a.lazy === false || a.lazy === true && y.value === true || a.lazy === true && i.value === true
    ), Y = toRef(
      () => a.backdropVariant !== void 0 ? a.backdropVariant : a.hideBackdrop ? "transparent" : "dark"
    ), U = toRef(() => !Ne(r["header-close"])), F = computed(() => [
      a.dialogClass,
      {
        "modal-fullscreen": a.fullscreen === true,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string",
        [`modal-${a.size}`]: a.size !== "md",
        "modal-dialog-centered": a.centered,
        "modal-dialog-scrollable": a.scrollable
      }
    ]), j = lt(() => ({
      bgVariant: a.bodyBgVariant,
      textVariant: a.bodyTextVariant,
      variant: a.bodyVariant
    })), $ = computed(() => [a.bodyClass, j.value]), N = lt(() => ({
      bgVariant: a.headerBgVariant,
      textVariant: a.headerTextVariant,
      variant: a.headerVariant
    })), H = computed(() => [
      a.headerClass,
      N.value,
      {
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null
      }
    ]), k = computed(() => ({
      variant: U.value ? a.headerCloseVariant : void 0,
      class: a.headerCloseClass
    })), S = lt(() => ({
      bgVariant: a.footerBgVariant,
      textVariant: a.footerTextVariant,
      variant: a.footerVariant
    })), E = computed(() => [
      a.footerClass,
      S.value,
      {
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null
      }
    ]), M = computed(() => [
      a.titleClass,
      {
        "visually-hidden": a.titleSrOnly
      }
    ]), X = toRef(() => a.cancelDisabled || a.busy), I = toRef(() => a.okDisabled || a.busy), z = (pe, ye = {}) => new Ct(pe, {
      cancelable: false,
      target: d.value || null,
      relatedTarget: null,
      trigger: null,
      ...ye,
      componentId: u.value
    });
    watch(i, (pe, ye) => {
      pe !== ye && (pe === true ? ae() : te());
    });
    const te = (pe = "") => {
      if (pe === "backdrop" && a.noCloseOnBackdrop || pe === "esc" && a.noCloseOnEsc) {
        n("hide-prevented");
        return;
      }
      const ye = z("hide", { cancelable: pe !== "", trigger: pe });
      if (pe === "ok" && n(pe, ye), pe === "cancel" && n(pe, ye), pe === "close" && n(pe, ye), n("hide", ye), ye.defaultPrevented) {
        n("hide-prevented"), i.value || (i.value = true);
        return;
      }
      i.value && (i.value = false);
    }, ae = () => {
      if (v.value)
        return;
      const pe = z("show", { cancelable: true });
      if (n("show", pe), pe.defaultPrevented) {
        i.value && (i.value = false), n("show-prevented");
        return;
      }
      i.value || (i.value = true);
    }, K = () => {
      a.autoFocus !== false && (a.autoFocusButton === "ok" ? g.value = true : a.autoFocusButton === "close" ? C.value = true : a.autoFocusButton === "cancel" ? A.value = true : B.value = true);
    }, ne = () => {
      ae();
    }, re = () => {
      v.value = true, K(), n("shown", z("shown")), a.lazy === true && (y.value = true);
    }, Q = ref(false), fe = () => {
      v.value = false, Q.value = true;
    }, de = () => {
      n("hidden", z("hidden")), a.lazy === true && (y.value = false), Q.value = false;
    }, { activePosition: me, activeModalCount: J, stackWithoutSelf: se } = Ci(
      v,
      i.value
    );
    watch(se, (pe, ye) => {
      pe.length > ye.length && v.value === true && a.noStacking === true && te();
    });
    const Be = computed(() => ({
      // Make sure that newly opened modals have a higher z-index than currently active ones.
      // All active modals have a z-index of ('defaultZIndex' - 'stackSize' - 'positionInStack').
      //
      // This means inactive modals will already be higher than active ones when opened.
      "z-index": v.value || Q.value ? (
        // Just for reference there is a single frame in which the modal is not active but still has a higher z-index than the active ones due to _when_ it calculates its position. It's a small visual effect
        Jo - (((J == null ? void 0 : J.value) ?? 0) - ((me == null ? void 0 : me.value) ?? 0))
      ) : Jo
    }));
    Ve(d, "bv-toggle", () => {
      i.value ? te() : ae();
    });
    const ve = computed(() => ({
      cancel: () => {
        te("cancel");
      },
      close: () => {
        te("close");
      },
      hide: te,
      ok: () => {
        te("ok");
      },
      visible: i.value
    }));
    return l({
      hide: te,
      id: u,
      show: ae
    }), (pe, ye) => (openBlock(), createBlock(Teleport, {
      to: unref(a).teleportTo,
      disabled: unref(a).teleportDisabled
    }, [
      createVNode(Transition, mergeProps({ ...unref(m), ...unref(a).transProps, enterToClass: "show" }, {
        appear: i.value,
        onBeforeEnter: ne,
        onAfterEnter: re,
        onLeave: fe,
        onAfterLeave: de
      }), {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", mergeProps({
            id: unref(u),
            ref_key: "element",
            ref: d,
            class: ["modal", V.value],
            role: "dialog",
            "aria-labelledby": unref(a).hideHeader ? void 0 : `${unref(u)}-label`,
            "aria-describedby": `${unref(u)}-body`,
            tabindex: "-1"
          }, pe.$attrs, { style: Be.value }), [
            createBaseVNode("div", {
              class: normalizeClass(["modal-dialog", F.value])
            }, [
              O.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["modal-content", unref(a).contentClass])
              }, [
                unref(a).hideHeader ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(["modal-header", H.value])
                }, [
                  renderSlot(pe.$slots, "header", normalizeProps(guardReactiveProps(ve.value)), () => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(a).titleTag), {
                      id: `${unref(u)}-label`,
                      class: normalizeClass(["modal-title", M.value])
                    }, {
                      default: withCtx(() => [
                        renderSlot(pe.$slots, "title", normalizeProps(guardReactiveProps(ve.value)), () => [
                          createTextVNode(toDisplayString(unref(a).title), 1)
                        ], true)
                      ]),
                      _: 3
                    }, 8, ["id", "class"])),
                    unref(a).hideHeaderClose ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      U.value ? (openBlock(), createBlock(vt, mergeProps({ key: 0 }, k.value, {
                        onClick: ye[0] || (ye[0] = (Te) => te("close"))
                      }), {
                        default: withCtx(() => [
                          renderSlot(pe.$slots, "header-close", {}, void 0, true)
                        ]),
                        _: 3
                      }, 16)) : (openBlock(), createBlock(zt, mergeProps({
                        key: 1,
                        "aria-label": unref(a).headerCloseLabel
                      }, k.value, {
                        onClick: ye[1] || (ye[1] = (Te) => te("close"))
                      }), null, 16, ["aria-label"]))
                    ], 64))
                  ], true)
                ], 2)),
                createBaseVNode("div", mergeProps({
                  id: `${unref(u)}-body`,
                  class: ["modal-body", $.value]
                }, unref(a).bodyAttrs), [
                  renderSlot(pe.$slots, "default", normalizeProps(guardReactiveProps(ve.value)), () => [
                    createTextVNode(toDisplayString(unref(a).body), 1)
                  ], true)
                ], 16, ru),
                unref(a).hideFooter ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(["modal-footer", E.value])
                }, [
                  renderSlot(pe.$slots, "footer", normalizeProps(guardReactiveProps(ve.value)), () => [
                    renderSlot(pe.$slots, "cancel", normalizeProps(guardReactiveProps(ve.value)), () => [
                      unref(a).okOnly ? createCommentVNode("", true) : (openBlock(), createBlock(vt, {
                        key: 0,
                        ref_key: "cancelButton",
                        ref: f,
                        disabled: X.value,
                        size: unref(a).buttonSize,
                        variant: unref(a).cancelVariant,
                        onClick: ye[2] || (ye[2] = (Te) => te("cancel"))
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(unref(a).cancelTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"]))
                    ], true),
                    renderSlot(pe.$slots, "ok", normalizeProps(guardReactiveProps(ve.value)), () => [
                      createVNode(vt, {
                        ref_key: "okButton",
                        ref: c,
                        disabled: I.value,
                        size: unref(a).buttonSize,
                        variant: unref(a).okVariant,
                        onClick: ye[3] || (ye[3] = (Te) => te("ok"))
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(unref(a).okTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"])
                    ], true)
                  ], true)
                ], 2))
              ], 2)) : createCommentVNode("", true)
            ], 2),
            renderSlot(pe.$slots, "backdrop", {}, () => [
              createVNode(Na, {
                variant: Y.value,
                show: i.value,
                "no-spinner": "",
                fixed: "",
                "no-wrap": "",
                blur: null,
                onClick: ye[4] || (ye[4] = (Te) => te("backdrop"))
              }, null, 8, ["variant", "show"])
            ], true)
          ], 16, su), [
            [vShow, i.value]
          ])
        ]),
        _: 3
      }, 16, ["appear"])
    ], 8, ["to", "disabled"]));
  }
});
var On = (t4, l) => {
  const e = t4.__vccOpts || t4;
  for (const [o, a] of l)
    e[o] = a;
  return e;
};
var Ka = On(iu, [["__scopeId", "data-v-d94bf8bd"]]);
var Pn = {
  install(t4) {
    const l = ref([]), e = () => {
      let i = () => {
      };
      return {
        value: new Promise((c) => {
          i = c;
        }),
        resolve: i
      };
    }, o = () => [e(), Symbol(), ref(true)], a = (i) => {
      const [d, c, f] = o();
      return l.value.push(
        computed({
          get: () => ({
            component: toValue(i.component) ?? Ka,
            props: {
              ...toValue(i.props),
              _isConfirm: false,
              _promise: d,
              _self: c,
              _modelValue: f.value
            }
          }),
          set: (p) => {
            f.value = p.props._modelValue;
          }
        })
      ), d.value;
    }, n = (i) => {
      const [d, c, f] = o();
      return l.value.push(
        computed({
          get: () => ({
            component: toValue(i.component) ?? Ka,
            props: {
              ...toValue(i.props),
              _isConfirm: true,
              _promise: d,
              _self: c,
              _modelValue: f.value
            }
          }),
          set: (p) => {
            f.value = p.props._modelValue;
          }
        })
      ), d.value;
    }, r = (i) => {
      const d = l.value.find((c) => c.value.props._self === i);
      d !== void 0 && (d.value = {
        ...d.value,
        props: {
          ...d.value.props,
          _modelValue: false
        }
      });
    }, u = (i) => {
      l.value = l.value.filter((d) => d.value.props._self !== i);
    };
    t4.provide(en, {
      modals: l,
      remove: u,
      show: a,
      confirm: n,
      leave: r
    });
  }
};
var En = {
  install(t4) {
    const l = ref(/* @__PURE__ */ new Map()), e = computed(() => l.value.size), o = computed(() => [...l.value.values()].pop()), a = (d) => {
      l.value.set(d.uid, d);
    }, n = (d) => {
      l.value.delete(d.uid);
    }, r = ref(/* @__PURE__ */ new Map()), u = (d) => {
      r.value.set(d.uid, d);
    }, i = (d) => {
      r.value.delete(d.uid);
    };
    t4.provide(tn, {
      stack: computed(() => [...l.value.values()]),
      countStack: e,
      lastStack: o,
      registry: computed(() => [...r.value.values()]),
      pushStack: a,
      removeStack: n,
      pushRegistry: u,
      removeRegistry: i
    });
  }
};
var Fn = {
  install(t4, l) {
    var i, d;
    const a = typeof (l == null ? void 0 : l.rtl) == "boolean" ? false : ((i = l == null ? void 0 : l.rtl) == null ? void 0 : i.rtlInitial) ?? false, n = typeof (l == null ? void 0 : l.rtl) == "boolean" ? void 0 : ((d = l == null ? void 0 : l.rtl) == null ? void 0 : d.localeInitial) ?? void 0, r = ref(a), u = ref(n);
    t4.provide(Jl, { isRtl: r, locale: u });
  }
};
var In = {
  install(t4, l) {
    const e = (l == null ? void 0 : l.components) ?? {};
    t4.provide(ra, ref(e));
  }
};
var gf = Object.freeze(Object.defineProperty({
  __proto__: null,
  breadcrumb: kn,
  defaults: In,
  id: Tn,
  modalController: Pn,
  modalManager: En,
  rtl: Fn,
  toast: Cn
}, Symbol.toStringTag, { value: "Module" }));
var uu = ["id"];
var du = defineComponent({
  __name: "BAccordion",
  props: mergeModels({
    flush: { type: Boolean, default: false },
    free: { type: Boolean, default: false },
    id: { default: void 0 },
    modelValue: {}
  }, {
    modelValue: {
      default: void 0
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t4) {
    const e = G(t4, "BAccordion"), o = useModel(t4, "modelValue"), a = ke(() => e.id, "accordion"), n = computed(() => ({
      "accordion-flush": e.flush
    }));
    return provide(Ul, {
      openItem: readonly(o),
      free: toRef(() => e.free),
      setOpenItem: (r) => {
        o.value = r;
      }
    }), (r, u) => (openBlock(), createElementBlock("div", {
      id: unref(a),
      class: normalizeClass(["accordion", n.value])
    }, [
      renderSlot(r.$slots, "default")
    ], 10, uu));
  }
});
var Ln = defineComponent({
  inheritAttrs: false,
  __name: "BCollapse",
  props: mergeModels({
    horizontal: { type: Boolean, default: false },
    id: { default: void 0 },
    isNav: { type: Boolean, default: false },
    modelValue: { type: Boolean },
    skipAnimation: { type: Boolean, default: false },
    tag: { default: "div" },
    toggle: { type: Boolean, default: false },
    visible: { type: Boolean, default: false }
  }, {
    modelValue: { type: Boolean, default: false },
    modelModifiers: {}
  }),
  emits: mergeModels(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BCollapse"), n = e, r = (V, O = {}) => new Ct(V, {
      cancelable: false,
      target: d.value || null,
      relatedTarget: null,
      trigger: null,
      ...O,
      componentId: i.value
    }), u = useModel(t4, "modelValue"), i = ke(() => a.id, "collapse"), d = ref(null), c = ref(false), f = ref(u.value), p = computed(() => ({
      show: f.value,
      "navbar-collapse": a.isNav,
      collapsing: c.value,
      closing: f.value && !u.value,
      "collapse-horizontal": a.horizontal
    })), v = () => {
      u.value = false;
    }, y = () => {
      u.value = true;
    }, h2 = () => {
      u.value = !u.value;
    }, w = computed(() => ({
      toggle: h2,
      show: y,
      hide: v,
      id: i.value,
      visible: u.value
    }));
    let m, B, g = a.skipAnimation;
    const A = () => {
      const V = r("show", { cancelable: true });
      if (n("show", V), V.defaultPrevented) {
        n("show-prevented");
        return;
      }
      clearTimeout(B), clearTimeout(m), f.value = true, !g && (c.value = true, nextTick(() => {
        d.value !== null && (a.horizontal ? d.value.style.width = `${d.value.scrollWidth}px` : d.value.style.height = `${d.value.scrollHeight}px`, m = setTimeout(() => {
          c.value = false, n("shown"), d.value !== null && (d.value.style.height = "", d.value.style.width = "");
        }, Ma(d.value)));
      }));
    }, C = () => {
      const V = r("hide", { cancelable: true });
      if (n("hide", V), V.defaultPrevented) {
        n("hide-prevented");
        return;
      }
      if (clearTimeout(m), clearTimeout(B), d.value !== null) {
        if (g) {
          f.value = false;
          return;
        }
        c.value ? (d.value.style.height = "", d.value.style.width = "") : a.horizontal ? d.value.style.width = `${d.value.scrollWidth}px` : d.value.style.height = `${d.value.scrollHeight}px`, d.value.offsetHeight, c.value = true, nextTick(() => {
          d.value !== null && (d.value.style.height = "", d.value.style.width = "", B = setTimeout(() => {
            f.value = false, c.value = false, n("hidden");
          }, Ma(d.value)));
        });
      }
    };
    return watch(u, () => {
      u.value ? A() : C();
    }), onMounted(() => {
      d.value !== null && !u.value && a.toggle && nextTick(() => {
        u.value = true;
      });
    }), watch(
      () => a.skipAnimation,
      (V) => {
        g = V;
      }
    ), a.visible && (g = true, u.value = true, nextTick(() => {
      g = a.skipAnimation;
    })), watch(
      () => a.visible,
      (V) => {
        g = true, V ? y() : v(), nextTick(() => {
          g = a.skipAnimation;
        });
      }
    ), Ve(d, "bv-toggle", () => {
      u.value = !u.value;
    }), l({
      hide: v,
      isNav: a.isNav,
      show: y,
      toggle: h2,
      visible: readonly(f)
    }), provide(ho, {
      id: i,
      hide: v,
      show: y,
      toggle: h2,
      visible: readonly(f),
      isNav: toRef(() => a.isNav)
    }), (V, O) => (openBlock(), createElementBlock(Fragment, null, [
      renderSlot(V.$slots, "header", normalizeProps(guardReactiveProps(w.value))),
      (openBlock(), createBlock(resolveDynamicComponent(unref(a).tag), mergeProps({
        id: unref(i),
        ref_key: "element",
        ref: d,
        class: ["collapse", p.value],
        "is-nav": unref(a).isNav
      }, V.$attrs), {
        default: withCtx(() => [
          renderSlot(V.$slots, "default", normalizeProps(guardReactiveProps(w.value)))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      renderSlot(V.$slots, "footer", normalizeProps(guardReactiveProps(w.value)))
    ], 64));
  }
});
var cu = ["aria-expanded", "aria-controls", "onClick"];
var fu = defineComponent({
  inheritAttrs: false,
  __name: "BAccordionItem",
  props: mergeModels({
    bodyAttrs: { default: void 0 },
    bodyClass: { default: void 0 },
    buttonAttrs: { default: void 0 },
    buttonClass: { default: void 0 },
    collapseClass: { default: void 0 },
    headerAttrs: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "h2" },
    horizontal: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: void 0 },
    modelValue: { type: Boolean },
    tag: { default: void 0 },
    title: { default: void 0 },
    toggle: { type: Boolean, default: void 0 },
    visible: { type: Boolean, default: false },
    wrapperAttrs: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: false },
    modelModifiers: {}
  }),
  emits: mergeModels(["hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t4, { emit: l }) {
    const { class: e, ...o } = useAttrs(), n = G(t4, "BAccordionItem"), r = l, u = useModel(t4, "modelValue"), i = inject(Ul, null), d = ke(() => n.id, "accordion_item");
    return onMounted(() => {
      u.value && !(i != null && i.free.value) && (i == null || i.setOpenItem(d.value)), !u.value && (i == null ? void 0 : i.openItem.value) === d.value && (u.value = true);
    }), watch(
      () => i == null ? void 0 : i.openItem.value,
      () => u.value = (i == null ? void 0 : i.openItem.value) === d.value && !(i != null && i.free.value)
    ), watch(u, () => {
      u.value && !(i != null && i.free.value) && (i == null || i.setOpenItem(d.value));
    }), (c, f) => (openBlock(), createElementBlock("div", mergeProps({ class: "accordion-item" }, unref(n).wrapperAttrs, { class: unref(e) }), [
      createVNode(Ln, mergeProps({
        id: unref(d),
        modelValue: u.value,
        "onUpdate:modelValue": f[0] || (f[0] = (p) => u.value = p),
        class: ["accordion-collapse", unref(n).collapseClass],
        "aria-labelledby": `${unref(d)}-heading`
      }, o, {
        tag: unref(n).tag,
        toggle: unref(n).toggle,
        horizontal: unref(n).horizontal,
        visible: unref(n).visible,
        "is-nav": unref(n).isNav,
        onShow: f[1] || (f[1] = (p) => r("show", p)),
        onShown: f[2] || (f[2] = (p) => r("shown")),
        onHide: f[3] || (f[3] = (p) => r("hide", p)),
        onHidden: f[4] || (f[4] = (p) => r("hidden")),
        onHidePrevented: f[5] || (f[5] = (p) => r("hide-prevented")),
        onShowPrevented: f[6] || (f[6] = (p) => r("show-prevented"))
      }), {
        header: withCtx(({ visible: p, toggle: v }) => [
          (openBlock(), createBlock(resolveDynamicComponent(unref(n).headerTag), mergeProps({
            id: `${unref(d)}-heading`,
            class: ["accordion-header", unref(n).headerClass]
          }, unref(n).headerAttrs), {
            default: withCtx(() => [
              createBaseVNode("button", mergeProps({ class: "accordion-button" }, unref(n).buttonAttrs, {
                class: [{ collapsed: !p }, unref(n).buttonClass],
                type: "button",
                "aria-expanded": p ? "true" : "false",
                "aria-controls": unref(d),
                onClick: v
              }), [
                renderSlot(c.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString(unref(n).title), 1)
                ])
              ], 16, cu)
            ]),
            _: 2
          }, 1040, ["id", "class"]))
        ]),
        default: withCtx(() => [
          createBaseVNode("div", mergeProps({ class: "accordion-body" }, unref(n).bodyAttrs, {
            class: unref(n).bodyClass
          }), [
            renderSlot(c.$slots, "default")
          ], 16)
        ]),
        _: 3
      }, 16, ["id", "modelValue", "class", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ], 16));
  }
});
var vu = defineComponent({
  __name: "BAlert",
  props: mergeModels({
    closeClass: { default: void 0 },
    closeContent: { default: void 0 },
    closeLabel: { default: "Close" },
    closeVariant: { default: "secondary" },
    dismissible: { type: Boolean, default: false },
    fade: { type: Boolean, default: false },
    immediate: { type: Boolean, default: true },
    interval: { default: 1e3 },
    modelValue: { type: [Boolean, Number] },
    noHoverPause: { type: Boolean, default: false },
    showOnPause: { type: Boolean, default: true },
    variant: { default: "info" }
  }, {
    modelValue: { type: [Boolean, Number], default: false },
    modelModifiers: {}
  }),
  emits: mergeModels(["close", "close-countdown", "closed"], ["update:modelValue"]),
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BAlert"), n = e, r = useSlots(), u = ref(null), i = useModel(t4, "modelValue"), d = yo(u), c = _e(() => a.interval), f = toRef(() => !Ne(r.close)), p = toRef(() => typeof i.value == "boolean" ? 0 : i.value), v = computed(() => ({
      [`alert-${a.variant}`]: a.variant !== null,
      "alert-dismissible": a.dismissible
    })), y = computed(() => [a.closeClass, { "btn-close-custom": f.value }]), {
      isActive: h2,
      pause: w,
      restart: m,
      resume: B,
      stop: g,
      isPaused: A,
      value: C
    } = nn(p, c, {
      immediate: typeof i.value == "number" && a.immediate
    }), V = toRef(
      () => typeof i.value == "boolean" ? i.value : h2.value || a.showOnPause && A.value
    ), O = computed(() => ({
      variant: f.value ? a.closeVariant : void 0,
      class: y.value
    }));
    watchEffect(() => {
      n("close-countdown", C.value);
    });
    const Y = () => {
      n("close"), typeof i.value == "boolean" ? i.value = false : (i.value = 0, g()), n("closed");
    }, U = () => {
      a.noHoverPause || w();
    };
    return watch(d, (F) => {
      if (F) {
        U();
        return;
      }
      B();
    }), onBeforeUnmount(g), l({
      pause: w,
      restart: m,
      resume: B,
      stop: g
    }), (F, j) => (openBlock(), createBlock(Va, {
      "no-fade": !unref(a).fade,
      "trans-props": { enterToClass: "show" }
    }, {
      default: withCtx(() => [
        V.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref_key: "element",
          ref: u,
          class: normalizeClass(["alert", v.value]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true"
        }, [
          renderSlot(F.$slots, "default", {}, void 0, true),
          unref(a).dismissible ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            f.value || unref(a).closeContent ? (openBlock(), createBlock(vt, mergeProps({ key: 0 }, O.value, { onClick: Y }), {
              default: withCtx(() => [
                renderSlot(F.$slots, "close", {}, () => [
                  createTextVNode(toDisplayString(unref(a).closeContent), 1)
                ], true)
              ]),
              _: 3
            }, 16)) : (openBlock(), createBlock(zt, mergeProps({
              key: 1,
              "aria-label": unref(a).closeLabel
            }, O.value, { onClick: Y }), null, 16, ["aria-label"]))
          ], 64)) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
});
var pu = On(vu, [["__scopeId", "data-v-96a91b13"]]);
var Rn = defineComponent({
  __name: "BBadge",
  props: {
    dotIndicator: { type: Boolean, default: false },
    pill: { type: Boolean, default: false },
    tag: { default: "span" },
    textIndicator: { type: Boolean },
    placement: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: false },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BBadge"), o = lt(e), { computedLink: a, computedLinkProps: n } = Tt(e, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), r = toRef(() => a.value ? it : e.tag), u = computed(() => {
      const d = e.placement ?? (e.dotIndicator ? "top-end" : void 0);
      return [
        "position-absolute",
        "translate-middle",
        {
          "start-0 top-0": d === "top-start",
          "start-0 top-50": d === "start",
          "start-0 top-100": d === "bottom-start",
          "start-50 top-0": d === "top",
          "start-50 top-100": d === "bottom",
          "start-100 top-0": d === "top-end",
          "start-100 top-50": d === "end",
          "start-100 top-100": d === "bottom-end"
        }
      ];
    }), i = computed(() => [
      o.value,
      e.placement !== void 0 || e.dotIndicator === true ? u.value : void 0,
      {
        active: e.active,
        disabled: e.disabled,
        "rounded-pill": e.pill,
        "p-2 border border-light rounded-circle": e.dotIndicator,
        "text-decoration-none": a.value
      }
    ]);
    return (d, c) => (openBlock(), createBlock(resolveDynamicComponent(r.value), mergeProps({
      class: ["badge", i.value]
    }, unref(n)), {
      default: withCtx(() => [
        createVNode(Zt, mergeProps({
          skip: unref(e).dotIndicator !== true,
          tag: "span"
        }, unref(e).dotIndicator ? { class: "visually-hidden" } : {}), {
          default: withCtx(() => [
            renderSlot(d.$slots, "default")
          ]),
          _: 3
        }, 16, ["skip"])
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var mu = {
  key: 0,
  class: "b-avatar-custom"
};
var bu = {
  key: 1,
  class: "b-avatar-img"
};
var yu = ["src", "alt"];
var Qo = 0.4;
var gu = defineComponent({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    badge: { type: [Boolean, String], default: false },
    badgeBgVariant: { default: null },
    badgePlacement: { default: "top-end" },
    badgeTextVariant: { default: null },
    badgeVariant: { default: "primary" },
    badgePill: { type: Boolean, default: false },
    badgeDotIndicator: { type: Boolean, default: false },
    button: { type: Boolean, default: false },
    buttonType: { default: "button" },
    size: { default: void 0 },
    square: { type: Boolean, default: false },
    src: { default: void 0 },
    text: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    stretched: { type: Boolean, default: false },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: "secondary" },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [Boolean, String, Number], default: false },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  emits: ["click", "img-error"],
  setup(t4, { emit: l }) {
    const e = t4, o = l, a = useSlots(), { computedLink: n, computedLinkProps: r } = Tt(e), u = inject(Gl, null), i = ["sm", null, "lg"], d = Qo * 0.7, c = toRef(() => !Ne(a.default)), f = toRef(() => !Ne(a.badge)), p = toRef(() => !!e.badge || e.badge === "" || f.value), v = toRef(() => (u == null ? void 0 : u.square.value) || e.square), y = Ba(() => e.size), h2 = Ba(() => u == null ? void 0 : u.size.value), w = computed(() => h2.value ?? y.value), m = toRef(() => (u == null ? void 0 : u.variant.value) ?? e.variant), B = toRef(() => (u == null ? void 0 : u.rounded.value) ?? e.rounded), g = toRef(() => (u == null ? void 0 : u.roundedTop.value) ?? e.roundedTop), A = toRef(() => (u == null ? void 0 : u.roundedBottom.value) ?? e.roundedBottom), C = toRef(() => (u == null ? void 0 : u.roundedStart.value) ?? e.roundedStart), V = toRef(() => (u == null ? void 0 : u.roundedEnd.value) ?? e.roundedEnd), O = Co(() => ({
      rounded: B.value,
      roundedTop: g.value,
      roundedBottom: A.value,
      roundedStart: C.value,
      roundedEnd: V.value
    })), Y = toRef(() => e.badge === true ? "" : e.badge), U = computed(() => !Y.value && !f.value), F = toRef(() => (u == null ? void 0 : u.textVariant.value) ?? e.textVariant), j = toRef(() => (u == null ? void 0 : u.bgVariant.value) ?? e.bgVariant), $ = lt(() => ({
      bgVariant: j.value,
      textVariant: F.value,
      variant: m.value
    })), N = computed(() => [
      $.value,
      // Square overwrites all else
      v.value === true ? void 0 : O.value,
      {
        [`b-avatar-${e.size}`]: !!e.size && i.indexOf(y.value) !== -1,
        [`btn-${m.value}`]: e.button ? m.value !== null : false,
        badge: !e.button && m.value !== null && c.value,
        btn: e.button,
        // Square is the same as rounded-0 class
        "rounded-0": v.value === true
      }
    ]), H = computed(() => ({
      fontSize: i.indexOf(w.value || null) === -1 ? `calc(${w.value} * ${d})` : ""
    })), k = computed(() => {
      const z = i.indexOf(w.value || null) === -1 ? `calc(${w.value} * ${Qo})` : null;
      return z ? { fontSize: z } : {};
    }), S = computed(() => {
      var ae;
      const z = ((ae = u == null ? void 0 : u.overlapScale) == null ? void 0 : ae.value) || 0, te = w.value && z ? `calc(${w.value} * -${z})` : null;
      return te ? { marginLeft: te, marginRight: te } : {};
    }), E = toRef(() => n.value ? it : e.button ? "button" : "span"), M = computed(() => ({
      ...S.value,
      width: w.value ?? void 0,
      height: w.value ?? void 0
    })), X = (z) => {
      !e.disabled && (n.value || e.button) && o("click", z);
    }, I = (z) => {
      o("img-error", z);
    };
    return (z, te) => (openBlock(), createBlock(resolveDynamicComponent(E.value), mergeProps({
      class: ["b-avatar", N.value],
      style: M.value
    }, unref(r), {
      type: e.button && !unref(n) ? e.buttonType : void 0,
      disabled: e.disabled || null,
      onClick: X
    }), {
      default: withCtx(() => [
        c.value ? (openBlock(), createElementBlock("span", mu, [
          renderSlot(z.$slots, "default")
        ])) : e.src ? (openBlock(), createElementBlock("span", bu, [
          createBaseVNode("img", {
            src: e.src,
            alt: e.alt,
            onError: I
          }, null, 40, yu)
        ])) : e.text ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: "b-avatar-text",
          style: normalizeStyle(k.value)
        }, toDisplayString(e.text), 5)) : createCommentVNode("", true),
        p.value ? (openBlock(), createBlock(Rn, {
          key: 3,
          pill: e.badgePill,
          "dot-indicator": e.badgeDotIndicator || U.value,
          variant: e.badgeVariant,
          "bg-variant": e.badgeBgVariant,
          "text-variant": e.badgeTextVariant,
          style: normalizeStyle(H.value),
          placement: e.badgePlacement
        }, {
          default: withCtx(() => [
            renderSlot(z.$slots, "badge", {}, () => [
              createTextVNode(toDisplayString(Y.value), 1)
            ])
          ]),
          _: 3
        }, 8, ["pill", "dot-indicator", "variant", "bg-variant", "text-variant", "style", "placement"])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16, ["class", "style", "type", "disabled"]));
  }
});
var hu = defineComponent({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    size: { default: void 0 },
    square: { type: Boolean, default: false },
    tag: { default: "div" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null },
    rounded: { type: [Boolean, String, Number], default: false },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BAvatarGroup"), o = _e(() => e.overlap), a = Ba(() => e.size), n = toRef(() => Math.min(Math.max(o.value, 0), 1) / 2), r = computed(() => {
      const u = a.value ? `calc(${a.value} * ${n.value})` : null;
      return u ? { paddingLeft: u, paddingRight: u } : {};
    });
    return provide(Gl, {
      overlapScale: n,
      size: toRef(() => e.size),
      square: toRef(() => e.square),
      rounded: toRef(() => e.rounded),
      roundedTop: toRef(() => e.roundedTop),
      roundedBottom: toRef(() => e.roundedBottom),
      roundedStart: toRef(() => e.roundedStart),
      roundedEnd: toRef(() => e.roundedEnd),
      variant: toRef(() => e.variant),
      bgVariant: toRef(() => e.bgVariant),
      textVariant: toRef(() => e.textVariant)
    }), (u, i) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: withCtx(() => [
        createBaseVNode("div", {
          class: "b-avatar-group-inner",
          style: normalizeStyle(r.value)
        }, [
          renderSlot(u.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
});
var zn = defineComponent({
  __name: "BBreadcrumbItem",
  props: {
    ariaCurrent: { default: "location" },
    text: { default: void 0 },
    active: { type: Boolean, default: false },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: false },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  emits: ["click"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BBreadcrumbItem"), a = l, n = computed(() => ({
      active: o.active
    })), r = toRef(() => o.active ? "span" : it), u = toRef(() => o.active ? o.ariaCurrent : void 0), i = computed(
      () => r.value !== "span" ? _o(o, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "icon"
      ]) : {}
    ), d = (c) => {
      if (o.disabled || o.active) {
        c.preventDefault(), c.stopImmediatePropagation();
        return;
      }
      o.disabled || a("click", c);
    };
    return (c, f) => (openBlock(), createElementBlock("li", {
      class: normalizeClass(["breadcrumb-item", n.value])
    }, [
      (openBlock(), createBlock(resolveDynamicComponent(r.value), mergeProps({ "aria-current": u.value }, i.value, { onClick: d }), {
        default: withCtx(() => [
          renderSlot(c.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(unref(o).text), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-current"]))
    ], 2));
  }
});
var Bu = { "aria-label": "breadcrumb" };
var _u = { class: "breadcrumb" };
var wu = defineComponent({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BBreadcrumb"), o = ln(), a = computed(() => {
      var i;
      const n = e.items || ((i = o.items) == null ? void 0 : i.value) || [];
      let r = false;
      return n.map((d, c) => (typeof d == "string" && (d = { text: d }, c < n.length - 1 && (d.href = "#")), d.active && (r = true), !d.active && !r && (d.active = c + 1 === n.length), d));
    });
    return (n, r) => (openBlock(), createElementBlock("nav", Bu, [
      createBaseVNode("ol", _u, [
        renderSlot(n.$slots, "prepend"),
        (openBlock(true), createElementBlock(Fragment, null, renderList(a.value, (u, i) => (openBlock(), createBlock(zn, mergeProps({
          key: i,
          ref_for: true
        }, u), {
          default: withCtx(() => [
            createTextVNode(toDisplayString(u.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        renderSlot(n.$slots, "default"),
        renderSlot(n.$slots, "append")
      ])
    ]));
  }
});
var Cu = defineComponent({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { type: Boolean, default: false }
  },
  setup(t4) {
    const e = G(t4, "BButtonGroup"), o = computed(() => ({
      "btn-group": !e.vertical,
      [`btn-group-${e.size}`]: e.size !== "md",
      "btn-group-vertical": e.vertical
    }));
    return (a, n) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(o.value),
      role: "group",
      "aria-label": unref(e).ariaLabel
    }, {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
});
var ku = ["role", "aria-label"];
var Tu = defineComponent({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { type: Boolean, default: false },
    role: { default: "toolbar" }
  },
  setup(t4) {
    const e = G(t4, "BButtonToolbar"), o = computed(() => ({
      "justify-content-between": e.justify
    }));
    return (a, n) => (openBlock(), createElementBlock("div", {
      class: normalizeClass([o.value, "btn-toolbar"]),
      role: unref(e).role,
      "aria-label": unref(e).ariaLabel
    }, [
      renderSlot(a.$slots, "default")
    ], 10, ku));
  }
});
var ko = defineComponent({
  __name: "BImg",
  props: {
    blank: { type: Boolean, default: false },
    blankColor: { default: "transparent" },
    block: { type: Boolean, default: false },
    fluid: { type: Boolean, default: false },
    fluidGrow: { type: Boolean, default: false },
    height: { default: void 0 },
    tag: { default: "img" },
    lazy: { type: Boolean, default: false },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { type: Boolean, default: false },
    width: { default: void 0 },
    placement: { default: void 0 },
    rounded: { type: [Boolean, String, Number], default: false },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BImg"), o = _e(() => e.height ?? NaN), a = _e(() => e.width ?? NaN), n = Co(() => ({
      rounded: e.rounded,
      roundedTop: e.roundedTop,
      roundedBottom: e.roundedBottom,
      roundedStart: e.roundedStart,
      roundedEnd: e.roundedEnd
    })), r = computed(
      () => typeof e.srcset == "string" ? e.srcset.split(",").filter((v) => v).join(",") : Array.isArray(e.srcset) ? e.srcset.filter((v) => v).join(",") : void 0
    ), u = computed(
      () => typeof e.sizes == "string" ? e.sizes.split(",").filter((v) => v).join(",") : Array.isArray(e.sizes) ? e.sizes.filter((v) => v).join(",") : void 0
    ), i = computed(() => {
      const v = Number.isNaN(a.value) ? void 0 : a.value, y = Number.isNaN(o.value) ? void 0 : o.value;
      if (e.blank) {
        if (v !== void 0 && y === void 0)
          return { height: v, width: v };
        if (v === void 0 && y !== void 0)
          return { height: y, width: y };
        if (v === void 0 && y === void 0)
          return { height: 1, width: 1 };
      }
      return {
        width: v,
        height: y
      };
    }), d = toRef(
      () => p(i.value.width, i.value.height, e.blankColor)
    ), c = computed(() => ({
      "float-start": e.placement === "start",
      "float-end": e.placement === "end",
      "mx-auto": e.placement === "center"
    })), f = computed(() => [
      n.value,
      c.value,
      {
        "img-thumbnail": e.thumbnail,
        "img-fluid": e.fluid || e.fluidGrow,
        "w-100": e.fluidGrow,
        "d-block": e.block || e.placement === "center"
      }
    ]), p = (v, y, h2) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg width="${v}" height="${y}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${v} ${y}" preserveAspectRatio="none">
    <rect width="100%" height="100%" style="fill:${h2};"></rect>
    </svg>`)}`;
    return (v, y) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(f.value),
      src: unref(e).blank ? d.value : unref(e).src,
      width: i.value.width || void 0,
      height: i.value.height || void 0,
      srcset: unref(e).blank ? void 0 : r.value,
      sizes: unref(e).blank ? void 0 : u.value,
      loading: unref(e).lazy ? "lazy" : "eager"
    }, null, 8, ["class", "src", "width", "height", "srcset", "sizes", "loading"]));
  }
});
var To = defineComponent({
  __name: "BCardImg",
  props: {
    placement: { default: "top" },
    blank: { type: Boolean, default: void 0 },
    blankColor: { default: void 0 },
    block: { type: Boolean, default: void 0 },
    fluid: { type: Boolean, default: void 0 },
    fluidGrow: { type: Boolean, default: void 0 },
    height: { default: void 0 },
    tag: {},
    lazy: { type: Boolean, default: void 0 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { type: Boolean, default: void 0 },
    width: { default: void 0 },
    rounded: { type: [Boolean, String, Number], default: void 0 },
    roundedTop: { type: [Boolean, String, Number], default: void 0 },
    roundedBottom: { type: [Boolean, String, Number], default: void 0 },
    roundedStart: { type: [Boolean, String, Number], default: void 0 },
    roundedEnd: { type: [Boolean, String, Number], default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BCardImg"), o = computed(() => ({
      "card-img-top": e.placement === "top",
      // TODO implement this class
      "card-img-end": e.placement === "end",
      "card-img-bottom": e.placement === "bottom",
      // TODO implement this class
      "card-img-start": e.placement === "start",
      "card-img": e.placement === "overlay"
    })), a = computed(() => $a(e, ["placement"]));
    return (n, r) => (openBlock(), createBlock(ko, mergeProps(a.value, { class: o.value }), null, 16, ["class"]));
  }
});
var Su = ["innerHTML"];
var Mn = defineComponent({
  __name: "BCardHeadFoot",
  props: {
    borderVariant: { default: null },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t4) {
    const l = t4, e = lt(l), o = computed(() => [
      e.value,
      {
        [`border-${l.borderVariant}`]: l.borderVariant !== null
      }
    ]);
    return (a, n) => (openBlock(), createBlock(resolveDynamicComponent(a.tag), {
      class: normalizeClass(o.value)
    }, {
      default: withCtx(() => [
        a.html ? (openBlock(), createElementBlock("div", {
          key: 0,
          innerHTML: a.html
        }, null, 8, Su)) : renderSlot(a.$slots, "default", { key: 1 }, () => [
          createTextVNode(toDisplayString(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Hn = defineComponent({
  __name: "BCardHeader",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BCardHeader");
    return (o, a) => (openBlock(), createBlock(Mn, mergeProps({ class: "card-header" }, unref(e)), {
      default: withCtx(() => [
        renderSlot(o.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var Dn = defineComponent({
  __name: "BCardTitle",
  props: {
    tag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BCardTitle");
    return (o, a) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), { class: "card-title" }, {
      default: withCtx(() => [
        renderSlot(o.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(unref(e).text), 1)
        ])
      ]),
      _: 3
    }));
  }
});
var jn = defineComponent({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "body-secondary" }
  },
  setup(t4) {
    const e = G(t4, "BCardSubtitle"), o = computed(() => ({
      [`text-${e.textVariant}`]: e.textVariant !== null
    }));
    return (a, n) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(["card-subtitle mb-2", o.value])
    }, {
      default: withCtx(() => [
        renderSlot(a.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(unref(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var qn = defineComponent({
  __name: "BCardBody",
  props: {
    overlay: { type: Boolean, default: false },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BCardBody"), o = useSlots(), a = lt(e), n = toRef(() => !Ne(o.title)), r = toRef(() => !Ne(o.subtitle)), u = computed(() => [
      a.value,
      e.overlay ? "card-img-overlay" : "card-body"
    ]);
    return (i, d) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(u.value)
    }, {
      default: withCtx(() => [
        unref(e).title || n.value ? (openBlock(), createBlock(Dn, {
          key: 0,
          tag: unref(e).titleTag
        }, {
          default: withCtx(() => [
            renderSlot(i.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(unref(e).title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : createCommentVNode("", true),
        unref(e).subtitle || r.value ? (openBlock(), createBlock(jn, {
          key: 1,
          tag: unref(e).subtitleTag,
          "text-variant": unref(e).subtitleTextVariant
        }, {
          default: withCtx(() => [
            renderSlot(i.$slots, "subtitle", {}, () => [
              createTextVNode(toDisplayString(unref(e).subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : createCommentVNode("", true),
        renderSlot(i.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(unref(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Wn = defineComponent({
  __name: "BCardFooter",
  props: {
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    text: { default: void 0 },
    variant: { default: void 0 },
    bgVariant: { default: void 0 },
    textVariant: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BCardFooter");
    return (o, a) => (openBlock(), createBlock(Mn, mergeProps({ class: "card-footer" }, unref(e)), {
      default: withCtx(() => [
        renderSlot(o.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(unref(e).text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
});
var Gn = defineComponent({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyText: { default: "" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: null },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    footerVariant: { default: null },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    headerVariant: { default: null },
    imgAlt: { default: void 0 },
    imgPlacement: { default: "top" },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgWidth: { default: void 0 },
    noBody: { type: Boolean, default: false },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "body-secondary" },
    tag: { default: "div" },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    variant: { default: null },
    bgVariant: { default: null },
    textVariant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BCard"), o = useSlots(), a = toRef(() => !Ne(o.header)), n = toRef(() => !Ne(o.footer)), r = lt(e), u = computed(() => [
      r.value,
      {
        [`text-${e.align}`]: e.align !== void 0,
        [`border-${e.borderVariant}`]: e.borderVariant !== null,
        "flex-row": e.imgPlacement === "start",
        "flex-row-reverse": e.imgPlacement === "end"
      }
    ]), i = computed(() => ({
      src: e.imgSrc,
      alt: e.imgAlt,
      height: e.imgHeight,
      width: e.imgWidth,
      placement: e.imgPlacement
    })), d = pa();
    return (c, f) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(["card", u.value])
    }, {
      default: withCtx(() => [
        createVNode(unref(d).define, null, {
          default: withCtx(() => [
            renderSlot(c.$slots, "img", {}, () => [
              unref(e).imgSrc ? (openBlock(), createBlock(To, normalizeProps(mergeProps({ key: 0 }, i.value)), null, 16)) : createCommentVNode("", true)
            ])
          ]),
          _: 3
        }),
        unref(e).imgPlacement !== "bottom" ? (openBlock(), createBlock(unref(d).reuse, { key: 0 })) : createCommentVNode("", true),
        unref(e).header || a.value || unref(e).headerHtml ? (openBlock(), createBlock(Hn, {
          key: 1,
          "bg-variant": unref(e).headerBgVariant,
          variant: unref(e).headerVariant,
          "border-variant": unref(e).headerBorderVariant,
          html: unref(e).headerHtml,
          tag: unref(e).headerTag,
          "text-variant": unref(e).headerTextVariant,
          class: normalizeClass(unref(e).headerClass)
        }, {
          default: withCtx(() => [
            renderSlot(c.$slots, "header", {}, () => [
              createTextVNode(toDisplayString(unref(e).header), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "variant", "border-variant", "html", "tag", "text-variant", "class"])) : createCommentVNode("", true),
        unref(e).noBody ? renderSlot(c.$slots, "default", { key: 3 }, () => [
          createTextVNode(toDisplayString(unref(e).bodyText), 1)
        ]) : (openBlock(), createBlock(qn, {
          key: 2,
          overlay: unref(e).imgPlacement === "overlay",
          "bg-variant": unref(e).bodyBgVariant,
          tag: unref(e).bodyTag,
          "text-variant": unref(e).bodyTextVariant,
          subtitle: unref(e).subtitle,
          "subtitle-tag": unref(e).subtitleTag,
          "subtitle-text-variant": unref(e).subtitleTextVariant,
          title: unref(e).title,
          "title-tag": unref(e).titleTag,
          class: normalizeClass(unref(e).bodyClass)
        }, {
          default: withCtx(() => [
            renderSlot(c.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(unref(e).bodyText), 1)
            ])
          ]),
          _: 3
        }, 8, ["overlay", "bg-variant", "tag", "text-variant", "subtitle", "subtitle-tag", "subtitle-text-variant", "title", "title-tag", "class"])),
        unref(e).footer || n.value || unref(e).footerHtml ? (openBlock(), createBlock(Wn, {
          key: 4,
          "bg-variant": unref(e).footerBgVariant,
          "border-variant": unref(e).footerBorderVariant,
          variant: unref(e).footerVariant,
          html: unref(e).footerHtml,
          tag: unref(e).footerTag,
          "text-variant": unref(e).footerTextVariant,
          class: normalizeClass(unref(e).footerClass)
        }, {
          default: withCtx(() => [
            renderSlot(c.$slots, "footer", {}, () => [
              createTextVNode(toDisplayString(unref(e).footer), 1)
            ])
          ]),
          _: 3
        }, 8, ["bg-variant", "border-variant", "variant", "html", "tag", "text-variant", "class"])) : createCommentVNode("", true),
        unref(e).imgPlacement === "bottom" ? (openBlock(), createBlock(unref(d).reuse, { key: 5 })) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var xu = defineComponent({
  __name: "BCardGroup",
  props: {
    columns: { type: Boolean, default: false },
    deck: { type: Boolean, default: false },
    tag: { default: "div" }
  },
  setup(t4) {
    const e = G(t4, "BCardGroup"), o = toRef(
      () => e.deck ? "card-deck" : e.columns ? "card-columns" : "card-group"
    );
    return (a, n) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(o.value)
    }, {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var $u = defineComponent({
  __name: "BCardText",
  props: {
    tag: { default: "p" },
    text: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BCardText");
    return (o, a) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), { class: "card-text" }, {
      default: withCtx(() => [
        renderSlot(o.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(unref(e).text), 1)
        ])
      ]),
      _: 3
    }));
  }
});
var Vu = ["id"];
var Au = {
  key: 0,
  class: "carousel-indicators"
};
var Nu = ["aria-current", "aria-label", "onClick"];
var Ou = createBaseVNode("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1);
var Pu = { class: "visually-hidden" };
var Eu = createBaseVNode("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1);
var Fu = { class: "visually-hidden" };
var Iu = defineComponent({
  __name: "BCarousel",
  props: mergeModels({
    background: { default: void 0 },
    controls: { type: Boolean, default: false },
    controlsNextText: { default: "Next" },
    controlsPrevText: { default: "Previous" },
    fade: { type: Boolean, default: false },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    indicators: { type: Boolean, default: false },
    indicatorsButtonLabel: { default: "Slide" },
    interval: { default: 5e3 },
    keyboard: { type: Boolean, default: true },
    modelValue: {},
    noHoverPause: { type: Boolean, default: false },
    noTouch: { type: Boolean, default: false },
    noWrap: { type: Boolean, default: false },
    ride: { type: [Boolean, String], default: false },
    rideReverse: { type: Boolean, default: false },
    touchThreshold: { default: 50 }
  }, {
    modelValue: { default: 0 },
    modelModifiers: {}
  }),
  emits: mergeModels(["slide", "slid"], ["update:modelValue"]),
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BCarousel"), n = e, r = useSlots(), u = ke(() => a.id, "carousel"), i = useModel(t4, "modelValue"), d = ref(null), c = _e(() => a.touchThreshold), f = ref(null);
    onMounted(() => {
      var ae, K;
      f.value = ((K = (ae = d.value) == null ? void 0 : ae.find((ne) => ne.$el.style.display !== "none")) == null ? void 0 : K.$props.interval) ?? null;
    });
    const p = _e(() => f.value ?? a.interval), v = ref(false), y = ref(false), h2 = ref(true), w = ref(null), m = ref(null), B = ref(i.value), g = yo(m), A = toRef(
      () => `carousel-item carousel-item-${h2.value ? "prev" : "next"} carousel-item-${h2.value ? "end" : "start"}`
    ), C = toRef(
      () => `carousel-item active carousel-item-${h2.value ? "start" : "end"}`
    ), { pause: V, resume: O } = Ll(
      () => {
        a.rideReverse ? N() : H();
      },
      p,
      { immediate: a.ride === "carousel" }
    ), Y = toRef(
      () => a.ride === true && y.value === true || a.ride === "carousel"
    ), U = computed(() => ai(r.default, "BCarouselSlide")), F = computed(() => ({ "carousel-fade": a.fade })), j = (ae) => {
      var K;
      return new pl(ae, {
        componentId: u.value,
        cancelable: false,
        target: m.value,
        direction: h2.value ? "right" : "left",
        from: B.value,
        to: i.value,
        relatedTarget: ((K = w.value) == null ? void 0 : K.children[i.value]) ?? null
      });
    }, $ = (ae) => {
      if (v.value !== true) {
        if (a.ride === true && (y.value = true), Y.value === true && O(), h2.value = !(ae < i.value), ae >= U.value.length) {
          if (a.noWrap)
            return;
          i.value = 0;
          return;
        }
        if (ae < 0) {
          if (a.noWrap)
            return;
          i.value = U.value.length - 1;
          return;
        }
        B.value = i.value, i.value = ae;
      }
    }, N = () => {
      $(i.value - 1);
    }, H = () => {
      $(i.value + 1);
    }, k = (ae) => {
      a.keyboard !== false && ae();
    }, S = () => {
      a.noHoverPause || V();
    }, E = () => {
      Y.value && O();
    }, { lengthX: M } = Kr(m, {
      passive: true,
      onSwipeStart() {
        a.noTouch !== true && V();
      },
      onSwipeEnd() {
        if (a.noTouch === true)
          return;
        const ae = () => {
          Y.value !== false && O();
        };
        if (M.value >= c.value) {
          H(), ae();
          return;
        }
        M.value <= -c.value && (N(), ae());
      }
    }), X = () => {
      n("slide", j("slide")), v.value = true;
    }, I = () => {
      n("slid", j("slid")), v.value = false;
    }, z = (ae) => {
      i.value !== 0 && ae.classList.add("carousel-item");
    }, te = (ae) => {
      var K, ne;
      f.value = ((ne = (K = d.value) == null ? void 0 : K.find((re) => re.$el === ae)) == null ? void 0 : ne.$props.interval) ?? null;
    };
    return qe(
      "ArrowLeft",
      () => {
        k(N);
      },
      { target: m }
    ), qe(
      "ArrowRight",
      () => {
        k(H);
      },
      { target: m }
    ), watch(
      () => a.ride,
      () => {
        y.value = false;
      }
    ), watch(g, (ae) => {
      if (ae) {
        S();
        return;
      }
      E();
    }), l({
      next: H,
      pause: V,
      prev: N,
      resume: O
    }), provide(Dl, {
      background: toRef(() => a.background),
      width: toRef(() => a.imgWidth),
      height: toRef(() => a.imgHeight)
    }), (ae, K) => (openBlock(), createElementBlock("div", {
      id: unref(u),
      ref_key: "element",
      ref: m,
      class: normalizeClass(["carousel slide pointer-event", F.value])
    }, [
      unref(a).indicators ? (openBlock(), createElementBlock("div", Au, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(U.value.length, (ne, re) => (openBlock(), createElementBlock("button", {
          key: re,
          type: "button",
          "data-bs-target": "",
          class: normalizeClass(re === i.value ? "active" : ""),
          "aria-current": re === i.value ? true : void 0,
          "aria-label": `${unref(a).indicatorsButtonLabel} ${re}`,
          onClick: (Q) => $(re)
        }, null, 10, Nu))), 128))
      ])) : createCommentVNode("", true),
      createBaseVNode("div", {
        ref_key: "relatedTarget",
        ref: w,
        class: "carousel-inner"
      }, [
        createVNode(TransitionGroup, {
          "enter-from-class": A.value,
          "enter-active-class": A.value,
          "enter-to-class": A.value,
          "leave-from-class": C.value,
          "leave-active-class": C.value,
          "leave-to-class": C.value,
          onBeforeLeave: X,
          onAfterLeave: I,
          onAfterEnter: z,
          onEnter: te
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(U.value, (ne, re) => withDirectives((openBlock(), createBlock(resolveDynamicComponent(ne), {
              key: re,
              ref_for: true,
              ref_key: "slideValues",
              ref: d,
              class: normalizeClass({ active: re === i.value && v.value === false })
            }, null, 8, ["class"])), [
              [vShow, re === i.value]
            ])), 128))
          ]),
          _: 1
        }, 8, ["enter-from-class", "enter-active-class", "enter-to-class", "leave-from-class", "leave-active-class", "leave-to-class"])
      ], 512),
      unref(a).controls ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createBaseVNode("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: N
        }, [
          Ou,
          createBaseVNode("span", Pu, toDisplayString(unref(a).controlsPrevText), 1)
        ]),
        createBaseVNode("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: H
        }, [
          Eu,
          createBaseVNode("span", Fu, toDisplayString(unref(a).controlsNextText), 1)
        ])
      ], 64)) : createCommentVNode("", true)
    ], 10, Vu));
  }
});
var Lu = ["innerHTML"];
var Ru = { key: 1 };
var zu = ["innerHTML"];
var Mu = { key: 1 };
var Hu = defineComponent({
  __name: "BCarouselSlide",
  props: {
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { type: Boolean, default: false },
    imgBlankColor: { default: "transparent" },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgSrcset: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(t4) {
    const e = G(t4, "BCarouselSlide"), o = useSlots(), a = inject(Dl, null), n = toRef(() => e.text || e.textHtml || !Ne(o.text)), r = toRef(() => e.caption || e.captionHtml || !Ne(o.caption)), u = toRef(() => n.value || r.value || !Ne(o.default)), i = computed(() => ({
      background: `${e.background || (a == null ? void 0 : a.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), d = computed(() => ({
      "d-none": e.contentVisibleUp !== void 0,
      [`d-${e.contentVisibleUp}-block`]: e.contentVisibleUp !== void 0
    }));
    return (c, f) => (openBlock(), createElementBlock("div", {
      class: "carousel-item",
      style: normalizeStyle(i.value)
    }, [
      renderSlot(c.$slots, "img", {}, () => {
        var p, v;
        return [
          createVNode(ko, {
            class: "d-block w-100",
            alt: unref(e).imgAlt,
            srcset: unref(e).imgSrcset,
            src: unref(e).imgSrc,
            width: unref(e).imgWidth || ((p = unref(a)) == null ? void 0 : p.width.value),
            height: unref(e).imgHeight || ((v = unref(a)) == null ? void 0 : v.height.value),
            blank: unref(e).imgBlank,
            "blank-color": unref(e).imgBlankColor
          }, null, 8, ["alt", "srcset", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      u.value ? (openBlock(), createBlock(resolveDynamicComponent(unref(e).contentTag), {
        key: 0,
        class: normalizeClass(["carousel-caption", d.value])
      }, {
        default: withCtx(() => [
          r.value ? (openBlock(), createBlock(resolveDynamicComponent(unref(e).captionTag), { key: 0 }, {
            default: withCtx(() => [
              renderSlot(c.$slots, "caption", {}, () => [
                unref(e).captionHtml ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  innerHTML: unref(e).captionHtml
                }, null, 8, Lu)) : (openBlock(), createElementBlock("span", Ru, toDisplayString(unref(e).caption), 1))
              ])
            ]),
            _: 3
          })) : createCommentVNode("", true),
          n.value ? (openBlock(), createBlock(resolveDynamicComponent(unref(e).textTag), { key: 1 }, {
            default: withCtx(() => [
              renderSlot(c.$slots, "text", {}, () => [
                unref(e).textHtml ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  innerHTML: unref(e).textHtml
                }, null, 8, zu)) : (openBlock(), createElementBlock("span", Mu, toDisplayString(unref(e).text), 1))
              ])
            ]),
            _: 3
          })) : createCommentVNode("", true),
          renderSlot(c.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : createCommentVNode("", true)
    ], 4));
  }
});
var Dt = defineComponent({
  __name: "BCol",
  props: {
    alignSelf: { default: void 0 },
    tag: { default: "div" },
    order: { default: void 0 },
    offset: { default: void 0 },
    cols: { default: void 0 },
    col: { type: Boolean, default: false },
    offsetSm: { default: void 0 },
    offsetMd: { default: void 0 },
    offsetLg: { default: void 0 },
    offsetXl: { default: void 0 },
    offsetXxl: { default: void 0 },
    orderSm: { default: void 0 },
    orderMd: { default: void 0 },
    orderLg: { default: void 0 },
    orderXl: { default: void 0 },
    orderXxl: { default: void 0 },
    sm: { type: [Boolean, Number, String], default: false },
    md: { type: [Boolean, Number, String], default: false },
    lg: { type: [Boolean, Number, String], default: false },
    xl: { type: [Boolean, Number, String], default: false },
    xxl: { type: [Boolean, Number, String], default: false }
  },
  setup(t4) {
    const e = G(t4, "BCol"), o = computed(() => [
      ...la(
        {
          sm: e.sm,
          md: e.md,
          lg: e.lg,
          xl: e.xl,
          xxl: e.xxl
        },
        ["sm", "md", "lg", "xl", "xxl"],
        "col"
      ),
      ...la(
        {
          order: e.order,
          orderLg: e.orderLg,
          orderMd: e.orderMd,
          orderSm: e.orderSm,
          orderXl: e.orderXl,
          orderXxl: e.orderXxl
        },
        ["order", "orderLg", "orderMd", "orderSm", "orderXl", "orderXxl"],
        "order"
      ),
      ...la(
        {
          offset: e.offset,
          offsetLg: e.offsetLg,
          offsetMd: e.offsetMd,
          offsetSm: e.offsetSm,
          offsetXl: e.offsetXl,
          offsetXxl: e.offsetXxl
        },
        ["offset", "offsetLg", "offsetMd", "offsetSm", "offsetXl", "offsetXxl"],
        "offset"
      )
    ]), a = computed(() => [
      o.value,
      {
        col: e.col || !o.value.some((n) => n.startsWith("col-")) && !e.cols,
        [`col-${e.cols}`]: e.cols !== void 0,
        [`offset-${e.offset}`]: e.offset !== void 0,
        [`order-${e.order}`]: e.order !== void 0,
        [`align-self-${e.alignSelf}`]: e.alignSelf !== void 0
      }
    ]);
    return (n, r) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(a.value)
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var Du = defineComponent({
  __name: "BContainer",
  props: {
    fluid: { type: [Boolean, String], default: false },
    gutterX: { default: void 0 },
    gutterY: { default: void 0 },
    tag: { default: "div" }
  },
  setup(t4) {
    const e = G(t4, "BContainer"), o = computed(() => ({
      container: e.fluid === false,
      "container-fluid": e.fluid === true,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== void 0,
      [`gy-${e.gutterY}`]: e.gutterY !== void 0
    }));
    return (a, n) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(o.value)
    }, {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var ju = { class: "visually-hidden" };
var qu = ["aria-labelledby", "role"];
var Un = defineComponent({
  __name: "BDropdown",
  props: mergeModels({
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: true },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    dropend: { type: Boolean, default: false },
    dropstart: { type: Boolean, default: false },
    dropup: { type: Boolean, default: false },
    end: { type: Boolean, default: false },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: false },
    lazy: { type: Boolean, default: false },
    menuClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCaret: { type: Boolean, default: false },
    noFlip: { type: Boolean, default: false },
    noShift: { type: Boolean, default: false },
    noSize: { type: Boolean, default: false },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    skipWrapper: { type: Boolean, default: false },
    split: { type: Boolean, default: false },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: Boolean, default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    wrapperClass: { default: void 0 },
    teleportDisabled: { default: false },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: false },
    modelModifiers: {}
  }),
  emits: mergeModels(["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle"], ["update:modelValue"]),
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BDropdown"), n = e, r = ke(() => a.id, "dropdown"), u = useModel(t4, "modelValue"), i = inject(on, false), d = toRef(
      () => typeof a.offset == "string" || typeof a.offset == "number" ? a.offset : NaN
    ), c = _e(d), f = ref(null), p = ref(null), v = ref(null), y = ref(null), h2 = computed(
      () => a.boundary === "document" || a.boundary === "viewport" ? void 0 : a.boundary
    ), w = computed(
      () => a.boundary === "document" || a.boundary === "viewport" ? a.boundary : void 0
    ), m = toRef(() => a.split ? p.value : v.value);
    qe(
      "Escape",
      () => {
        u.value = !u.value;
      },
      { target: m }
    ), qe(
      "Escape",
      () => {
        u.value = !u.value;
      },
      { target: f }
    );
    const B = (S, E) => {
      var X, I, z, te, ae, K, ne;
      if ((I = f.value) != null && I.contains((X = S.target) == null ? void 0 : X.closest("form")) || /input|select|option|textarea|form/i.test((z = S.target) == null ? void 0 : z.tagName))
        return;
      if (S.preventDefault(), !u.value) {
        open(), nextTick(() => B(S, E));
        return;
      }
      const M = (te = f.value) == null ? void 0 : te.querySelectorAll(".dropdown-item:not(.disabled):not(:disabled)");
      if (M)
        if ((ae = f.value) != null && ae.contains(document.activeElement)) {
          const re = f.value.querySelector(".dropdown-item:focus"), Q = Array.prototype.indexOf.call(M, re) + E;
          Q >= 0 && Q < (M == null ? void 0 : M.length) && ((K = M[Q]) == null || K.focus());
        } else
          (ne = M[E === -1 ? M.length - 1 : 0]) == null || ne.focus();
    };
    qe("ArrowUp", (S) => B(S, -1), { target: m }), qe("ArrowDown", (S) => B(S, 1), { target: m }), qe("ArrowUp", (S) => B(S, -1), { target: f }), qe("ArrowDown", (S) => B(S, 1), { target: f });
    const g = computed(
      () => ei({
        top: a.dropup,
        start: a.dropstart,
        end: a.dropend,
        alignCenter: a.center,
        alignEnd: a.end
      })
    ), A = ref({}), C = computed(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const S = typeof a.offset == "string" || typeof a.offset == "number" ? c.value : a.offset, E = [Sl(S)];
      return a.noFlip === false && E.push(
        $l({
          boundary: h2.value,
          rootBoundary: w.value,
          padding: a.boundaryPadding
        })
      ), a.noShift === false && E.push(
        xl({
          boundary: h2.value,
          rootBoundary: w.value,
          padding: a.boundaryPadding
        })
      ), a.noSize === false && E.push(
        Vl({
          boundary: h2.value,
          rootBoundary: w.value,
          padding: a.boundaryPadding,
          apply({ availableWidth: M, availableHeight: X }) {
            A.value = {
              maxHeight: X && u.value ? `${X}px` : void 0,
              maxWidth: M && u.value ? `${M}px` : void 0
            };
          }
        })
      ), E;
    }), { update: V, floatingStyles: O } = Nl(m, f, {
      placement: g,
      middleware: C,
      strategy: toRef(() => a.strategy),
      whileElementsMounted: Tl
    }), Y = computed(() => [
      a.wrapperClass,
      {
        "btn-group": !a.wrapperClass && a.split,
        dropdown: !a.wrapperClass && !a.split,
        dropup: a.dropup,
        dropend: a.dropend,
        dropstart: a.dropstart,
        "position-static": a.boundary !== "clippingAncestors" && !a.isNav
      }
    ]), U = computed(() => [
      a.split ? a.splitClass : a.toggleClass,
      {
        "nav-link": a.isNav,
        "dropdown-toggle": !a.split,
        "dropdown-toggle-no-caret": a.noCaret && !a.split,
        show: a.split ? void 0 : u.value
      }
    ]), F = () => {
      k();
    }, j = (S) => {
      a.split ? n("click", S) : F();
    };
    Rl(
      f,
      () => {
        u.value && (a.autoClose === true || a.autoClose === "outside") && k();
      },
      { ignore: [p, v] }
    );
    const $ = () => {
      u.value && (a.autoClose === true || a.autoClose === "inside") && k();
    }, N = () => {
      u.value && k();
    }, H = () => {
      u.value || k();
    }, k = () => {
      var M, X;
      n("toggle");
      const S = u.value, E = new Ct(S ? "hide" : "show");
      if (n(S ? "hide" : "show", E), E.defaultPrevented) {
        n(S ? "hide-prevented" : "show-prevented");
        return;
      }
      u.value = !S, n(S ? "hidden" : "shown"), (X = (M = y.value) == null ? void 0 : M.dispatchEvent) == null || X.call(M, new Event("forceHide"));
    };
    return watch(u, () => {
      V();
    }), l({
      hide: N,
      show: H,
      toggle: k
    }), provide(Yl, {
      id: r,
      show: H,
      hide: N,
      toggle: k,
      visible: toRef(() => u.value),
      isNav: toRef(() => a.isNav)
    }), (S, E) => (openBlock(), createBlock(Zt, {
      ref_key: "wrapper",
      ref: y,
      skip: unref(i) || unref(a).skipWrapper,
      class: normalizeClass(Y.value)
    }, {
      default: withCtx(() => [
        createVNode(vt, {
          id: unref(r),
          ref_key: "splitButton",
          ref: v,
          variant: unref(a).splitVariant || unref(a).variant,
          size: unref(a).size,
          class: normalizeClass(U.value),
          disabled: unref(a).splitDisabled || unref(a).disabled,
          type: unref(a).splitButtonType,
          "aria-label": unref(a).ariaLabel,
          "aria-expanded": unref(a).split ? void 0 : u.value,
          "aria-haspopup": unref(a).split ? void 0 : "menu",
          href: unref(a).split ? unref(a).splitHref : void 0,
          to: unref(a).split && unref(a).splitTo ? unref(a).splitTo : void 0,
          onClick: j
        }, {
          default: withCtx(() => [
            renderSlot(S.$slots, "button-content", {}, () => [
              createTextVNode(toDisplayString(unref(a).text), 1)
            ])
          ]),
          _: 3
        }, 8, ["id", "variant", "size", "class", "disabled", "type", "aria-label", "aria-expanded", "aria-haspopup", "href", "to"]),
        unref(a).split ? (openBlock(), createBlock(vt, {
          key: 0,
          ref_key: "button",
          ref: p,
          variant: unref(a).variant,
          size: unref(a).size,
          disabled: unref(a).disabled,
          class: normalizeClass([[unref(a).toggleClass, { show: u.value }], "dropdown-toggle-split dropdown-toggle"]),
          "aria-expanded": u.value,
          "aria-haspopup": "menu",
          onClick: F
        }, {
          default: withCtx(() => [
            createBaseVNode("span", ju, [
              renderSlot(S.$slots, "toggle-text", {}, () => [
                createTextVNode(toDisplayString(unref(a).toggleText), 1)
              ])
            ])
          ]),
          _: 3
        }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : createCommentVNode("", true),
        (openBlock(), createBlock(Teleport, {
          to: unref(a).teleportTo,
          disabled: !unref(a).teleportTo || unref(a).teleportDisabled
        }, [
          !unref(a).lazy || u.value ? withDirectives((openBlock(), createElementBlock("ul", {
            key: 0,
            ref_key: "floating",
            ref: f,
            style: normalizeStyle([unref(O), A.value]),
            class: normalizeClass(["dropdown-menu overflow-auto", [unref(a).menuClass, { show: u.value }]]),
            "aria-labelledby": unref(r),
            role: unref(a).role,
            onClick: $
          }, [
            renderSlot(S.$slots, "default", {
              hide: N,
              show: H
            })
          ], 14, qu)), [
            [vShow, unref(a).lazy || u.value]
          ]) : createCommentVNode("", true)
        ], 8, ["to", "disabled"]))
      ]),
      _: 3
    }, 8, ["skip", "class"]));
  }
});
var Wu = { role: "presentation" };
var Gu = defineComponent({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(t4) {
    const e = G(t4, "BDropdownDivider");
    return (o, a) => (openBlock(), createElementBlock("li", Wu, [
      (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
});
var Uu = { role: "presentation" };
var Ku = defineComponent({
  __name: "BDropdownForm",
  setup(t4) {
    return (l, e) => (openBlock(), createElementBlock("li", Uu, [
      createBaseVNode("form", mergeProps({ class: "dropdown-item-text" }, l.$attrs), [
        renderSlot(l.$slots, "default")
      ], 16)
    ]));
  }
});
var Xu = { role: "presentation" };
var Yu = ["id", "aria-describedby"];
var Zu = defineComponent({
  inheritAttrs: false,
  __name: "BDropdownGroup",
  props: {
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: null },
    id: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BDropdownGroup"), o = toRef(() => e.id ? `${e.id}_group_dd_header` : void 0), a = toRef(() => e.headerTag === "header" ? void 0 : "heading"), n = computed(() => [
      e.headerClass,
      {
        [`text-${e.headerVariant}`]: e.headerVariant !== null
      }
    ]);
    return (r, u) => (openBlock(), createElementBlock("li", Xu, [
      (openBlock(), createBlock(resolveDynamicComponent(unref(e).headerTag), {
        id: o.value,
        class: normalizeClass(["dropdown-header", n.value]),
        role: a.value
      }, {
        default: withCtx(() => [
          renderSlot(r.$slots, "header", {}, () => [
            createTextVNode(toDisplayString(unref(e).header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      createBaseVNode("ul", mergeProps({
        id: unref(e).id,
        role: "group",
        class: "list-unstyled"
      }, r.$attrs, {
        "aria-describedby": unref(e).ariaDescribedby || o.value
      }), [
        renderSlot(r.$slots, "default")
      ], 16, Yu)
    ]));
  }
});
var Ju = { class: "dropdown-header" };
var Qu = defineComponent({
  __name: "BDropdownHeader",
  setup(t4) {
    return (l, e) => (openBlock(), createElementBlock("li", null, [
      createBaseVNode("h6", Ju, [
        renderSlot(l.$slots, "default")
      ])
    ]));
  }
});
var ed = defineComponent({
  inheritAttrs: false,
  __name: "BDropdownItem",
  props: {
    linkClass: { default: void 0 },
    wrapperAttrs: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: false },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: null },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  emits: ["click"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BDropdownItem"), a = l, { class: n, ...r } = useAttrs(), { computedLink: u, computedLinkProps: i } = Tt(o), d = computed(() => [
      o.linkClass,
      {
        active: o.active,
        disabled: o.disabled,
        [`text-${o.variant}`]: o.variant !== null
      }
    ]), c = toRef(() => u.value ? it : o.href ? "a" : "button"), f = inject(ho, null), p = inject(Yl, null), v = inject(Bo, null), y = (h2) => {
      var w, m, B;
      a("click", h2), v !== null && ((w = v == null ? void 0 : v.autoClose) == null ? void 0 : w.value) === true && ((m = f == null ? void 0 : f.hide) == null || m.call(f)), (B = p == null ? void 0 : p.hide) == null || B.call(p);
    };
    return (h2, w) => (openBlock(), createElementBlock("li", mergeProps({
      role: "presentation",
      class: unref(n)
    }, unref(o).wrapperAttrs), [
      (openBlock(), createBlock(resolveDynamicComponent(c.value), mergeProps({
        class: ["dropdown-item", d.value],
        disabled: unref(o).disabled,
        "aria-disabled": unref(o).disabled ? true : null,
        "aria-current": unref(o).active ? true : null,
        href: c.value === "a" ? unref(o).href : null,
        rel: unref(o).rel,
        role: "menuitem",
        type: c.value === "button" ? "button" : null,
        target: unref(o).target
      }, { ...unref(i), ...r }, { onClick: y }), {
        default: withCtx(() => [
          renderSlot(h2.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "disabled", "aria-disabled", "aria-current", "href", "rel", "type", "target"]))
    ], 16));
  }
});
var td = { role: "presentation" };
var ad = ["disabled"];
var od = defineComponent({
  inheritAttrs: false,
  __name: "BDropdownItemButton",
  props: {
    active: { type: Boolean, default: false },
    activeClass: { default: "active" },
    buttonClass: { default: void 0 },
    disabled: { type: Boolean, default: false },
    variant: { default: null }
  },
  emits: ["click"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BDropdownItemButton"), a = l, n = computed(() => [
      o.buttonClass,
      {
        [o.activeClass]: o.active,
        disabled: o.disabled,
        [`text-${o.variant}`]: o.variant !== null
      }
    ]), r = (u) => {
      a("click", u);
    };
    return (u, i) => (openBlock(), createElementBlock("li", td, [
      createBaseVNode("button", {
        role: "menu",
        type: "button",
        class: normalizeClass(["dropdown-item", n.value]),
        disabled: unref(o).disabled,
        onClick: r
      }, [
        renderSlot(u.$slots, "default")
      ], 10, ad)
    ]));
  }
});
var ld = { role: "presentation" };
var nd = defineComponent({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(t4) {
    const e = G(t4, "BDropdownText");
    return (o, a) => (openBlock(), createElementBlock("li", ld, [
      createBaseVNode("span", mergeProps({ class: "dropdown-item-text" }, o.$attrs), [
        renderSlot(o.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(unref(e).text), 1)
        ])
      ], 16)
    ]));
  }
});
var sd = ["id", "novalidate"];
var Kn = defineComponent({
  __name: "BForm",
  props: {
    floating: { type: Boolean, default: false },
    id: { default: void 0 },
    novalidate: { type: Boolean, default: false },
    validated: { type: Boolean, default: false }
  },
  emits: ["submit"],
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BForm"), n = e, r = ref(null), u = computed(() => ({
      "form-floating": a.floating,
      "was-validated": a.validated
    })), i = (d) => {
      n("submit", d);
    };
    return l({
      element: r
    }), (d, c) => (openBlock(), createElementBlock("form", {
      id: unref(a).id,
      ref_key: "element",
      ref: r,
      novalidate: unref(a).novalidate,
      class: normalizeClass(u.value),
      onSubmit: withModifiers(i, ["prevent"])
    }, [
      renderSlot(d.$slots, "default")
    ], 42, sd));
  }
});
var rd = { class: "form-floating" };
var id = ["for"];
var ud = defineComponent({
  __name: "BFormFloatingLabel",
  props: {
    label: { default: void 0 },
    labelFor: { default: void 0 },
    text: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BFormFloatingLabel");
    return (o, a) => (openBlock(), createElementBlock("div", rd, [
      renderSlot(o.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(unref(e).text), 1)
      ]),
      createBaseVNode("label", {
        for: unref(e).labelFor
      }, [
        renderSlot(o.$slots, "label", {}, () => [
          createTextVNode(toDisplayString(unref(e).label), 1)
        ])
      ], 8, id)
    ]));
  }
});
var Xa = defineComponent({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: Boolean, default: false },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: Boolean, default: false }
  },
  setup(t4) {
    const e = G(t4, "BFormInvalidFeedback"), o = toRef(() => e.forceShow === true || e.state === false), a = computed(() => ({
      "d-block": o.value,
      "invalid-feedback": !e.tooltip,
      "invalid-tooltip": e.tooltip
    }));
    return (n, r) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      id: unref(e).id,
      role: unref(e).role,
      "aria-live": unref(e).ariaLive,
      "aria-atomic": unref(e).ariaLive ? true : void 0,
      class: normalizeClass(a.value)
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(unref(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
});
var ia = defineComponent({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(t4) {
    const e = G(t4, "BFormRow");
    return (o, a) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), { class: "row d-flex flex-wrap" }, {
      default: withCtx(() => [
        renderSlot(o.$slots, "default")
      ]),
      _: 3
    }));
  }
});
var Ya = defineComponent({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { type: Boolean, default: false },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "body-secondary" }
  },
  setup(t4) {
    const e = G(t4, "BFormText"), o = computed(() => ({
      [`text-${e.textVariant}`]: e.textVariant !== null,
      "form-text": !e.inline
    }));
    return (a, n) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      id: unref(e).id,
      class: normalizeClass(o.value)
    }, {
      default: withCtx(() => [
        renderSlot(a.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(unref(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
});
var Za = defineComponent({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: Boolean, default: false },
    id: { default: void 0 },
    role: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    tag: { default: "div" },
    text: { default: void 0 },
    tooltip: { type: Boolean, default: false }
  },
  setup(t4) {
    const e = G(t4, "BFormInvalidFeedback"), o = toRef(() => e.forceShow === true || e.state === true), a = computed(() => ({
      "d-block": o.value,
      "valid-feedback": !e.tooltip,
      "valid-tooltip": e.tooltip
    }));
    return (n, r) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      id: unref(e).id,
      role: unref(e).role,
      "aria-live": unref(e).ariaLive,
      "aria-atomic": unref(e).ariaLive ? true : void 0,
      class: normalizeClass(a.value)
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(unref(e).text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
});
var dd = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "true-value", "false-value", "indeterminate"];
var cd = ["for"];
var Xn = defineComponent({
  inheritAttrs: false,
  __name: "BFormCheckbox",
  props: mergeModels({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: Boolean, default: false },
    button: { type: Boolean, default: false },
    buttonGroup: { type: Boolean, default: false },
    buttonVariant: { default: null },
    disabled: { type: Boolean, default: false },
    form: { default: void 0 },
    id: { default: void 0 },
    indeterminate: { type: Boolean },
    inline: { type: Boolean, default: false },
    modelValue: { type: [Array, Set, String, Boolean, Object, Number, null] },
    name: { default: void 0 },
    plain: { type: Boolean, default: false },
    required: { type: Boolean, default: void 0 },
    reverse: { type: Boolean, default: false },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    switch: { type: Boolean, default: false },
    uncheckedValue: { type: [Array, Set, String, Boolean, Object, Number, null], default: false },
    value: { type: [String, Boolean, Array, Set, Object, Number, null], default: true }
  }, {
    modelValue: { type: [Array, Set, String, Boolean, Object, Number, null], default: void 0 },
    modelModifiers: {},
    indeterminate: { type: Boolean, default: false },
    indeterminateModifiers: {}
  }),
  emits: ["update:modelValue", "update:indeterminate"],
  setup(t4, { expose: l }) {
    const o = G(t4, "BFormCheckbox"), a = useSlots(), n = useModel(t4, "modelValue"), r = useModel(t4, "indeterminate"), u = ke(() => o.id, "form-check"), i = inject(Kl, null), d = ref(null), { focused: c } = Re(d, {
      initialValue: o.autofocus
    }), f = toRef(() => !Ne(a.default)), p = computed({
      get: () => (i == null ? void 0 : i.modelValue.value) ?? n.value,
      set: (g) => {
        if (g !== void 0) {
          if (r.value = false, i !== null && Array.isArray(g)) {
            i.modelValue.value = g;
            return;
          }
          n.value = g;
        }
      }
    }), v = toRef(
      () => !!(o.name ?? (i == null ? void 0 : i.name.value)) && (o.required || (i == null ? void 0 : i.required.value))
    ), y = toRef(() => o.buttonGroup || ((i == null ? void 0 : i.buttons.value) ?? false)), h2 = computed(() => ({
      plain: o.plain || ((i == null ? void 0 : i.plain.value) ?? false),
      button: o.button || ((i == null ? void 0 : i.buttons.value) ?? false),
      inline: o.inline || ((i == null ? void 0 : i.inline.value) ?? false),
      reverse: o.reverse || ((i == null ? void 0 : i.reverse.value) ?? false),
      switch: o.switch || ((i == null ? void 0 : i.switch.value) ?? false),
      state: o.state || (i == null ? void 0 : i.state.value),
      size: o.size ?? (i == null ? void 0 : i.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: o.buttonVariant ?? (i == null ? void 0 : i.buttonVariant.value) ?? "secondary",
      // This is where the true default is made
      hasDefaultSlot: f.value
    })), w = un(h2), m = dn(h2), B = cn(h2);
    return l({
      blur: () => {
        c.value = false;
      },
      element: d,
      focus: () => {
        c.value = true;
      }
    }), (g, A) => (openBlock(), createBlock(Zt, {
      skip: y.value,
      class: normalizeClass(unref(w))
    }, {
      default: withCtx(() => {
        var C, V, O;
        return [
          withDirectives(createBaseVNode("input", mergeProps({ id: unref(u) }, g.$attrs, {
            ref_key: "input",
            ref: d,
            "onUpdate:modelValue": A[0] || (A[0] = (Y) => p.value = Y),
            class: unref(m),
            type: "checkbox",
            disabled: unref(o).disabled || ((C = unref(i)) == null ? void 0 : C.disabled.value),
            required: v.value || void 0,
            name: unref(o).name || ((V = unref(i)) == null ? void 0 : V.name.value),
            form: unref(o).form || ((O = unref(i)) == null ? void 0 : O.form.value),
            "aria-label": unref(o).ariaLabel,
            "aria-labelledby": unref(o).ariaLabelledby,
            "aria-required": v.value || void 0,
            value: unref(o).value,
            "true-value": unref(o).value,
            "false-value": unref(o).uncheckedValue,
            indeterminate: unref(o).indeterminate
          }), null, 16, dd), [
            [vModelCheckbox, p.value]
          ]),
          f.value || unref(o).plain === false ? (openBlock(), createElementBlock("label", {
            key: 0,
            for: unref(u),
            class: normalizeClass(unref(B))
          }, [
            renderSlot(g.$slots, "default")
          ], 10, cd)) : createCommentVNode("", true)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
});
var fd = ["id"];
var vd = ["innerHTML"];
var pd = defineComponent({
  __name: "BFormCheckboxGroup",
  props: mergeModels({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: false },
    buttonVariant: { default: "secondary" },
    buttons: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: {},
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    reverse: { type: Boolean, default: false },
    size: { default: "md" },
    stacked: { type: Boolean, default: false },
    state: { type: [Boolean, null], default: null },
    switches: { type: Boolean, default: false },
    textField: { default: "text" },
    validated: { type: Boolean, default: false },
    valueField: { default: "value" }
  }, {
    modelValue: {
      default: () => []
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t4, { expose: l }) {
    const o = G(t4, "BFormCheckboxGroup"), a = useModel(t4, "modelValue"), n = ke(() => o.id, "checkbox"), r = ke(() => o.name, "checkbox"), u = ref(null), { focused: i } = Re(u, {
      initialValue: o.autofocus
    });
    provide(Kl, {
      modelValue: a,
      switch: toRef(() => o.switches),
      buttonVariant: toRef(() => o.buttonVariant),
      form: toRef(() => o.form),
      name: r,
      state: toRef(() => o.state),
      plain: toRef(() => o.plain),
      size: toRef(() => o.size),
      inline: toRef(() => !o.stacked),
      reverse: toRef(() => o.reverse),
      required: toRef(() => o.required),
      buttons: toRef(() => o.buttons),
      disabled: toRef(() => o.disabled)
    });
    const d = computed(
      () => o.options.map(
        (v, y) => typeof v == "string" || typeof v == "number" ? {
          props: {
            value: v,
            disabled: o.disabled
          },
          text: v.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${y}`)
        } : {
          props: {
            value: v[o.valueField],
            disabled: v[o.disabledField],
            ...v.props ? v.props : {}
          },
          text: v[o.textField],
          html: v[o.htmlField],
          self: Symbol(`checkboxGroupOptionItem${y}`)
        }
      )
    ), c = computed(() => ({
      required: o.required,
      ariaInvalid: o.ariaInvalid,
      state: o.state,
      validated: o.validated,
      buttons: o.buttons,
      stacked: o.stacked,
      size: o.size
    })), f = fn(c), p = vn(c);
    return l({
      blur: () => {
        i.value = false;
      },
      focus: () => {
        i.value = true;
      }
    }), (v, y) => (openBlock(), createElementBlock("div", mergeProps(unref(f), {
      id: unref(n),
      ref_key: "element",
      ref: u,
      role: "group",
      class: [unref(p), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      renderSlot(v.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(d.value, (h2) => (openBlock(), createBlock(Xn, mergeProps({
        key: h2.self,
        ref_for: true
      }, h2.props), {
        default: withCtx(() => [
          h2.html ? (openBlock(), createElementBlock("span", {
            key: 0,
            innerHTML: h2.html
          }, null, 8, vd)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(h2.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040))), 128)),
      renderSlot(v.$slots, "default")
    ], 16, fd));
  }
});
var md = ["for"];
var bd = ["id", "form", "name", "multiple", "disabled", "capture", "accept", "required", "aria-label", "aria-labelledby", "aria-required", "directory", "webkitdirectory"];
var yd = defineComponent({
  inheritAttrs: false,
  __name: "BFormFile",
  props: mergeModels({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    accept: { default: "" },
    autofocus: { type: Boolean, default: false },
    capture: { type: [Boolean, String], default: false },
    directory: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    form: { default: void 0 },
    id: { default: void 0 },
    label: { default: "" },
    labelClass: { default: void 0 },
    modelValue: {},
    multiple: { type: Boolean, default: false },
    name: { default: void 0 },
    noButton: { type: Boolean, default: false },
    noDrop: { type: Boolean, default: false },
    noTraverse: { type: Boolean, default: false },
    plain: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null }
  }, {
    modelValue: {
      default: null
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t4, { expose: l }) {
    const e = useSlots(), a = G(t4, "BFormFile"), n = useModel(t4, "modelValue"), r = ke(() => a.id), u = St(() => a.state), i = ref(null), { focused: d } = Re(i, { initialValue: a.autofocus }), c = toRef(() => !Ne(e.label)), f = toRef(
      () => typeof a.accept == "string" ? a.accept : a.accept.join(",")
    ), p = computed(() => [
      u.value,
      {
        [`form-control-${a.size}`]: a.size !== void 0,
        "form-control": !a.plain,
        "form-control-input-file-hide-button": a.noButton
      }
    ]), v = () => {
      var m, B;
      const w = ((m = i.value) == null ? void 0 : m.files) === null || ((B = i.value) == null ? void 0 : B.files) === void 0 ? null : [...i.value.files];
      n.value = w === null ? null : a.multiple === true ? w : w[0];
    }, y = (w) => {
      a.noDrop === true && w.preventDefault();
    }, h2 = () => {
      n.value = null;
    };
    return watch(n, (w) => {
      w === null && i.value !== null && (i.value.value = "");
    }), l({
      blur: () => {
        d.value = false;
      },
      element: i,
      focus: () => {
        d.value = true;
      },
      reset: h2
    }), (w, m) => (openBlock(), createElementBlock(Fragment, null, [
      c.value || unref(a).label ? (openBlock(), createElementBlock("label", {
        key: 0,
        class: normalizeClass(["form-label", unref(a).labelClass]),
        for: unref(r)
      }, [
        renderSlot(w.$slots, "label", {}, () => [
          createTextVNode(toDisplayString(unref(a).label), 1)
        ])
      ], 10, md)) : createCommentVNode("", true),
      createBaseVNode("input", mergeProps({ id: unref(r) }, w.$attrs, {
        ref_key: "input",
        ref: i,
        type: "file",
        class: p.value,
        form: unref(a).form,
        name: unref(a).name,
        multiple: unref(a).multiple,
        disabled: unref(a).disabled,
        capture: unref(a).capture,
        accept: f.value || void 0,
        required: unref(a).required || void 0,
        "aria-label": unref(a).ariaLabel,
        "aria-labelledby": unref(a).ariaLabelledby,
        "aria-required": unref(a).required || void 0,
        directory: unref(a).directory,
        webkitdirectory: unref(a).directory,
        onChange: v,
        onDrop: y
      }), null, 16, bd)
    ], 64));
  }
});
var Yn = ["input", "select", "textarea"];
var gd = Yn.map((t4) => `${t4}:not([disabled])`).join();
var hd = [...Yn, "a", "button", "label"];
var Bd = "label";
var _d = "invalid-feedback";
var wd = "valid-feedback";
var Cd = "description";
var kd = "default";
var Td = defineComponent({
  components: { BCol: Dt, BFormInvalidFeedback: Xa, BFormRow: ia, BFormText: Ya, BFormValidFeedback: Za },
  props: {
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: Boolean, default: false },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: Boolean, default: false },
    state: { type: Boolean, default: null },
    tooltip: { type: Boolean, default: false },
    validFeedback: { type: String, default: void 0 },
    validated: { type: Boolean, default: false },
    floating: { type: Boolean, default: false }
  },
  setup(t4) {
    const e = ["xs", "sm", "md", "lg", "xl"], o = (y, h2) => e.reduce((w, m) => {
      const B = jo(m === "xs" ? "" : m, `${h2}Align`), g = y[B] || null;
      return g && (m === "xs" ? w.push(`text-${g}`) : w.push(`text-${m}-${g}`)), w;
    }, []), a = (y, h2) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      e.reduce((w, m) => {
        const B = jo(m === "xs" ? "" : m, `${h2}Cols`);
        let g = y[B];
        if (g = g === "" ? true : g || false, typeof g != "boolean" && g !== "auto") {
          const A = Number.parseInt(g);
          g = Number.isNaN(A) ? 0 : A, g = g > 0 ? g : false;
        }
        return g && (m === "xs" ? w[typeof g == "boolean" ? "col" : "cols"] = g : w[m || (typeof g == "boolean" ? "col" : "cols")] = g), w;
      }, {})
    ), n = ref(null), r = (y, h2 = null) => {
      if (no && t4.labelFor && n.value !== null) {
        const w = n.value.querySelector(`#${CSS.escape(t4.labelFor)}`);
        if (w) {
          const m = "aria-describedby", B = (y || "").split(na), g = (h2 || "").split(na), A = (w.getAttribute(m) || "").split(na).filter((C) => !g.includes(C)).concat(B).filter((C, V, O) => O.indexOf(C) === V).filter((C) => C).join(" ").trim();
          A ? w.setAttribute(m, A) : w.removeAttribute(m);
        }
      }
    }, u = computed(() => a(t4, "content")), i = computed(() => o(t4, "label")), d = computed(() => a(t4, "label")), c = computed(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(u.value).length > 0 || Object.keys(d.value).length > 0
      )
    ), f = St(() => t4.state), p = Sa(
      () => t4.ariaInvalid,
      () => t4.state
    );
    return watch(
      () => null,
      (y, h2) => {
        y !== h2 && r(y, h2);
      }
    ), onMounted(() => {
      nextTick(() => {
        r(null);
      });
    }), {
      ariaDescribedby: null,
      computedAriaInvalid: p,
      contentColProps: u,
      isHorizontal: c,
      labelAlignClasses: i,
      labelColProps: d,
      onLegendClick: (y) => {
        if (t4.labelFor || n.value === null)
          return;
        const { target: h2 } = y, w = h2 ? h2.tagName : "";
        if (hd.indexOf(w) !== -1)
          return;
        const m = [...n.value.querySelectorAll(gd)].filter(ys), [B] = m;
        m.length === 1 && B instanceof HTMLElement && bs(B);
      },
      stateClass: f
    };
  },
  render() {
    const t4 = this.$props, l = this.$slots, e = ke(), o = !t4.labelFor;
    let a = null;
    const n = Mt(Bd, {}, l) || t4.label, r = n ? ke(void 0, "_BV_label_").value : null;
    if (n || this.isHorizontal) {
      const A = o ? "legend" : "label";
      if (t4.labelSrOnly)
        n && (a = h(
          A,
          {
            class: "visually-hidden",
            id: r,
            for: t4.labelFor || null
          },
          n
        )), this.isHorizontal ? a = h(Dt, this.labelColProps, { default: () => a }) : a = h("div", {}, [a]);
      else {
        const C = {
          onClick: o ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? A : null,
          id: r,
          for: t4.labelFor || null,
          tabIndex: o ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": o,
              "col-form-label": this.isHorizontal || o,
              "pt-0": !this.isHorizontal && o,
              "d-block": !this.isHorizontal && !o,
              [`col-form-label-${t4.labelSize}`]: !!t4.labelSize
            },
            this.labelAlignClasses,
            t4.labelClass
          ]
        };
        this.isHorizontal ? a = h(Dt, C, { default: () => n }) : a = h(A, C, n);
      }
    }
    let u = null;
    const i = Mt(_d, {}, l) || this.invalidFeedback, d = i ? ke(void 0, "_BV_feedback_invalid_").value : void 0;
    i && (u = h(
      Xa,
      {
        ariaLive: t4.feedbackAriaLive,
        id: d,
        state: t4.state,
        tooltip: t4.tooltip
      },
      { default: () => i }
    ));
    let c = null;
    const f = Mt(wd, {}, l) || this.validFeedback, p = f ? ke(void 0, "_BV_feedback_valid_").value : void 0;
    f && (c = h(
      Za,
      {
        ariaLive: t4.feedbackAriaLive,
        id: p,
        state: t4.state,
        tooltip: t4.tooltip
      },
      { default: () => f }
      // validFeedbackContent
    ));
    let v = null;
    const y = Mt(Cd, {}, l) || this.description, h2 = y ? ke(void 0, "_BV_description_").value : void 0;
    y && (v = h(
      Ya,
      {
        id: h2
      },
      { default: () => y }
    ));
    const w = this.ariaDescribedby = [
      h2,
      t4.state === false ? d : null,
      t4.state === true ? p : null
    ].filter((A) => A).join(" ") || null, m = [
      Mt(kd, { ariaDescribedby: w, descriptionId: h2, id: e, labelId: r }, l) || "",
      u,
      c,
      v
    ];
    !this.isHorizontal && t4.floating && m.push(a);
    let B = h(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && t4.floating
          }
        ]
      },
      m
    );
    this.isHorizontal && (B = h(Dt, { ref: "content", ...this.contentColProps }, { default: () => m }));
    const g = {
      class: [
        this.stateClass,
        {
          "was-validated": t4.validated
        }
      ],
      id: ke(() => t4.id).value,
      disabled: o ? t4.disabled : null,
      role: o ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": o && this.isHorizontal ? r : null
    };
    return this.isHorizontal && !o ? h(ia, g, { default: () => [a, B] }) : h(
      o ? "fieldset" : "div",
      g,
      this.isHorizontal && o ? [h(ia, null, { default: () => [a, B] })] : this.isHorizontal || !t4.floating ? [a, B] : [B]
    );
  }
});
var Sd = ["id", "value", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"];
var el = defineComponent({
  __name: "BFormInput",
  props: mergeModels({
    max: { default: void 0 },
    min: { default: void 0 },
    step: { default: void 0 },
    type: { default: "text" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazyFormatter: { type: Boolean, default: false },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    placeholder: { default: void 0 },
    plaintext: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  }, {
    modelValue: {
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t4, { expose: l }) {
    const o = G(t4, "BFormInput"), [a, n] = useModel(t4, "modelValue", {
      set: (m) => {
        if (m === null)
          return;
        let B = m;
        if (n.trim && (B = B.toString().trim()), (n.number || o.type === "number") && typeof B == "string" && B !== "") {
          const g = Number.parseFloat(B);
          B = Number.isNaN(g) ? B : g;
        }
        return B;
      }
    }), { input: r, computedId: u, computedAriaInvalid: i, onInput: d, onChange: c, onBlur: f, focus: p, blur: v } = pn(o, a, n), y = St(() => o.state), h2 = ref(false), w = computed(() => {
      const m = o.type === "range", B = o.type === "color";
      return [
        y.value,
        {
          "form-control-highlighted": h2.value,
          "form-range": m,
          "form-control": B || !o.plaintext && !m,
          "form-control-color": B,
          "form-control-plaintext": o.plaintext && !m && !B,
          [`form-control-${o.size}`]: !!o.size
        }
      ];
    });
    return l({
      blur: v,
      element: r,
      focus: p
    }), (m, B) => (openBlock(), createElementBlock("input", {
      id: unref(u),
      ref_key: "input",
      ref: r,
      value: unref(a),
      class: normalizeClass(w.value),
      name: unref(o).name || void 0,
      form: unref(o).form || void 0,
      type: unref(o).type,
      disabled: unref(o).disabled,
      placeholder: unref(o).placeholder,
      required: unref(o).required || void 0,
      autocomplete: unref(o).autocomplete || void 0,
      readonly: unref(o).readonly || unref(o).plaintext,
      min: unref(o).min,
      max: unref(o).max,
      step: unref(o).step,
      list: unref(o).type !== "password" ? unref(o).list : void 0,
      "aria-required": unref(o).required || void 0,
      "aria-invalid": unref(i),
      onInput: B[0] || (B[0] = (g) => unref(d)(g)),
      onChange: B[1] || (B[1] = (g) => unref(c)(g)),
      onBlur: B[2] || (B[2] = (g) => unref(f)(g))
    }, null, 42, Sd));
  }
});
var xd = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"];
var $d = ["for"];
var Zn = defineComponent({
  inheritAttrs: false,
  __name: "BFormRadio",
  props: mergeModels({
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    autofocus: { type: Boolean, default: false },
    button: { type: Boolean, default: false },
    buttonGroup: { type: Boolean, default: false },
    buttonVariant: { default: null },
    disabled: { type: Boolean, default: false },
    form: { default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: false },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    name: { default: void 0 },
    plain: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    reverse: { type: Boolean, default: false },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    value: { type: [Boolean, String, Array, Object, Number, null], default: true }
  }, {
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: void 0 },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t4, { expose: l }) {
    const o = G(t4, "BFormRadio"), a = useSlots(), n = useModel(t4, "modelValue"), r = ke(() => o.id, "form-check"), u = inject(Xl, null), i = ref(null), { focused: d } = Re(i, {
      initialValue: o.autofocus
    }), c = toRef(() => !Ne(a.default)), f = computed({
      get: () => (u == null ? void 0 : u.modelValue.value) ?? n.value,
      set: (B) => {
        if (B !== void 0) {
          if (u !== null) {
            u.modelValue.value = B;
            return;
          }
          n.value = B;
        }
      }
    }), p = toRef(
      () => !!(o.name ?? (u == null ? void 0 : u.name.value)) && (o.required || (u == null ? void 0 : u.required.value))
    ), v = toRef(() => o.buttonGroup || ((u == null ? void 0 : u.buttons.value) ?? false)), y = computed(() => ({
      plain: o.plain || ((u == null ? void 0 : u.plain.value) ?? false),
      button: o.button || ((u == null ? void 0 : u.buttons.value) ?? false),
      inline: o.inline || ((u == null ? void 0 : u.inline.value) ?? false),
      state: o.state || (u == null ? void 0 : u.state.value),
      reverse: o.reverse || ((u == null ? void 0 : u.reverse.value) ?? false),
      size: o.size ?? (u == null ? void 0 : u.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: o.buttonVariant ?? (u == null ? void 0 : u.buttonVariant.value) ?? "secondary",
      // This is where the true default is made
      hasDefaultSlot: c.value
    })), h2 = un(y), w = dn(y), m = cn(y);
    return l({
      blur: () => {
        d.value = false;
      },
      element: i,
      focus: () => {
        d.value = true;
      }
    }), (B, g) => (openBlock(), createBlock(Zt, {
      skip: v.value,
      class: normalizeClass(unref(h2))
    }, {
      default: withCtx(() => {
        var A, C, V;
        return [
          withDirectives(createBaseVNode("input", mergeProps({ id: unref(r) }, B.$attrs, {
            ref_key: "input",
            ref: i,
            "onUpdate:modelValue": g[0] || (g[0] = (O) => f.value = O),
            class: unref(w),
            type: "radio",
            disabled: unref(o).disabled || ((A = unref(u)) == null ? void 0 : A.disabled.value),
            required: p.value || void 0,
            name: unref(o).name || ((C = unref(u)) == null ? void 0 : C.name.value),
            form: unref(o).form || ((V = unref(u)) == null ? void 0 : V.form.value),
            "aria-label": unref(o).ariaLabel,
            "aria-labelledby": unref(o).ariaLabelledby,
            value: unref(o).value,
            "aria-required": p.value || void 0
          }), null, 16, xd), [
            [vModelRadio, f.value]
          ]),
          c.value || unref(o).plain === false ? (openBlock(), createElementBlock("label", {
            key: 0,
            for: unref(r),
            class: normalizeClass(unref(m))
          }, [
            renderSlot(B.$slots, "default")
          ], 10, $d)) : createCommentVNode("", true)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
});
var Vd = ["id"];
var Ad = ["innerHTML"];
var Nd = defineComponent({
  __name: "BFormRadioGroup",
  props: mergeModels({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: false },
    buttonVariant: { default: "secondary" },
    buttons: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    reverse: { type: Boolean, default: false },
    size: { default: "md" },
    stacked: { type: Boolean, default: false },
    state: { type: [Boolean, null], default: null },
    textField: { default: "text" },
    validated: { type: Boolean, default: false },
    valueField: { default: "value" }
  }, {
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: null },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t4, { expose: l }) {
    const o = G(t4, "BFormRadioGroup"), a = useModel(t4, "modelValue"), n = ke(() => o.id, "radio"), r = ke(() => o.name, "checkbox"), u = ref(null), { focused: i } = Re(u, {
      initialValue: o.autofocus
    });
    provide(Xl, {
      modelValue: a,
      buttonVariant: toRef(() => o.buttonVariant),
      form: toRef(() => o.form),
      name: r,
      buttons: toRef(() => o.buttons),
      state: toRef(() => o.state),
      plain: toRef(() => o.plain),
      size: toRef(() => o.size),
      inline: toRef(() => !o.stacked),
      reverse: toRef(() => o.reverse),
      required: toRef(() => o.required),
      disabled: toRef(() => o.disabled)
    });
    const d = computed(
      () => o.options.map(
        (v, y) => typeof v == "string" || typeof v == "number" ? {
          value: v,
          disabled: o.disabled,
          text: v.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${y}`)
        } : {
          value: v[o.valueField],
          disabled: v[o.disabledField],
          ...v.props ? v.props : {},
          text: v[o.textField],
          html: v[o.htmlField],
          self: Symbol(`radioGroupOptionItem${y}`)
        }
      )
    ), c = computed(() => ({
      required: o.required,
      ariaInvalid: o.ariaInvalid,
      state: o.state,
      validated: o.validated,
      buttons: o.buttons,
      stacked: o.stacked,
      size: o.size
    })), f = fn(c), p = vn(c);
    return l({
      blur: () => {
        i.value = false;
      },
      focus: () => {
        i.value = true;
      }
    }), (v, y) => (openBlock(), createElementBlock("div", mergeProps(unref(f), {
      id: unref(n),
      ref_key: "element",
      ref: u,
      role: "radiogroup",
      class: [unref(p), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      renderSlot(v.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(d.value, (h2) => (openBlock(), createBlock(Zn, {
        key: h2.self,
        disabled: h2.disabled,
        value: h2.value
      }, {
        default: withCtx(() => [
          h2.html ? (openBlock(), createElementBlock("span", {
            key: 0,
            innerHTML: h2.html
          }, null, 8, Ad)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(h2.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1032, ["disabled", "value"]))), 128)),
      renderSlot(v.$slots, "default")
    ], 16, Vd));
  }
});
var Od = ["value", "disabled"];
var So = defineComponent({
  __name: "BFormSelectOption",
  props: {
    disabled: { type: Boolean, default: false },
    value: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BFormSelectOption");
    return (o, a) => (openBlock(), createElementBlock("option", {
      value: unref(e).value,
      disabled: unref(e).disabled
    }, [
      renderSlot(o.$slots, "default")
    ], 8, Od));
  }
});
var Pd = ["label"];
var Ed = ["innerHTML"];
var Jn = defineComponent({
  __name: "BFormSelectOptionGroup",
  props: {
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    label: { default: void 0 },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(t4) {
    const e = G(t4, "BFormSelectOptionGroup"), { normalizedOptions: o } = mn(() => e.options, e), a = computed(() => o.value);
    return (n, r) => (openBlock(), createElementBlock("optgroup", {
      label: unref(e).label
    }, [
      renderSlot(n.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(a.value, (u, i) => (openBlock(), createBlock(So, mergeProps({
        key: i,
        disabled: u.disabled,
        value: u.value,
        ref_for: true
      }, n.$attrs), {
        default: withCtx(() => [
          u.html ? (openBlock(), createElementBlock("span", {
            key: 0,
            innerHTML: u.html
          }, null, 8, Ed)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(u.text), 1)
          ], 64))
        ]),
        _: 2
      }, 1040, ["disabled", "value"]))), 128)),
      renderSlot(n.$slots, "default")
    ], 8, Pd));
  }
});
var Fd = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"];
var Id = ["innerHTML"];
var Ld = defineComponent({
  __name: "BFormSelect",
  props: mergeModels({
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autofocus: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    modelValue: { type: [Boolean, String, Array, Object, Number, null] },
    multiple: { type: Boolean, default: false },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    selectSize: { default: 0 },
    size: { default: "md" },
    state: { type: [Boolean, null], default: null },
    textField: { default: "text" },
    valueField: { default: "value" }
  }, {
    modelValue: {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t4, { expose: l }) {
    const o = G(t4, "BFormSelect"), a = useModel(t4, "modelValue"), n = ke(() => o.id, "input"), r = _e(() => o.selectSize), u = St(() => o.state), i = ref(null), { focused: d } = Re(i, {
      initialValue: o.autofocus
    }), c = computed(() => [
      u.value,
      {
        "form-control": o.plain,
        [`form-control-${o.size}`]: o.size !== "md" && o.plain,
        "form-select": !o.plain,
        [`form-select-${o.size}`]: o.size !== "md" && !o.plain
      }
    ]), f = toRef(
      () => r.value || o.plain ? r.value : void 0
    ), p = Sa(
      () => o.ariaInvalid,
      () => o.state
    ), { normalizedOptions: v, isComplex: y } = mn(() => o.options, o), h2 = computed(
      () => v.value
    ), w = computed({
      get: () => a.value,
      set: (m) => {
        a.value = m;
      }
    });
    return l({
      blur: () => {
        d.value = false;
      },
      element: i,
      focus: () => {
        d.value = true;
      }
    }), (m, B) => withDirectives((openBlock(), createElementBlock("select", {
      id: unref(n),
      ref_key: "input",
      ref: i,
      "onUpdate:modelValue": B[0] || (B[0] = (g) => w.value = g),
      class: normalizeClass(c.value),
      name: unref(o).name,
      form: unref(o).form || void 0,
      multiple: unref(o).multiple || void 0,
      size: f.value,
      disabled: unref(o).disabled,
      required: unref(o).required || void 0,
      "aria-required": unref(o).required || void 0,
      "aria-invalid": unref(p)
    }, [
      renderSlot(m.$slots, "first"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(h2.value, (g, A) => (openBlock(), createElementBlock(Fragment, { key: A }, [
        unref(y)(g) ? (openBlock(), createBlock(Jn, {
          key: 0,
          label: g.label,
          options: g.options,
          "value-field": unref(o).valueField,
          "text-field": unref(o).textField,
          "html-field": unref(o).htmlField,
          "disabled-field": unref(o).disabledField
        }, null, 8, ["label", "options", "value-field", "text-field", "html-field", "disabled-field"])) : (openBlock(), createBlock(So, {
          key: 1,
          value: g.value,
          disabled: g.disabled
        }, {
          default: withCtx(() => [
            g.html ? (openBlock(), createElementBlock("span", {
              key: 0,
              innerHTML: g.html
            }, null, 8, Id)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(g.text), 1)
            ], 64))
          ]),
          _: 2
        }, 1032, ["value", "disabled"]))
      ], 64))), 128)),
      renderSlot(m.$slots, "default")
    ], 10, Fd)), [
      [vModelSelect, w.value]
    ]);
  }
});
var Ra = "ArrowDown";
var tl = "End";
var al = "Home";
var ol = "PageDown";
var ll = "PageUp";
var za = "ArrowUp";
var Rd = ["lang", "tabindex", "title"];
var zd = ["name", "form", "value"];
var Md = ["id", "dir", "tabindex", "aria-label", "aria-invalid", "aria-required", "aria-valuemin", "aria-valuemax", "aria-valuenow", "aria-valuetext"];
var je = {
  min: 1,
  max: 100,
  step: 1,
  repeatDelay: 500,
  repeatInterval: 100,
  repeatThreshold: 10,
  repeatMultiplier: 4
};
var Hd = defineComponent({
  __name: "BFormSpinbutton",
  props: mergeModels({
    ariaControls: { default: void 0 },
    ariaLabel: { default: void 0 },
    disabled: { type: Boolean, default: false },
    form: { default: void 0 },
    formatterFn: { type: Function, default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: false },
    labelDecrement: { default: "Decrement" },
    labelIncrement: { default: "Increment" },
    locale: { default: void 0 },
    max: { default: je.max },
    min: { default: je.min },
    modelValue: {},
    name: { default: void 0 },
    placeholder: { default: void 0 },
    readonly: { type: Boolean, default: false },
    repeatDelay: { default: je.repeatDelay },
    repeatInterval: { default: je.repeatInterval },
    repeatStepMultiplier: { default: je.repeatMultiplier },
    repeatThreshold: { default: je.repeatThreshold },
    required: { type: Boolean, default: false },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    step: { default: je.step },
    vertical: { type: Boolean, default: false },
    wrap: { type: Boolean, default: false }
  }, {
    modelValue: {
      default: null
    },
    modelModifiers: {}
  }),
  emits: mergeModels(["change"], ["update:modelValue"]),
  setup(t4, { emit: l }) {
    const e = [za, Ra, al, tl, ll, ol], a = G(t4, "BFormSpinbutton"), n = l, r = useModel(t4, "modelValue"), u = ref(null), { focused: i } = Re(u), d = ke(() => a.id, "spinbutton"), c = computed(() => ({
      disabled: a.disabled,
      readonly: a.readonly,
      focus: i.value,
      "d-inline-flex": a.inline || a.vertical,
      "d-flex": !a.inline && !a.vertical,
      "align-items-stretch": !a.vertical,
      "flex-column": a.vertical,
      [`form-control-${a.size}`]: a.size !== void 0
    })), f = computed(() => ({
      "d-flex": a.vertical,
      "align-self-center": !a.vertical,
      "align-items-center": a.vertical,
      "border-top": a.vertical,
      "border-bottom": a.vertical,
      "border-start": !a.vertical,
      "border-end": !a.vertical
    }));
    let p, v, y = false;
    const h2 = _e(() => a.step), w = toRef(
      () => Number.isNaN(h2.value) ? je.step : h2.value
    ), m = _e(() => a.min), B = toRef(
      () => Number.isNaN(m.value) ? je.min : m.value
    ), g = _e(() => a.max), A = toRef(() => {
      const J = w.value, se = B.value;
      return Math.floor((g.value - se) / J) * J + se;
    }), C = _e(() => a.repeatDelay, {
      nanToZero: true,
      method: "parseInt"
    }), V = toRef(
      () => C.value > 0 ? C.value : je.repeatDelay
    ), O = _e(() => a.repeatInterval, {
      nanToZero: true,
      method: "parseInt"
    }), Y = toRef(
      () => O.value > 0 ? O.value : je.repeatInterval
    ), U = _e(() => a.repeatThreshold, {
      nanToZero: true,
      method: "parseInt"
    }), F = toRef(
      () => Math.max(
        Number.isNaN(U.value) ? je.repeatThreshold : U.value,
        1
      )
    ), j = _e(() => a.repeatStepMultiplier, {
      nanToZero: true,
      method: "parseInt"
    }), $ = toRef(
      () => Math.max(
        Number.isNaN(j.value) ? je.repeatMultiplier : j.value,
        1
      )
    ), N = toRef(() => {
      const J = w.value;
      return Math.floor(J) === J ? 0 : (J.toString().split(".")[1] || "").length;
    }), H = toRef(() => Math.pow(10, N.value || 0)), k = toRef(
      () => r.value === null ? "" : r.value.toFixed(N.value)
    ), { isRtl: S, locale: E } = Ti(), M = computed(() => {
      const se = [(a.locale ?? (E == null ? void 0 : E.value)) || "locale"];
      return new Intl.NumberFormat(se).resolvedOptions().locale;
    }), X = () => new Intl.NumberFormat(M.value, {
      style: "decimal",
      useGrouping: false,
      minimumIntegerDigits: 1,
      minimumFractionDigits: N.value,
      maximumFractionDigits: N.value,
      notation: "standard"
    }).format, I = toRef(() => a.formatterFn ?? X()), z = (J) => {
      let { value: se } = r;
      if (!a.disabled && se !== null) {
        const Be = w.value * J, ve = B.value, pe = A.value, ye = H.value, { wrap: Te } = a;
        se = Math.round((se - ve) / Be) * Be + ve + Be, se = Math.round(se * ye) / ye, r.value = se > pe ? Te ? ve : pe : se < ve ? Te ? pe : ve : se;
      }
    }, te = (J = 1) => {
      if (r.value === null) {
        r.value = B.value;
        return;
      }
      z(1 * J);
    }, ae = (J = 1) => {
      if (r.value === null) {
        r.value = a.wrap ? A.value : B.value;
        return;
      }
      z(-1 * J);
    }, K = (J) => {
      J.preventDefault(), J.stopImmediatePropagation();
    };
    qe(
      e,
      (J) => {
        const { code: se, altKey: Be, ctrlKey: ve, metaKey: pe } = J;
        if (!(a.disabled || a.readonly || Be || ve || pe) && (K(J), !y)) {
          if (de(), [za, Ra].includes(se)) {
            if (y = true, se === za) {
              ne(J, te);
              return;
            }
            se === Ra && ne(J, ae);
            return;
          }
          if (se === ll) {
            te($.value);
            return;
          }
          if (se === ol) {
            ae($.value);
            return;
          }
          if (se === al) {
            r.value = B.value;
            return;
          }
          se === tl && (r.value = A.value);
        }
      },
      { target: u, eventName: "keydown" }
    ), qe(
      e,
      (J) => {
        const { altKey: se, ctrlKey: Be, metaKey: ve } = J;
        a.disabled || a.readonly || se || Be || ve || (K(J), de(), y = false, n("change", r.value));
      },
      { target: u, eventName: "keyup" }
    );
    const ne = (J, se) => {
      const { type: Be } = J || {};
      if (!a.disabled && !a.readonly) {
        if (re(J) && Be === "mousedown" && J.button)
          return;
        de(), se(1);
        const ve = F.value, pe = $.value, ye = V.value, Te = Y.value;
        p = setTimeout(() => {
          let Qe = 0;
          v = setInterval(() => {
            se(Qe < ve ? 1 : pe), Qe++;
          }, Te);
        }, ye);
      }
    }, re = (J) => J.type === "mouseup" || J.type === "mousedown", Q = (J) => {
      re(J) && J.type === "mouseup" && J.button || (K(J), de(), fe(false), n("change", r.value));
    }, fe = (J) => {
      try {
        Vo(J, [document.body, "mouseup", Q, false]), Vo(J, [document.body, "touchend", Q, false]);
      } catch {
      }
    }, de = () => {
      clearTimeout(p), clearInterval(v), p = void 0, v = void 0;
    }, me = computed(() => {
      const J = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-plus",
          viewBox: "0 0 16 16"
        },
        path: {
          d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
        }
      }, se = {
        svg: {
          xmlns: "http://www.w3.org/2000/svg",
          width: "16",
          height: "16",
          fill: "currentColor",
          class: "bi bi-dash",
          viewBox: "0 0 16 16"
        },
        path: { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" }
      }, Be = {
        class: [{ "py-0": !a.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
        tabindex: "-1",
        type: "button",
        disabled: a.disabled || a.readonly,
        "aria-disabled": a.disabled || a.readonly ? true : void 0,
        "aria-controls": d.value
      }, ve = {
        "aria-hidden": true,
        scale: i.value ? 1.5 : 1.25
      }, pe = (Qe, ss) => {
        !a.disabled && !a.readonly && (K(Qe), fe(true), i.value = true, ne(Qe, ss));
      }, ye = {
        button: {
          ...Be,
          "aria-label": a.labelIncrement || void 0,
          "aria-keyshortcuts": "ArrowUp"
        },
        svg: {
          ...ve,
          ...J.svg
        },
        path: {
          ...J.path
        },
        slot: {
          name: "increment"
        },
        handler: (Qe) => pe(Qe, te)
      }, Te = {
        button: {
          ...Be,
          "aria-label": a.labelDecrement || void 0,
          "aria-keyshortcuts": "ArrowDown"
        },
        svg: {
          ...ve,
          ...se.svg
        },
        path: {
          ...se.path
        },
        slot: {
          name: "decrement"
        },
        handler: (Qe) => pe(Qe, ae)
      };
      return {
        top: {
          ...a.vertical ? ye : Te
        },
        bottom: {
          ...a.vertical ? Te : ye
        }
      };
    });
    return (J, se) => (openBlock(), createElementBlock("div", {
      ref_key: "element",
      ref: u,
      class: normalizeClass(["b-form-spinbutton form-control", c.value]),
      role: "group",
      lang: M.value,
      tabindex: unref(a).disabled ? void 0 : "-1",
      title: unref(a).ariaLabel,
      onClick: se[4] || (se[4] = (Be) => i.value = true)
    }, [
      renderSlot(J.$slots, me.value.top.slot.name, { hasFocus: unref(i) }, () => [
        createBaseVNode("button", mergeProps(me.value.top.button, {
          onMousedown: se[0] || (se[0] = //@ts-ignore
          (...Be) => me.value.top.handler && me.value.top.handler(...Be)),
          onTouchstart: se[1] || (se[1] = //@ts-ignore
          (...Be) => me.value.top.handler && me.value.top.handler(...Be))
        }), [
          (openBlock(), createElementBlock("svg", normalizeProps(guardReactiveProps(me.value.top.svg)), [
            createBaseVNode("path", normalizeProps(guardReactiveProps(me.value.top.path)), null, 16)
          ], 16))
        ], 16)
      ]),
      unref(a).name && !unref(a).disabled ? (openBlock(), createElementBlock("input", {
        key: "hidden",
        type: "hidden",
        name: unref(a).name,
        form: unref(a).form,
        value: k.value
      }, null, 8, zd)) : createCommentVNode("", true),
      createBaseVNode("output", {
        id: unref(d),
        key: "output",
        class: normalizeClass(["flex-grow-1", f.value]),
        dir: unref(S) ?? false ? "rtl" : "ltr",
        tabindex: unref(a).disabled ? void 0 : "0",
        role: "spinbutton",
        "aria-live": "off",
        "aria-label": unref(a).ariaLabel || void 0,
        "aria-invalid": unref(a).state === false || !r.value !== null && unref(a).required ? true : void 0,
        "aria-required": unref(a).required ? true : void 0,
        "aria-valuemin": B.value,
        "aria-valuemax": A.value,
        "aria-valuenow": r.value !== null ? r.value : void 0,
        "aria-valuetext": r.value !== null ? I.value(r.value) : void 0
      }, [
        createBaseVNode("bdi", null, toDisplayString((r.value !== null ? I.value(r.value) : unref(a).placeholder) || ""), 1)
      ], 10, Md),
      renderSlot(J.$slots, me.value.bottom.slot.name, { hasFocus: unref(i) }, () => [
        createBaseVNode("button", mergeProps(me.value.bottom.button, {
          onMousedown: se[2] || (se[2] = //@ts-ignore
          (...Be) => me.value.bottom.handler && me.value.bottom.handler(...Be)),
          onTouchstart: se[3] || (se[3] = //@ts-ignore
          (...Be) => me.value.bottom.handler && me.value.bottom.handler(...Be))
        }), [
          (openBlock(), createElementBlock("svg", normalizeProps(guardReactiveProps(me.value.bottom.svg)), [
            createBaseVNode("path", normalizeProps(guardReactiveProps(me.value.bottom.path)), null, 16)
          ], 16))
        ], 16)
      ])
    ], 10, Rd));
  }
});
var Dd = ["id"];
var Qn = defineComponent({
  __name: "BFormTag",
  props: {
    disabled: { type: Boolean, default: false },
    id: { default: void 0 },
    noRemove: { type: Boolean, default: false },
    pill: { type: Boolean, default: false },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    title: { default: void 0 },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BFormTag"), a = l, n = useSlots(), r = ke(() => o.id), u = computed(
      () => {
        var c;
        return ((((c = n.default) == null ? void 0 : c.call(n, {})[0].children) ?? "").toString() || o.title) ?? "";
      }
    ), i = toRef(() => `${r.value}taglabel__`), d = computed(() => ({
      [`text-bg-${o.variant}`]: o.variant !== null,
      "rounded-pill": o.pill,
      disabled: o.disabled
    }));
    return (c, f) => (openBlock(), createBlock(resolveDynamicComponent(unref(o).tag), {
      id: unref(r),
      title: u.value,
      class: normalizeClass(["badge b-form-tag d-inline-flex align-items-center mw-100", d.value]),
      "aria-labelledby": i.value
    }, {
      default: withCtx(() => [
        createBaseVNode("span", {
          id: i.value,
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          renderSlot(c.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(u.value), 1)
          ])
        ], 8, Dd),
        !unref(o).disabled && !unref(o).noRemove ? (openBlock(), createBlock(zt, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": unref(o).removeLabel,
          class: "b-form-tag-remove",
          "aria-describedby": i.value,
          "aria-controls": unref(o).id,
          onClick: f[0] || (f[0] = (p) => a("remove", u.value))
        }, null, 8, ["aria-label", "aria-describedby", "aria-controls"])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
});
var jd = ["id"];
var qd = ["id", "for", "aria-live"];
var Wd = ["id", "aria-live"];
var Gd = ["id"];
var Ud = ["aria-controls"];
var Kd = {
  role: "group",
  class: "d-flex"
};
var Xd = ["id", "disabled", "value", "type", "placeholder", "form", "required", "aria-required"];
var Yd = ["disabled"];
var Zd = {
  "aria-live": "polite",
  "aria-atomic": "true"
};
var Jd = {
  key: 0,
  class: "d-block invalid-feedback"
};
var Qd = {
  key: 1,
  class: "form-text text-body-secondary"
};
var ec = {
  key: 2,
  class: "form-text text-body-secondary"
};
var tc = ["name", "value"];
var ac = defineComponent({
  __name: "BFormTags",
  props: mergeModels({
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { type: Boolean, default: false },
    autofocus: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    duplicateTagText: { default: "Duplicate tag(s)" },
    form: { default: void 0 },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: {},
    name: { default: void 0 },
    noAddOnEnter: { type: Boolean, default: false },
    noOuterFocus: { type: Boolean, default: false },
    noTagRemove: { type: Boolean, default: false },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    separator: { default: void 0 },
    size: { default: "md" },
    state: { type: [Boolean, null], default: null },
    tagClass: { default: void 0 },
    tagPills: { type: Boolean, default: false },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => true },
    tagVariant: { default: "secondary" }
  }, {
    modelValue: {
      default: () => []
    },
    modelModifiers: {}
  }),
  emits: mergeModels(["blur", "focus", "focusin", "focusout", "tag-state"], ["update:modelValue"]),
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BFormTags"), n = e, r = useModel(t4, "modelValue"), u = ke(), i = _e(() => a.limit ?? NaN), d = St(() => a.state), c = ref(null), { focused: f } = Re(c, {
      initialValue: a.autofocus
    }), p = toRef(() => a.inputId || `${u.value}input__`), v = ref([...r.value]), y = ref(""), h2 = ref(r.value.length > 0), w = ref(""), m = ref([]), B = ref([]), g = ref([]);
    Wa(r, v, {
      direction: "ltr",
      transform: {
        ltr: (I) => [...I]
      }
    });
    const A = computed(() => [
      d.value,
      {
        [`form-control-${a.size}`]: a.size !== "md",
        disabled: a.disabled,
        focus: f.value
      }
    ]), C = computed(() => v.value.includes(y.value)), V = computed(
      () => y.value === "" ? false : !a.tagValidator(y.value)
    ), O = toRef(() => v.value.length === i.value), Y = toRef(() => !V.value && !C.value), U = computed(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: M,
      disableAddButton: Y.value,
      disabled: a.disabled,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: g.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: a.disabled,
        form: a.form,
        id: p,
        value: y
      },
      inputHandlers: {
        input: N,
        keydown: k,
        change: H
      },
      inputId: p,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: B.value,
      isDuplicate: C.value,
      isInvalid: V.value,
      isLimitReached: O.value,
      limitTagsText: a.limitTagsText,
      limit: i.value,
      noTagRemove: a.noTagRemove,
      placeholder: a.placeholder,
      removeTag: X,
      required: a.required,
      separator: a.separator,
      size: a.size,
      state: a.state,
      tagClass: a.tagClass,
      tagPills: a.tagPills,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: v.value
    })), F = (I) => {
      if (a.disabled) {
        I.target.blur();
        return;
      }
      n("focusin", I);
    }, j = (I) => {
      a.disabled || a.noOuterFocus || (f.value = true, n("focus", I));
    }, $ = (I) => {
      f.value = false, n("blur", I);
    }, N = (I) => {
      var te, ae;
      const z = typeof I == "string" ? I : I.target.value;
      if (h2.value = false, (te = a.separator) != null && te.includes(z.charAt(0)) && z.length > 0) {
        c.value && (c.value.value = "");
        return;
      }
      if (y.value = z, (ae = a.separator) != null && ae.includes(z.charAt(z.length - 1))) {
        M(z.slice(0, z.length - 1));
        return;
      }
      m.value = a.tagValidator(z) && !C.value ? [z] : [], B.value = a.tagValidator(z) ? [] : [z], g.value = C.value ? [z] : [], n("tag-state", m.value, B.value, g.value);
    }, H = (I) => {
      a.addOnChange && (N(I), C.value || M(y.value));
    }, k = (I) => {
      if (I.key === "Enter" && !a.noAddOnEnter) {
        M(y.value);
        return;
      }
      (I.key === "Backspace" || I.key === "Delete") && a.removeOnDelete && y.value === "" && h2.value && v.value.length > 0 ? X(v.value[v.value.length - 1]) : h2.value = true;
    };
    qe(k, { target: c });
    const S = computed(() => {
      if (a.separator)
        return typeof a.separator == "string" ? a.separator : a.separator.join("");
    }), E = computed(() => {
      if (S.value)
        return new RegExp(`[${fi(S.value)}]+`);
    }), M = (I) => {
      I = (I ?? y.value).trim();
      const z = E.value ? I.split(E.value).map((K) => K.trim()) : [I], te = [];
      for (const K of z)
        if (!(K === "" || C.value || !a.tagValidator(K))) {
          if (i.value && O.value)
            break;
          te.push(K);
        }
      const ae = [...r.value, ...te];
      y.value = "", h2.value = true, r.value = ae, f.value = true;
    }, X = (I) => {
      const z = v.value.indexOf((I == null ? void 0 : I.toString()) ?? "");
      z !== -1 && (w.value = v.value.splice(z, 1).toString(), r.value = v.value);
    };
    return l({
      blur: () => {
        f.value = false;
      },
      element: c,
      focus: () => {
        f.value = true;
      }
    }), (I, z) => (openBlock(), createElementBlock("div", {
      id: unref(u),
      class: normalizeClass(["b-form-tags form-control h-auto", A.value]),
      role: "group",
      tabindex: "-1",
      onFocusin: F,
      onFocusout: z[1] || (z[1] = (te) => n("focusout", te))
    }, [
      createBaseVNode("output", {
        id: `${unref(u)}selected_tags__`,
        class: "visually-hidden",
        for: p.value,
        "aria-live": unref(f) ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, toDisplayString(v.value.join(", ")), 9, qd),
      createBaseVNode("div", {
        id: `${unref(u)}removed_tags__`,
        role: "status",
        "aria-live": unref(f) ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + toDisplayString(unref(a).tagRemovedLabel) + ") " + toDisplayString(w.value), 9, Wd),
      renderSlot(I.$slots, "default", normalizeProps(guardReactiveProps(U.value)), () => [
        createBaseVNode("ul", {
          id: `${unref(u)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(v.value, (te, ae) => renderSlot(I.$slots, "tag", {
            key: ae,
            tag: te,
            tagClass: unref(a).tagClass,
            tagVariant: unref(a).tagVariant,
            tagPills: unref(a).tagPills,
            removeTag: X
          }, () => [
            (openBlock(), createBlock(Qn, {
              key: te,
              class: normalizeClass(unref(a).tagClass),
              tag: "li",
              variant: unref(a).tagVariant,
              pill: unref(a).tagPills,
              onRemove: X
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(te), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          createBaseVNode("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${unref(u)}tag_list__`
          }, [
            createBaseVNode("div", Kd, [
              createBaseVNode("input", mergeProps({
                id: p.value,
                ref_key: "input",
                ref: c,
                disabled: unref(a).disabled,
                value: y.value,
                type: unref(a).inputType,
                placeholder: unref(a).placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, unref(a).inputAttrs, {
                form: unref(a).form,
                required: unref(a).required || void 0,
                "aria-required": unref(a).required || void 0,
                onInput: N,
                onChange: H,
                onFocus: j,
                onBlur: $
              }), null, 16, Xd),
              Y.value ? (openBlock(), createElementBlock("button", {
                key: 0,
                type: "button",
                class: normalizeClass(["btn b-form-tags-button py-0", [
                  I.inputClass,
                  {
                    [`btn-${unref(a).addButtonVariant}`]: unref(a).addButtonVariant !== null,
                    "disabled invisible": y.value.length === 0
                  }
                ]]),
                style: { "font-size": "90%" },
                disabled: unref(a).disabled || y.value.length === 0 || O.value,
                onClick: z[0] || (z[0] = (te) => M(y.value))
              }, [
                renderSlot(I.$slots, "add-button-text", {}, () => [
                  createTextVNode(toDisplayString(unref(a).addButtonText), 1)
                ])
              ], 10, Yd)) : createCommentVNode("", true)
            ])
          ], 8, Ud)
        ], 8, Gd),
        createBaseVNode("div", Zd, [
          V.value ? (openBlock(), createElementBlock("div", Jd, toDisplayString(unref(a).invalidTagText) + ": " + toDisplayString(y.value), 1)) : createCommentVNode("", true),
          C.value ? (openBlock(), createElementBlock("small", Qd, toDisplayString(unref(a).duplicateTagText) + ": " + toDisplayString(y.value), 1)) : createCommentVNode("", true),
          v.value.length === unref(a).limit ? (openBlock(), createElementBlock("small", ec, toDisplayString(unref(a).limitTagsText), 1)) : createCommentVNode("", true)
        ])
      ]),
      unref(a).name ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(v.value, (te, ae) => (openBlock(), createElementBlock("input", {
        key: ae,
        type: "hidden",
        name: unref(a).name,
        value: te
      }, null, 8, tc))), 128)) : createCommentVNode("", true)
    ], 42, jd));
  }
});
var oc = ["id", "name", "form", "value", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"];
var lc = defineComponent({
  __name: "BFormTextarea",
  props: mergeModels({
    noResize: { type: Boolean, default: false },
    rows: { default: 2 },
    wrap: { default: "soft" },
    ariaInvalid: { type: [Boolean, String], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazyFormatter: { type: Boolean, default: false },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    placeholder: { default: void 0 },
    plaintext: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    required: { type: Boolean, default: false },
    size: { default: void 0 },
    state: { type: [Boolean, null], default: null },
    debounce: { default: 0 },
    debounceMaxWait: { default: NaN }
  }, {
    modelValue: {
      default: ""
    },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t4, { expose: l }) {
    const o = G(t4, "BFormTextarea"), [a, n] = useModel(t4, "modelValue", {
      set: (m) => {
        if (m === null)
          return;
        let B = m;
        if (n.trim && (B = B.toString().trim()), n.number && typeof B == "string" && B !== "") {
          const g = Number.parseFloat(B);
          B = Number.isNaN(g) ? B : g;
        }
        return B;
      }
    }), { input: r, computedId: u, computedAriaInvalid: i, onInput: d, onChange: c, onBlur: f, focus: p, blur: v } = pn(o, a, n), y = St(() => o.state), h2 = computed(() => [
      y.value,
      o.plaintext ? "form-control-plaintext" : "form-control",
      {
        [`form-control-${o.size}`]: !!o.size
      }
    ]), w = computed(() => ({
      resize: o.noResize ? "none" : void 0
    }));
    return l({
      blur: v,
      element: r,
      focus: p
    }), (m, B) => (openBlock(), createElementBlock("textarea", {
      id: unref(u),
      ref_key: "input",
      ref: r,
      class: normalizeClass(h2.value),
      name: unref(o).name || void 0,
      form: unref(o).form || void 0,
      value: unref(a) ?? void 0,
      disabled: unref(o).disabled,
      placeholder: unref(o).placeholder,
      required: unref(o).required || void 0,
      autocomplete: unref(o).autocomplete || void 0,
      readonly: unref(o).readonly || unref(o).plaintext,
      "aria-required": unref(o).required || void 0,
      "aria-invalid": unref(i),
      rows: unref(o).rows,
      style: normalizeStyle(w.value),
      wrap: unref(o).wrap || void 0,
      onInput: B[0] || (B[0] = (g) => unref(d)(g)),
      onChange: B[1] || (B[1] = (g) => unref(c)(g)),
      onBlur: B[2] || (B[2] = (g) => unref(f)(g))
    }, null, 46, oc));
  }
});
var nc = {
  key: 0,
  class: "input-group-text"
};
var sc = ["innerHTML"];
var rc = { key: 1 };
var ic = {
  key: 0,
  class: "input-group-text"
};
var uc = ["innerHTML"];
var dc = { key: 1 };
var cc = defineComponent({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: "md" },
    tag: { default: "div" }
  },
  setup(t4) {
    provide(on, true);
    const e = G(t4, "BInputGroup"), o = computed(() => ({
      [`input-group-${e.size}`]: e.size !== "md"
    })), a = toRef(() => !!e.append || !!e.appendHtml), n = toRef(() => !!e.prepend || !!e.prependHtml);
    return (r, u) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      id: unref(e).id,
      class: normalizeClass(["input-group", o.value]),
      role: "group"
    }, {
      default: withCtx(() => [
        renderSlot(r.$slots, "prepend", {}, () => [
          n.value ? (openBlock(), createElementBlock("span", nc, [
            unref(e).prependHtml ? (openBlock(), createElementBlock("span", {
              key: 0,
              innerHTML: unref(e).prependHtml
            }, null, 8, sc)) : (openBlock(), createElementBlock("span", rc, toDisplayString(unref(e).prepend), 1))
          ])) : createCommentVNode("", true)
        ]),
        renderSlot(r.$slots, "default"),
        renderSlot(r.$slots, "append", {}, () => [
          a.value ? (openBlock(), createElementBlock("span", ic, [
            unref(e).appendHtml ? (openBlock(), createElementBlock("span", {
              key: 0,
              innerHTML: unref(e).appendHtml
            }, null, 8, uc)) : (openBlock(), createElementBlock("span", dc, toDisplayString(unref(e).append), 1))
          ])) : createCommentVNode("", true)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
});
var fc = defineComponent({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BInputGroupText");
    return (o, a) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), { class: "input-group-text" }, {
      default: withCtx(() => [
        renderSlot(o.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(unref(e).text), 1)
        ])
      ]),
      _: 3
    }));
  }
});
var vc = defineComponent({
  __name: "BListGroup",
  props: {
    flush: { type: Boolean, default: false },
    horizontal: { type: [Boolean, String], default: false },
    numbered: { type: Boolean, default: false },
    tag: { default: "div" }
  },
  setup(t4) {
    const e = G(t4, "BListGroup"), o = computed(() => {
      const n = e.flush ? false : e.horizontal;
      return {
        "list-group-flush": e.flush,
        "list-group-horizontal": n === true,
        [`list-group-horizontal-${n}`]: typeof n == "string",
        "list-group-numbered": e.numbered
      };
    }), a = toRef(() => e.numbered === true ? "ol" : e.tag);
    return provide(Wl, {
      numbered: toRef(() => e.numbered)
    }), (n, r) => (openBlock(), createBlock(resolveDynamicComponent(a.value), {
      class: normalizeClass(["list-group", o.value])
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var pc = defineComponent({
  __name: "BListGroupItem",
  props: {
    action: { type: Boolean, default: false },
    button: { type: Boolean, default: false },
    tag: { default: "div" },
    active: { type: Boolean, default: false },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: false },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  setup(t4) {
    const e = G(t4, "BListGroupItem"), o = useAttrs(), a = inject(Wl, null), { computedLink: n } = Tt(e), r = toRef(() => !e.button && n.value), u = toRef(
      () => a != null && a.numbered.value ? "li" : e.button ? "button" : r.value ? it : e.tag
    ), i = computed(
      () => e.action || r.value || e.button || ["a", "router-link", "button", "b-link"].includes(e.tag)
    ), d = computed(() => ({
      [`list-group-item-${e.variant}`]: e.variant !== null && e.variant !== void 0,
      "list-group-item-action": i.value,
      active: e.active,
      disabled: e.disabled
    })), c = computed(() => {
      const f = {};
      return e.button && ((!o || !o.type) && (f.type = "button"), e.disabled && (f.disabled = true)), f;
    });
    return (f, p) => (openBlock(), createBlock(resolveDynamicComponent(u.value), mergeProps({
      class: ["list-group-item", d.value],
      "aria-current": unref(e).active ? true : void 0,
      "aria-disabled": unref(e).disabled ? true : void 0,
      target: r.value ? unref(e).target : void 0,
      href: unref(e).button ? void 0 : unref(e).href,
      to: unref(e).button ? void 0 : unref(e).to
    }, c.value), {
      default: withCtx(() => [
        renderSlot(f.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
});
var mc = { id: "__BVID__modal-container" };
var bc = defineComponent({
  __name: "BModalOrchestrator",
  props: {
    teleportDisabled: { default: false },
    teleportTo: { default: "body" }
  },
  setup(t4, { expose: l }) {
    const o = G(t4, "BModalOrchestrator"), { modals: a, remove: n, show: r, confirm: u, leave: i } = bn(), d = (c) => $a(c, ["_promise", "_self", "_isConfirm", "_modelValue"]);
    return l({
      modals: a,
      show: r,
      confirm: u
    }), (c, f) => (openBlock(), createBlock(Teleport, {
      to: unref(o).teleportTo,
      disabled: unref(o).teleportDisabled
    }, [
      createBaseVNode("div", mc, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(a), (p, v) => (openBlock(), createBlock(resolveDynamicComponent(p.value.component), mergeProps({
          key: v,
          modelValue: p.value.props._modelValue,
          "onUpdate:modelValue": (y) => p.value.props._modelValue = y,
          ref_for: true
        }, d(p.value.props), {
          "teleport-disabled": true,
          "onUpdate:modelValue": (y) => {
            var h2;
            return (h2 = unref(i)) == null ? void 0 : h2(p.value.props._self);
          },
          onHide: (y) => {
            if (p.value.props._isConfirm === true) {
              if (y.trigger === "ok") {
                p.value.props._promise.resolve(true);
                return;
              }
              if (y.trigger === "cancel") {
                p.value.props._promise.resolve(false);
                return;
              }
              p.value.props._promise.resolve(null);
            }
            p.value.props._promise.resolve(true);
          },
          onHidden: (y) => {
            var h2;
            return (h2 = unref(n)) == null ? void 0 : h2(p.value.props._self);
          }
        }), null, 16, ["modelValue", "onUpdate:modelValue", "onHide", "onHidden"]))), 128))
      ])
    ], 8, ["to", "disabled"]));
  }
});
var yc = defineComponent({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { type: Boolean, default: false },
    fill: { type: Boolean, default: false },
    justified: { type: Boolean, default: false },
    pills: { type: Boolean, default: false },
    small: { type: Boolean, default: false },
    tabs: { type: Boolean, default: false },
    tag: { default: "ul" },
    underline: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false }
  },
  setup(t4) {
    const e = G(t4, "BNav"), o = Xt(() => e.align), a = computed(() => ({
      "nav-tabs": e.tabs,
      "nav-pills": e.pills && !e.tabs,
      "card-header-tabs": !e.vertical && e.cardHeader && e.tabs,
      "card-header-pills": !e.vertical && e.cardHeader && e.pills && !e.tabs,
      "flex-column": e.vertical,
      "nav-fill": !e.vertical && e.fill,
      "nav-justified": !e.vertical && e.justified,
      [o.value]: !e.vertical && e.align !== void 0,
      small: e.small,
      "nav-underline": e.underline
    }));
    return (n, r) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(["nav", a.value])
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var gc = { class: "d-flex flex-row align-items-center flex-wrap" };
var hc = defineComponent({
  inheritAttrs: false,
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    floating: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    novalidate: { type: Boolean, default: void 0 },
    validated: { type: Boolean, default: void 0 }
  },
  emits: ["submit"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BNavForm"), a = l, n = (r) => {
      a("submit", r);
    };
    return (r, u) => (openBlock(), createElementBlock("li", gc, [
      createVNode(Kn, mergeProps(r.$attrs, {
        id: unref(o).id,
        floating: unref(o).floating,
        role: unref(o).role,
        novalidate: unref(o).novalidate,
        validated: unref(o).validated,
        class: "d-flex",
        onSubmit: withModifiers(n, ["prevent"])
      }), {
        default: withCtx(() => [
          renderSlot(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["id", "floating", "role", "novalidate", "validated"])
    ]));
  }
});
var Bc = { class: "nav-item" };
var _c = defineComponent({
  __name: "BNavItem",
  props: {
    linkAttrs: { default: void 0 },
    linkClass: { default: void 0 },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: false },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  emits: ["click"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BNavItem"), a = l, n = computed(
      () => _o(o, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "icon",
        "opacity",
        "opacityHover",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "underlineVariant",
        "variant"
      ])
    );
    return n.value.activeClass, (r, u) => (openBlock(), createElementBlock("li", Bc, [
      createVNode(it, mergeProps({
        class: ["nav-link", r.linkClass],
        tabindex: unref(o).disabled ? -1 : void 0,
        "aria-disabled": unref(o).disabled ? true : void 0
      }, { ...n.value, ...r.linkAttrs }, {
        onClick: u[0] || (u[0] = (i) => a("click", i))
      }), {
        default: withCtx(() => [
          renderSlot(r.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "tabindex", "aria-disabled"])
    ]));
  }
});
var wc = { class: "nav-item dropdown" };
var Cc = defineComponent({
  __name: "BNavItemDropdown",
  props: mergeModels({
    ariaLabel: { default: void 0 },
    autoClose: { type: [Boolean, String], default: true },
    boundary: { default: "clippingAncestors" },
    boundaryPadding: { default: void 0 },
    center: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    dropend: { type: Boolean, default: false },
    dropstart: { type: Boolean, default: false },
    dropup: { type: Boolean, default: false },
    end: { type: Boolean, default: false },
    floatingMiddleware: { default: void 0 },
    id: { default: void 0 },
    isNav: { type: Boolean, default: true },
    lazy: { type: Boolean, default: false },
    menuClass: { default: void 0 },
    modelValue: { type: Boolean },
    noCaret: { type: Boolean, default: false },
    noFlip: { type: Boolean, default: false },
    noShift: { type: Boolean, default: false },
    noSize: { type: Boolean, default: false },
    offset: { default: 0 },
    role: { default: "menu" },
    size: { default: "md" },
    skipWrapper: { type: Boolean },
    split: { type: Boolean, default: false },
    splitButtonType: { default: "button" },
    splitClass: { default: void 0 },
    splitDisabled: { type: Boolean, default: void 0 },
    splitHref: { default: void 0 },
    splitTo: { default: void 0 },
    splitVariant: { default: void 0 },
    strategy: { default: "absolute" },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "link" },
    wrapperClass: {},
    teleportDisabled: { default: false },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: false },
    modelModifiers: {}
  }),
  emits: mergeModels(["click", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown", "toggle"], ["update:modelValue"]),
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BNavItemDropdown"), n = e, r = useModel(t4, "modelValue"), u = ref(null), i = () => {
      var f;
      (f = u.value) == null || f.hide();
    }, d = () => {
      var f;
      (f = u.value) == null || f.show();
    };
    return l({
      hide: i,
      show: d,
      toggle: () => {
        var f;
        (f = u.value) == null || f.toggle();
      }
    }), (f, p) => (openBlock(), createElementBlock("li", wc, [
      createVNode(Un, mergeProps({
        ref_key: "dropdown",
        ref: u
      }, unref(a), {
        modelValue: r.value,
        "onUpdate:modelValue": p[0] || (p[0] = (v) => r.value = v),
        "is-nav": "",
        onShow: p[1] || (p[1] = (v) => n("show", v)),
        onShown: p[2] || (p[2] = (v) => n("shown")),
        onHide: p[3] || (p[3] = (v) => n("hide", v)),
        onHidden: p[4] || (p[4] = (v) => n("hidden")),
        onHidePrevented: p[5] || (p[5] = (v) => n("hide-prevented")),
        onShowPrevented: p[6] || (p[6] = (v) => n("show-prevented")),
        onClick: p[7] || (p[7] = (v) => n("click", v)),
        onToggle: p[8] || (p[8] = (v) => n("toggle"))
      }), {
        "button-content": withCtx(() => [
          renderSlot(f.$slots, "button-content")
        ]),
        "toggle-text": withCtx(() => [
          renderSlot(f.$slots, "toggle-text")
        ]),
        default: withCtx(() => [
          renderSlot(f.$slots, "default", {
            hide: i,
            show: d
          })
        ]),
        _: 3
      }, 16, ["modelValue"])
    ]));
  }
});
var kc = { class: "navbar-text" };
var Tc = defineComponent({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BNavText");
    return (o, a) => (openBlock(), createElementBlock("li", kc, [
      renderSlot(o.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(unref(e).text), 1)
      ])
    ]));
  }
});
var Sc = defineComponent({
  __name: "BNavbar",
  props: {
    autoClose: { type: Boolean, default: true },
    container: { type: [Boolean, String], default: "fluid" },
    fixed: { default: void 0 },
    print: { type: Boolean, default: false },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: false },
    variant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BNavbar"), o = toRef(() => e.tag === "nav" ? void 0 : "navigation"), a = yi(() => e.container), n = computed(() => ({
      "d-print": e.print,
      [`sticky-${e.sticky}`]: e.sticky !== void 0,
      [`bg-${e.variant}`]: e.variant !== null,
      [`fixed-${e.fixed}`]: e.fixed !== void 0,
      "navbar-expand": e.toggleable === false,
      [`navbar-expand-${e.toggleable}`]: typeof e.toggleable == "string"
    }));
    return provide(Bo, {
      tag: toRef(() => e.tag),
      autoClose: toRef(() => e.autoClose)
    }), (r, u) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(["navbar", n.value]),
      role: o.value
    }, {
      default: withCtx(() => [
        unref(e).container !== false ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(a))
        }, [
          renderSlot(r.$slots, "default")
        ], 2)) : renderSlot(r.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
});
var xc = defineComponent({
  __name: "BNavbarBrand",
  props: {
    tag: { default: "div" },
    active: { type: Boolean, default: void 0 },
    activeClass: { default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    exactActiveClass: { default: void 0 },
    href: { default: void 0 },
    icon: { type: Boolean, default: void 0 },
    stretched: { type: Boolean, default: false },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: Boolean, default: void 0 },
    routerComponentName: { default: void 0 },
    target: { default: void 0 },
    to: { default: void 0 },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    underlineVariant: { default: void 0 },
    variant: { default: void 0 },
    prefetch: { type: Boolean },
    noPrefetch: { type: Boolean },
    prefetchedClass: {},
    noRel: { type: Boolean }
  },
  setup(t4) {
    const e = G(t4, "BNavbarBrand"), { computedLink: o, computedLinkProps: a } = Tt(e, [
      "active",
      "activeClass",
      "append",
      "disabled",
      "href",
      "rel",
      "replace",
      "routerComponentName",
      "target",
      "to",
      "variant",
      "opacity",
      "opacityHover",
      "underlineVariant",
      "underlineOffset",
      "underlineOffsetHover",
      "underlineOpacity",
      "underlineOpacityHover",
      "icon"
    ]), n = toRef(() => o.value ? it : e.tag);
    return (r, u) => (openBlock(), createBlock(resolveDynamicComponent(n.value), mergeProps({ class: "navbar-brand" }, unref(a)), {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
var $c = defineComponent({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { type: Boolean, default: false },
    justified: { type: Boolean, default: false },
    small: { type: Boolean, default: false },
    tag: { default: "ul" }
  },
  setup(t4) {
    const e = G(t4, "BNavbarNav"), o = Xt(() => e.align), a = computed(() => ({
      "nav-fill": e.fill,
      "nav-justified": e.justified,
      [o.value]: e.align !== void 0,
      small: e.small
    }));
    return (n, r) => (openBlock(), createElementBlock("ul", {
      class: normalizeClass(["navbar-nav", a.value])
    }, [
      renderSlot(n.$slots, "default")
    ], 2));
  }
});
var nl = (t4, l) => t4.setAttribute("data-bs-theme", l);
var Vc = {
  mounted(t4, l) {
    nl(t4, l.value);
  },
  updated(t4, l) {
    nl(t4, l.value);
  }
};
var Ac = (t4, l) => {
  const { modifiers: e, arg: o, value: a } = t4, n = Object.keys(e || {}), r = typeof a == "string" ? a.split(na) : a;
  if (l.tagName.toLowerCase() === "a") {
    const u = l.getAttribute("href") || "";
    ri.test(u) && n.push(u.replace(si, ""));
  }
  return Array.prototype.concat.apply([], [o, r]).forEach((u) => typeof u == "string" && n.push(u)), n.filter((u, i, d) => u && d.indexOf(u) === i);
};
var Nc = (t4, l) => {
  t4.forEach((e) => {
    const o = document.getElementById(e);
    o !== null && o.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => es(t4, l), 50);
};
var es = (t4, l) => {
  let e = false;
  t4.forEach((o) => {
    const a = document.getElementById(o);
    a != null && a.classList.contains("show") && (e = true), a != null && a.classList.contains("closing") && (e = false);
  }), l.setAttribute("aria-expanded", e ? "true" : "false"), l.classList.remove(e ? "collapsed" : "not-collapsed"), l.classList.add(e ? "not-collapsed" : "collapsed");
};
var sl = (t4, l) => {
  const e = Ac(l, t4);
  e.length !== 0 && (t4.__toggle && t4.removeEventListener("click", t4.__toggle), t4.__toggle = () => Nc(e, t4), t4.addEventListener("click", t4.__toggle), t4.setAttribute("aria-controls", e.join(" ")), es(e, t4));
};
var Ja = {
  mounted: sl,
  updated: sl,
  unmounted(t4) {
    t4.removeEventListener("click", t4.__toggle), t4.removeAttribute("aria-controls"), t4.removeAttribute("aria-expanded");
  }
};
var Oc = {
  mounted(t4, l) {
    if (!Gt(l.value))
      return;
    const o = ma(l.value, t4);
    !o.content && !o.title || ya(t4, l, {
      ...ba(l, t4),
      ...o
    });
  },
  updated(t4, l) {
    if (!Gt(l.value))
      return;
    const o = ma(l.value, t4);
    !o.content && !o.title || (ga(t4), ya(t4, l, {
      ...ba(l, t4),
      ...o
    }));
  },
  beforeUnmount(t4) {
    ga(t4);
  }
};
var rl = (t4, l) => {
  t4.$__scrollspy && t4.$__scrollspy.cleanup();
  const { arg: e, value: o } = l, a = typeof o == "object" && o !== null, n = e || (typeof o == "string" ? o : a ? o.content || o.element : null);
  t4.$__scrollspy = gn(n, t4, a ? $a(o, ["content", "element"]) : {});
};
var Pc = {
  mounted: rl,
  updated: rl,
  beforeUnmount(t4) {
    t4.$__scrollspy && t4.$__scrollspy.cleanup();
  }
};
var Ec = {
  mounted(t4, l) {
    const e = Gt(l.value);
    if (!e)
      return;
    const o = ma(l.value, t4);
    !o.content && !o.title || ya(t4, l, {
      noninteractive: true,
      ...ba(l, t4),
      title: o.title ?? o.content ?? "",
      tooltip: e
    });
  },
  updated(t4, l) {
    const e = Gt(l.value);
    if (!e)
      return;
    const o = ma(l.value, t4);
    !o.content && !o.title || (ga(t4), ya(t4, l, {
      noninteractive: true,
      ...ba(l, t4),
      title: o.title ?? o.content ?? "",
      tooltip: e
    }));
  },
  beforeUnmount(t4) {
    ga(t4);
  }
};
var Qa = Object.freeze(Object.defineProperty({
  __proto__: null,
  vBColorMode: Vc,
  vBModal: Ja,
  vBPopover: Oc,
  vBScrollspy: Pc,
  vBToggle: Ja,
  vBTooltip: Ec
}, Symbol.toStringTag, { value: "Module" }));
var Fc = ["disabled", "aria-label"];
var Ic = createBaseVNode("span", { class: "navbar-toggler-icon" }, null, -1);
var Lc = defineComponent({
  __name: "BNavbarToggle",
  props: {
    disabled: { type: Boolean, default: false },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BNavbarToggle"), a = l, n = computed(() => ({
      disabled: o.disabled
    })), r = (u) => {
      o.disabled || a("click", u);
    };
    return (u, i) => withDirectives((openBlock(), createElementBlock("button", {
      class: normalizeClass(["navbar-toggler", n.value]),
      type: "button",
      disabled: unref(o).disabled,
      "aria-label": unref(o).label,
      onClick: r
    }, [
      renderSlot(u.$slots, "default", {}, () => [
        Ic
      ])
    ], 10, Fc)), [
      [unref(Ja), unref(o).disabled ? void 0 : unref(o).target]
    ]);
  }
});
var Rc = ["id", "aria-labelledby"];
var zc = ["id"];
var Mc = defineComponent({
  inheritAttrs: false,
  __name: "BOffcanvas",
  props: mergeModels({
    backdrop: { type: Boolean, default: true },
    backdropBlur: { default: void 0 },
    backdropVariant: { default: "dark" },
    bodyAttrs: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyScrolling: { type: Boolean, default: false },
    footerClass: { default: void 0 },
    headerClass: { default: void 0 },
    headerCloseClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseVariant: { default: "secondary" },
    id: { default: void 0 },
    lazy: { type: Boolean, default: false },
    modelValue: { type: Boolean },
    noCloseOnBackdrop: { type: Boolean, default: false },
    noCloseOnEsc: { type: Boolean, default: false },
    noFocus: { type: Boolean, default: false },
    noHeader: { type: Boolean, default: false },
    noHeaderClose: { type: Boolean, default: false },
    placement: { default: "start" },
    shadow: { type: [String, Boolean], default: false },
    title: { default: void 0 },
    responsive: {},
    width: { default: void 0 },
    teleportDisabled: { default: false },
    teleportTo: { default: "body" }
  }, {
    modelValue: { type: Boolean, default: false },
    modelModifiers: {}
  }),
  emits: mergeModels(["close", "esc", "hidden", "hide", "hide-prevented", "show", "show-prevented", "shown"], ["update:modelValue"]),
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BOffcanvas"), n = e, r = useSlots(), u = useModel(t4, "modelValue"), i = ke(() => a.id, "offcanvas"), d = Fr(Er), c = d.greaterOrEqual(() => a.responsive ?? "xs"), f = d.smallerOrEqual(() => a.responsive ?? "xs"), p = computed(
      () => a.responsive !== void 0 && c.value
    );
    yn(u, () => a.bodyScrolling || p.value);
    const v = ref(null);
    qe(
      "Escape",
      () => {
        N("esc");
      },
      { target: v }
    );
    const { focused: y } = Re(v, {
      initialValue: u.value && a.noFocus === false
    }), h2 = ref(u.value), w = ref(false), m = ref(false), B = toRef(() => a.backdrop === true && u.value === true), g = toRef(
      () => a.lazy === false || a.lazy === true && w.value === true || a.lazy === true && u.value === true
    ), A = toRef(() => !Ne(r["header-close"])), C = computed(() => [
      { "text-reset": !A.value },
      a.headerCloseClass
    ]), V = computed(() => ({
      variant: A.value ? a.headerCloseVariant : void 0,
      class: C.value
    })), O = computed(
      () => m.value === true ? null : {
        enterToClass: "showing",
        enterFromClass: "",
        leaveToClass: "hiding show",
        leaveFromClass: "show"
      }
    ), Y = toRef(() => !Ne(r.footer)), U = computed(() => [
      a.responsive === void 0 ? "offcanvas" : `offcanvas-${a.responsive}`,
      `offcanvas-${a.placement}`,
      {
        show: u.value && h2.value === true,
        [`shadow-${a.shadow}`]: !!a.shadow
      }
    ]), F = computed(() => ({
      width: a.width
    })), j = computed(() => ({
      visible: u.value,
      placement: a.placement,
      hide: N
    })), $ = (I, z = {}) => new Ct(I, {
      cancelable: false,
      target: v.value || null,
      relatedTarget: null,
      trigger: null,
      ...z,
      componentId: i.value
    }), N = (I = "") => {
      if (I === "backdrop" && a.noCloseOnBackdrop || I === "esc" && a.noCloseOnEsc) {
        n("hide-prevented");
        return;
      }
      const z = $("hide", { cancelable: I !== "", trigger: I });
      if (I === "close" && n(I, z), I === "esc" && n(I, z), n("hide", z), z.defaultPrevented) {
        n("hide-prevented");
        return;
      }
      u.value = false;
    }, H = () => {
      const I = $("show", { cancelable: true });
      if (n("show", I), I.defaultPrevented) {
        u.value = false, n("show-prevented");
        return;
      }
      u.value = true;
    }, k = () => {
      nextTick(() => {
        a.noFocus === false && (y.value = true);
      });
    }, S = () => H(), E = () => {
      h2.value = true, k(), n("shown", $("shown")), a.lazy === true && (w.value = true);
    }, M = () => {
      m.value = false, h2.value = false;
    }, X = () => {
      n("hidden", $("hidden")), a.lazy === true && (w.value = false);
    };
    return Ve(v, "bv-toggle", () => {
      u.value ? N() : H();
    }), watch(c, (I) => {
      a.responsive !== void 0 && (u.value = I);
    }), watch(f, (I) => {
      a.responsive === void 0 && I === true || (m.value = true);
    }), l({
      hide: N,
      show: H
    }), (I, z) => (openBlock(), createBlock(Teleport, {
      to: unref(a).teleportTo,
      disabled: unref(a).teleportDisabled || p.value
    }, [
      createVNode(Transition, mergeProps(O.value, {
        onBeforeEnter: S,
        onAfterEnter: E,
        onLeave: M,
        onAfterLeave: X
      }), {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", mergeProps({
            id: unref(i),
            ref_key: "element",
            ref: v,
            "aria-modal": "true",
            role: "dialog",
            class: U.value,
            style: F.value,
            tabindex: "-1",
            "aria-labelledby": `${unref(i)}-offcanvas-label`,
            "data-bs-backdrop": "false"
          }, I.$attrs), [
            g.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              unref(a).noHeader ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(["offcanvas-header", unref(a).headerClass])
              }, [
                renderSlot(I.$slots, "header", normalizeProps(guardReactiveProps(j.value)), () => [
                  createBaseVNode("h5", {
                    id: `${unref(i)}-offcanvas-label`,
                    class: "offcanvas-title"
                  }, [
                    renderSlot(I.$slots, "title", normalizeProps(guardReactiveProps(j.value)), () => [
                      createTextVNode(toDisplayString(unref(a).title), 1)
                    ])
                  ], 8, zc),
                  unref(a).noHeaderClose ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    A.value ? (openBlock(), createBlock(vt, mergeProps({ key: 0 }, V.value, {
                      onClick: z[0] || (z[0] = (te) => N("close"))
                    }), {
                      default: withCtx(() => [
                        renderSlot(I.$slots, "header-close")
                      ]),
                      _: 3
                    }, 16)) : (openBlock(), createBlock(zt, mergeProps({
                      key: 1,
                      "aria-label": unref(a).headerCloseLabel
                    }, V.value, {
                      onClick: z[1] || (z[1] = (te) => N("close"))
                    }), null, 16, ["aria-label"]))
                  ], 64))
                ])
              ], 2)),
              createBaseVNode("div", mergeProps({
                class: ["offcanvas-body", unref(a).bodyClass]
              }, unref(a).bodyAttrs), [
                renderSlot(I.$slots, "default", normalizeProps(guardReactiveProps(j.value)))
              ], 16),
              Y.value ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(a).footerClass)
              }, [
                renderSlot(I.$slots, "footer", normalizeProps(guardReactiveProps(j.value)))
              ], 2)) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true)
          ], 16, Rc), [
            [vShow, u.value || p.value]
          ])
        ]),
        _: 3
      }, 16),
      unref(a).responsive === void 0 || !p.value ? renderSlot(I.$slots, "backdrop", { key: 0 }, () => [
        createVNode(Na, {
          blur: unref(a).backdropBlur,
          variant: unref(a).backdropVariant,
          show: B.value,
          fixed: "",
          "no-wrap": "",
          "no-spinner": "",
          onClick: z[2] || (z[2] = (te) => N("backdrop"))
        }, null, 8, ["blur", "variant", "show"])
      ]) : createCommentVNode("", true)
    ], 8, ["to", "disabled"]));
  }
});
var Hc = ["aria-disabled", "aria-label"];
var il = 20;
var ul = 0;
var Dc = defineComponent({
  __name: "BPagination",
  props: mergeModels({
    align: { default: "start" },
    ariaControls: { default: void 0 },
    ariaLabel: { default: "Pagination" },
    disabled: { type: Boolean, default: false },
    ellipsisClass: { default: void 0 },
    ellipsisText: { default: "" },
    firstClass: { default: void 0 },
    firstNumber: { type: Boolean, default: false },
    firstText: { default: "" },
    hideEllipsis: { type: Boolean, default: false },
    hideGotoEndButtons: { type: Boolean, default: false },
    labelFirstPage: { default: "Go to first page" },
    labelLastPage: { default: "Go to last page" },
    labelNextPage: { default: "Go to next page" },
    labelPage: { default: "Go to page" },
    labelPrevPage: { default: "Go to previous page" },
    lastClass: { default: void 0 },
    lastNumber: { type: Boolean, default: false },
    lastText: { default: "" },
    limit: { default: 5 },
    modelValue: {},
    nextClass: { default: void 0 },
    nextText: { default: "" },
    pageClass: { default: void 0 },
    perPage: { default: il },
    pills: { type: Boolean, default: false },
    prevClass: { default: void 0 },
    prevText: { default: "" },
    size: { default: void 0 },
    totalRows: { default: ul }
  }, {
    modelValue: { default: 1 },
    modelModifiers: {}
  }),
  emits: mergeModels(["page-click"], ["update:modelValue"]),
  setup(t4, { emit: l }) {
    const d = G(t4, "BPagination"), c = l, f = useModel(t4, "modelValue"), p = _e(() => d.limit, { nanToZero: true, method: "parseInt" }), v = _e(() => d.perPage, { nanToZero: true, method: "parseInt" }), y = _e(() => d.totalRows, { nanToZero: true, method: "parseInt" }), h2 = _e(f, { nanToZero: true, method: "parseInt" }), w = toRef(() => Math.max(v.value || il, 1)), m = toRef(() => Math.max(y.value || ul, 0)), B = toRef(() => Math.ceil(m.value / w.value)), g = toRef(() => d.align === "fill"), A = toRef(() => d.align === "fill" ? "start" : d.align), C = Xt(A), V = (Q) => Q === h2.value, O = (Q) => d.disabled ? null : V(Q) ? "0" : "-1", Y = (Q) => d.disabled || V(Q) || h2.value < 1 || // Check if the number is out of bounds
    Q < 1 || Q > B.value, U = computed(() => Y(1)), F = computed(() => Y(h2.value - 1)), j = computed(() => Y(B.value)), $ = computed(() => Y(h2.value + 1)), N = ({
      page: Q,
      classVal: fe,
      dis: de,
      slotName: me,
      textValue: J,
      tabIndex: se,
      label: Be,
      position: ve,
      isActive: pe,
      role: ye,
      hidden: Te
    }) => ({
      li: {
        class: [
          "page-item",
          {
            active: pe,
            disabled: de,
            "flex-fill": g.value,
            "d-flex": g.value && !de
          },
          fe
        ],
        role: ye,
        "aria-hidden": Te
      },
      button: {
        is: de ? "span" : "button",
        class: ["page-link", { "flex-grow-1": !de && g.value }],
        "aria-label": Be,
        "aria-controls": d.ariaControls || void 0,
        "aria-disabled": de ? true : void 0,
        "aria-posinset": ve,
        "aria-setsize": ve ? B.value : void 0,
        role: "menuitem",
        type: de ? void 0 : "button",
        tabindex: de ? void 0 : se
      },
      text: {
        name: me,
        active: pe,
        value: J ?? Q,
        page: Q,
        disabled: de,
        index: Q - 1,
        content: J ? void 0 : Q
      },
      clickHandler: (Qe) => ne(Qe, Q)
    }), H = ({
      page: Q,
      classVal: fe,
      dis: de,
      slotName: me,
      textValue: J,
      label: se
    }) => N({ page: Q, classVal: fe, dis: de, slotName: me, textValue: J, label: se, tabIndex: "-1" }), k = (Q) => N({
      page: Q,
      dis: d.disabled,
      classVal: d.pageClass,
      slotName: "page",
      label: d.labelPage ? `${d.labelPage} ${Q}` : void 0,
      tabIndex: O(Q) ?? void 0,
      position: Q,
      isActive: V(Q)
    }), S = computed(
      () => H({
        page: 1,
        dis: U.value,
        classVal: d.firstClass,
        slotName: "first-text",
        textValue: d.firstText,
        label: d.labelFirstPage
      })
    ), E = computed(
      () => H({
        page: Math.max(h2.value - 1, 1),
        dis: F.value,
        classVal: d.prevClass,
        slotName: "prev-text",
        textValue: d.prevText,
        label: d.labelPrevPage
      })
    ), M = computed(
      () => H({
        page: Math.min(h2.value + 1, B.value),
        dis: $.value,
        classVal: d.nextClass,
        slotName: "next-text",
        textValue: d.nextText,
        label: d.labelNextPage
      })
    ), X = computed(
      () => H({
        page: B.value,
        dis: j.value,
        classVal: d.lastClass,
        slotName: "last-text",
        textValue: d.lastText,
        label: d.labelLastPage
      })
    ), I = pa(), z = pa(), te = computed(() => ({
      li: {
        class: [
          "page-item",
          "disabled",
          "bv-d-xs-down-none",
          g.value ? "flex-fill" : "",
          d.ellipsisClass
        ],
        role: "separator"
      },
      span: {
        class: ["page-link"]
      }
    })), ae = computed(() => [
      C.value,
      {
        [`pagination-${d.size}`]: d.size !== void 0,
        "b-pagination-pills": d.pills
      }
    ]), K = computed(() => ({
      pageSize: w.value,
      totalRows: y.value,
      numberOfPages: B.value
    })), ne = (Q, fe) => {
      if (fe === h2.value)
        return;
      const de = new ut("page-click", {
        cancelable: true,
        target: Q.target
      });
      c("page-click", de, fe), !de.defaultPrevented && (f.value = fe);
    };
    watch(h2, (Q) => {
      const de = ((me, J) => {
        const se = me || 1;
        return se > J ? J : se < 1 ? 1 : se;
      })(Q, B.value);
      de !== f.value && (f.value = de);
    }), watch(K, (Q, fe) => {
      (fe.pageSize !== Q.pageSize && fe.totalRows === Q.totalRows || fe.numberOfPages !== Q.numberOfPages && h2.value > fe.numberOfPages) && (f.value = 1);
    });
    const re = computed(() => {
      const Q = B.value, { value: fe } = h2, de = p.value, me = d.firstNumber ? 1 : 0, J = d.lastNumber ? 1 : 0, se = d.hideEllipsis || de <= 3, Be = d.hideGotoEndButtons ? 1 : 0;
      if (Q < de + me + J)
        return [
          !me && !Be ? -1 : null,
          -2,
          ...Array.from({ length: Q }, (ye, Te) => Te + 1),
          -3,
          !J && !Be ? -4 : null
        ].filter((ye) => ye !== null);
      const ve = Array.from({ length: de + 4 - Be * 2 });
      Be ? (ve[0] = -2, ve[ve.length - 1] = -3) : (me ? (ve[0] = -2, ve[1] = 1) : (ve[0] = -1, ve[1] = -2), J ? (ve[ve.length - 1] = -3, ve[ve.length - 2] = Q) : (ve[ve.length - 1] = -4, ve[ve.length - 2] = -3));
      const pe = Math.floor(de / 2);
      if (fe <= pe + me) {
        for (let ye = 1; ye <= de; ye++)
          ve[ye + 1 - Be] = ye + me;
        se || (ve[ve.length - 3] = -5);
      }
      if (fe > Q - pe - J) {
        const ye = Q - (de - 1) - J;
        for (let Te = 0; Te < de; Te++)
          ve[Te + 2 - Be] = ye + Te;
        se || (ve[2] = -5);
      }
      if (!ve[2]) {
        const ye = fe - Math.floor(de / 2);
        for (let Te = 0; Te < de; Te++)
          ve[Te + 2 - Be] = ye + Te;
        se || (ve[2] = -5, ve[ve.length - 3] = -5);
      }
      return ve;
    });
    return (Q, fe) => (openBlock(), createElementBlock("ul", {
      class: normalizeClass(["pagination", ae.value]),
      role: "menubar",
      "aria-disabled": unref(d).disabled,
      "aria-label": unref(d).ariaLabel || void 0
    }, [
      createVNode(unref(I).define, null, {
        default: withCtx(({ button: de, li: me, text: J, clickHandler: se }) => [
          createBaseVNode("li", normalizeProps(guardReactiveProps(me)), [
            (openBlock(), createBlock(resolveDynamicComponent(de.is), mergeProps(de, { onClick: se }), {
              default: withCtx(() => [
                renderSlot(Q.$slots, J.name, {
                  disabled: J.disabled,
                  page: J.page,
                  index: J.index,
                  active: J.active,
                  content: J.value
                }, () => [
                  createTextVNode(toDisplayString(J.value), 1)
                ])
              ]),
              _: 2
            }, 1040, ["onClick"]))
          ], 16)
        ]),
        _: 3
      }),
      createVNode(unref(z).define, null, {
        default: withCtx(() => [
          createBaseVNode("li", normalizeProps(guardReactiveProps(te.value.li)), [
            createBaseVNode("span", normalizeProps(guardReactiveProps(te.value.span)), [
              renderSlot(Q.$slots, "ellipsis-text", {}, () => [
                createTextVNode(toDisplayString(unref(d).ellipsisText || "..."), 1)
              ])
            ], 16)
          ], 16)
        ]),
        _: 3
      }),
      (openBlock(true), createElementBlock(Fragment, null, renderList(re.value, (de) => (openBlock(), createElementBlock(Fragment, {
        key: `page-${de}`
      }, [
        de === -1 ? (openBlock(), createBlock(unref(I).reuse, mergeProps({
          key: 0,
          ref_for: true
        }, S.value), null, 16)) : de === -2 ? (openBlock(), createBlock(unref(I).reuse, mergeProps({
          key: 1,
          ref_for: true
        }, E.value), null, 16)) : de === -3 ? (openBlock(), createBlock(unref(I).reuse, mergeProps({
          key: 2,
          ref_for: true
        }, M.value), null, 16)) : de === -4 ? (openBlock(), createBlock(unref(I).reuse, mergeProps({
          key: 3,
          ref_for: true
        }, X.value), null, 16)) : de === -5 ? (openBlock(), createBlock(unref(z).reuse, { key: 4 })) : de !== null ? (openBlock(), createBlock(unref(I).reuse, mergeProps({
          key: 5,
          ref_for: true
        }, k(de)), null, 16)) : createCommentVNode("", true)
      ], 64))), 128))
    ], 10, Hc));
  }
});
var Xe = defineComponent({
  inheritAttrs: false,
  __name: "BPlaceholder",
  props: {
    animation: { default: void 0 },
    cols: { default: 12 },
    size: { default: "md" },
    tag: { default: "span" },
    variant: { default: null },
    width: { default: void 0 },
    wrapperTag: { default: "span" }
  },
  setup(t4) {
    const e = G(t4, "BPlaceholder"), o = toRef(
      () => e.width === void 0 ? void 0 : typeof e.width == "number" ? e.width.toString() : e.width.replace("%", "")
    ), a = toRef(
      () => e.cols === void 0 ? void 0 : typeof e.cols == "number" ? e.cols.toString() : e.cols
    ), n = computed(() => ({
      [`col-${a.value}`]: a.value !== void 0 && o.value === void 0,
      [`bg-${e.variant}`]: e.variant !== null,
      [`placeholder-${e.size}`]: e.size !== "md"
    })), r = computed(() => ({
      [`placeholder-${e.animation}`]: e.animation !== void 0
    })), u = computed(() => ({
      width: o.value === void 0 ? void 0 : `${o.value}%`
    }));
    return (i, d) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).wrapperTag), {
      class: normalizeClass(r.value)
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(i.tag), mergeProps(i.$attrs, {
          class: ["placeholder", n.value],
          style: u.value
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
});
var ts = defineComponent({
  __name: "BPlaceholderButton",
  props: {
    animation: { default: void 0 },
    cols: { default: void 0 },
    tag: { default: "div" },
    variant: { default: "primary" },
    width: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BPlaceholderButton"), o = computed(() => ({
      [`btn-${e.variant}`]: e.variant !== null
    }));
    return (a, n) => (openBlock(), createBlock(Xe, {
      class: normalizeClass(["btn disabled", o.value]),
      animation: unref(e).animation,
      width: unref(e).width,
      cols: unref(e).cols,
      tag: unref(e).tag,
      style: { cursor: "wait", "pointer-events": "auto" }
    }, null, 8, ["class", "animation", "width", "cols", "tag"]));
  }
});
var jc = defineComponent({
  __name: "BPlaceholderCard",
  props: {
    animation: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    footerWidth: { default: 100 },
    headerAnimation: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    headerWidth: { default: 100 },
    imgBlankColor: { default: "#868e96" },
    imgPlacement: { default: "top" },
    imgHeight: { default: 100 },
    imgSrc: { default: void 0 },
    noButton: { type: Boolean, default: false },
    noFooter: { type: Boolean, default: false },
    noHeader: { type: Boolean, default: false },
    noImg: { type: Boolean, default: false },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BPlaceholderCard"), o = computed(() => ({
      animation: e.animation,
      size: e.size,
      variant: e.variant
    })), a = toRef(() => e.noButton ? Xe : ts);
    return (n, r) => (openBlock(), createBlock(Gn, {
      "img-placement": unref(e).imgPlacement
    }, createSlots({
      default: withCtx(() => [
        renderSlot(n.$slots, "default", {}, () => [
          createVNode(Xe, mergeProps({ cols: "7" }, o.value), null, 16),
          createVNode(Xe, mergeProps({ cols: "4" }, o.value), null, 16),
          createVNode(Xe, mergeProps({ cols: "4" }, o.value), null, 16),
          createVNode(Xe, mergeProps({ cols: "6" }, o.value), null, 16),
          createVNode(Xe, mergeProps({ cols: "8" }, o.value), null, 16)
        ])
      ]),
      _: 2
    }, [
      unref(e).noImg ? void 0 : {
        name: "img",
        fn: withCtx(() => [
          renderSlot(n.$slots, "img", {}, () => [
            createVNode(To, {
              blank: !unref(e).imgSrc,
              "blank-color": unref(e).imgBlankColor,
              height: unref(e).imgSrc ? void 0 : unref(e).imgHeight,
              src: unref(e).imgSrc,
              "img-placement": unref(e).imgPlacement,
              style: { cursor: "wait" }
            }, null, 8, ["blank", "blank-color", "height", "src", "img-placement"])
          ])
        ]),
        key: "0"
      },
      unref(e).noHeader ? void 0 : {
        name: "header",
        fn: withCtx(() => [
          renderSlot(n.$slots, "header", {}, () => [
            createVNode(Xe, {
              width: unref(e).headerWidth,
              variant: unref(e).headerVariant,
              animation: unref(e).headerAnimation,
              size: unref(e).headerSize
            }, null, 8, ["width", "variant", "animation", "size"])
          ])
        ]),
        key: "1"
      },
      unref(e).noFooter ? void 0 : {
        name: "footer",
        fn: withCtx(() => [
          renderSlot(n.$slots, "footer", {}, () => [
            (openBlock(), createBlock(resolveDynamicComponent(a.value), {
              width: unref(e).footerWidth,
              animation: unref(e).footerAnimation,
              size: unref(e).noButton ? unref(e).footerSize : void 0,
              variant: unref(e).footerVariant
            }, null, 8, ["width", "animation", "size", "variant"]))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-placement"]));
  }
});
var qc = "300px";
var xo = defineComponent({
  __name: "BTableSimple",
  props: {
    bordered: { type: Boolean, default: false },
    borderless: { type: Boolean, default: false },
    borderVariant: { default: null },
    captionTop: { type: Boolean, default: false },
    dark: { type: Boolean, default: false },
    fixed: { type: Boolean, default: false },
    hover: { type: Boolean, default: false },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: false },
    outlined: { type: Boolean, default: false },
    responsive: { type: [Boolean, String], default: false },
    small: { type: Boolean, default: false },
    stacked: { type: [Boolean, String], default: false },
    stickyHeader: { type: [Boolean, String, Number], default: false },
    striped: { type: Boolean, default: false },
    stripedColumns: { type: Boolean, default: false },
    variant: { default: null },
    tableAttrs: { default: void 0 },
    tableClass: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BTableSimple"), o = computed(() => [
      e.tableClass,
      "table",
      "b-table",
      {
        "table-bordered": e.bordered,
        "table-borderless": e.borderless,
        [`border-${e.borderVariant}`]: e.borderVariant !== null,
        "caption-top": e.captionTop,
        "table-dark": e.dark,
        "table-hover": e.hover,
        "b-table-stacked": e.stacked === true,
        [`b-table-stacked-${e.stacked}`]: typeof e.stacked == "string",
        "table-striped": e.striped,
        "table-sm": e.small,
        [`table-${e.variant}`]: e.variant !== null,
        "table-striped-columns": e.stripedColumns
      }
    ]), a = computed(() => ({
      id: e.id,
      class: o.value,
      ...e.tableAttrs
    })), n = Ba(
      computed(
        () => (e.stickyHeader === true ? qc : e.stickyHeader) || NaN
      )
    ), r = computed(() => e.stickyHeader !== false), u = computed(() => e.responsive !== false || r.value), i = computed(
      () => r.value ? { maxHeight: n.value } : void 0
    ), d = computed(() => ({
      "table-responsive": e.responsive === true,
      [`table-responsive-${e.responsive}`]: typeof e.responsive == "string",
      "b-table-sticky-header": r.value
    }));
    return (c, f) => u.value ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(d.value),
      style: normalizeStyle(i.value)
    }, [
      createBaseVNode("table", normalizeProps(guardReactiveProps(a.value)), [
        renderSlot(c.$slots, "default")
      ], 16)
    ], 6)) : (openBlock(), createElementBlock("table", normalizeProps(mergeProps({ key: 1 }, a.value)), [
      renderSlot(c.$slots, "default")
    ], 16));
  }
});
var Wc = defineComponent({
  __name: "BPlaceholderTable",
  props: {
    animation: { default: void 0 },
    cellWidth: { default: 100 },
    columns: { default: 5 },
    footerAnimation: { default: void 0 },
    footerCellWidth: { default: 100 },
    footerColumns: { default: void 0 },
    footerSize: { default: "md" },
    footerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerCellWidth: { default: 100 },
    headerColumns: { default: void 0 },
    headerSize: { default: "md" },
    headerVariant: { default: void 0 },
    hideHeader: { type: Boolean, default: false },
    rows: { default: 3 },
    showFooter: { type: Boolean, default: false },
    size: { default: "md" },
    variant: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BPlaceholderTable"), o = _e(() => e.columns), a = _e(() => e.rows), n = toRef(() => e.headerColumns ?? NaN), r = toRef(() => e.footerColumns ?? NaN), u = _e(n), i = _e(r), d = toRef(() => o.value || 5), c = toRef(() => a.value || 3), f = toRef(
      () => e.headerColumns === void 0 ? d.value : u.value
    ), p = toRef(
      () => e.footerColumns === void 0 ? d.value : i.value
    );
    return (v, y) => (openBlock(), createBlock(xo, null, {
      default: withCtx(() => [
        unref(e).hideHeader ? createCommentVNode("", true) : renderSlot(v.$slots, "thead", { key: 0 }, () => [
          createBaseVNode("thead", null, [
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(f.value, (h2, w) => (openBlock(), createElementBlock("th", { key: w }, [
                createVNode(Xe, {
                  size: unref(e).headerSize,
                  variant: unref(e).headerVariant,
                  animation: unref(e).headerAnimation,
                  width: unref(e).headerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]),
        renderSlot(v.$slots, "default", {}, () => [
          createBaseVNode("tbody", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(c.value, (h2, w) => (openBlock(), createElementBlock("tr", { key: w }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(d.value, (m, B) => (openBlock(), createElementBlock("td", { key: B }, [
                createVNode(Xe, {
                  size: unref(e).size,
                  variant: unref(e).variant,
                  animation: unref(e).animation,
                  width: unref(e).cellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ]))), 128))
          ])
        ]),
        unref(e).showFooter ? renderSlot(v.$slots, "tfoot", { key: 1 }, () => [
          createBaseVNode("tfoot", null, [
            createBaseVNode("tr", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(p.value, (h2, w) => (openBlock(), createElementBlock("th", { key: w }, [
                createVNode(Xe, {
                  size: unref(e).footerSize,
                  variant: unref(e).footerVariant,
                  animation: unref(e).footerAnimation,
                  width: unref(e).footerCellWidth
                }, null, 8, ["size", "variant", "animation", "width"])
              ]))), 128))
            ])
          ])
        ]) : createCommentVNode("", true)
      ]),
      _: 3
    }));
  }
});
var Gc = defineComponent({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { type: Boolean, default: false }
  },
  setup(t4) {
    const e = G(t4, "BPlaceholderWrapper");
    return (o, a) => unref(e).loading ? renderSlot(o.$slots, "loading", { key: 0 }) : renderSlot(o.$slots, "default", { key: 1 });
  }
});
var Uc = defineComponent({
  __name: "BRow",
  props: {
    tag: { default: "div" },
    gutterX: { default: void 0 },
    gutterY: { default: void 0 },
    noGutters: { type: Boolean, default: false },
    alignV: { default: void 0 },
    alignH: { default: void 0 },
    alignContent: { default: void 0 },
    cols: { default: void 0 },
    colsSm: { default: void 0 },
    colsMd: { default: void 0 },
    colsLg: { default: void 0 },
    colsXl: { default: void 0 },
    colsXxl: { default: void 0 }
  },
  setup(t4) {
    const e = G(t4, "BRow"), o = Xt(() => e.alignH), a = computed(
      () => la(
        {
          cols: e.cols,
          colsLg: e.colsLg,
          colsMd: e.colsMd,
          colsSm: e.colsSm,
          colsXl: e.colsXl,
          colsXxl: e.colsXxl
        },
        ["cols", "colsLg", "colsMd", "colsSm", "colsXl", "colsXxl"],
        "cols",
        "row-cols"
      )
    ), n = computed(() => [
      a.value,
      {
        [`gx-${e.gutterX}`]: e.gutterX !== void 0,
        [`gy-${e.gutterY}`]: e.gutterY !== void 0,
        "g-0": e.noGutters,
        [`align-items-${e.alignV}`]: e.alignV !== void 0,
        [o.value]: e.alignH !== void 0,
        [`align-content-${e.alignContent}`]: e.alignContent !== void 0
      }
    ]);
    return (r, u) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), {
      class: normalizeClass(["row", n.value])
    }, {
      default: withCtx(() => [
        renderSlot(r.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
var et = (t4) => typeof t4 == "object" && t4 !== null;
var jt = (t4) => typeof t4 == "object" && t4 !== null && "key" in t4;
var as = defineComponent({
  __name: "BTbody",
  props: {
    variant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BTbody"), o = computed(() => ({
      [`thead-${e.variant}`]: e.variant !== null
    }));
    return (a, n) => (openBlock(), createElementBlock("tbody", {
      class: normalizeClass(o.value)
    }, [
      renderSlot(a.$slots, "default")
    ], 2));
  }
});
var Kc = ["scope", "colspan", "rowspan", "data-label"];
var Xc = { key: 0 };
var Ot = defineComponent({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: Boolean, default: false },
    variant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BTd"), o = computed(() => ({
      [`table-${e.variant}`]: e.variant !== null,
      "b-table-sticky-column": e.stickyColumn,
      "table-b-table-default": e.stickyColumn && e.variant === null
    })), a = toRef(() => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
    return (n, r) => (openBlock(), createElementBlock("td", {
      scope: a.value,
      class: normalizeClass(o.value),
      colspan: unref(e).colspan,
      rowspan: unref(e).rowspan,
      "data-label": unref(e).stackedHeading
    }, [
      unref(e).stackedHeading ? (openBlock(), createElementBlock("div", Xc, [
        renderSlot(n.$slots, "default")
      ])) : renderSlot(n.$slots, "default", { key: 1 })
    ], 10, Kc));
  }
});
var eo = defineComponent({
  __name: "BTfoot",
  props: {
    variant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BTfoot"), o = computed(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, n) => (openBlock(), createElementBlock("tfoot", {
      class: normalizeClass(o.value)
    }, [
      renderSlot(a.$slots, "default")
    ], 2));
  }
});
var Yc = ["scope", "colspan", "rowspan", "data-label"];
var Zc = { key: 0 };
var to = defineComponent({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: Boolean, default: false },
    variant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BTh"), o = computed(() => ({
      [`table-${e.variant}`]: e.variant !== null,
      "b-table-sticky-column": e.stickyColumn,
      "table-b-table-default": e.stickyColumn && e.variant === null
    })), a = toRef(() => e.colspan ? "colspan" : e.rowspan ? "rowspan" : "col");
    return (n, r) => (openBlock(), createElementBlock("th", {
      scope: a.value,
      class: normalizeClass(o.value),
      colspan: unref(e).colspan,
      rowspan: unref(e).rowspan,
      "data-label": unref(e).stackedHeading
    }, [
      unref(e).stackedHeading !== void 0 ? (openBlock(), createElementBlock("div", Zc, [
        renderSlot(n.$slots, "default")
      ])) : renderSlot(n.$slots, "default", { key: 1 })
    ], 10, Yc));
  }
});
var os = defineComponent({
  __name: "BThead",
  props: {
    variant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BThead"), o = computed(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, n) => (openBlock(), createElementBlock("thead", {
      class: normalizeClass(o.value)
    }, [
      renderSlot(a.$slots, "default")
    ], 2));
  }
});
var tt = defineComponent({
  __name: "BTr",
  props: {
    variant: { default: null }
  },
  setup(t4) {
    const e = G(t4, "BTr"), o = computed(() => ({
      [`table-${e.variant}`]: e.variant !== null
    }));
    return (a, n) => (openBlock(), createElementBlock("tr", {
      class: normalizeClass(o.value)
    }, [
      renderSlot(a.$slots, "default")
    ], 2));
  }
});
var Jc = {
  key: 0,
  class: "b-table-stacked-label"
};
var Qc = { class: "d-inline-flex flex-nowrap align-items-center gap-1" };
var ef = { key: 2 };
var ls = defineComponent({
  __name: "BTableLite",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: "There are no records matching your request" },
    emptyText: { default: "There are no records to show" },
    fieldColumnClass: { type: [Function, String, Object, Array], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: Boolean, default: false },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: false },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: Boolean, default: false },
    tbodyClass: { default: void 0 },
    tbodyTrAttrs: {},
    tbodyTrClass: { type: [Function, String, Object, Array], default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: Boolean, default: void 0 },
    borderless: { type: Boolean, default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: Boolean, default: void 0 },
    dark: { type: Boolean, default: void 0 },
    fixed: { type: Boolean, default: void 0 },
    hover: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: void 0 },
    outlined: { type: Boolean, default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: Boolean, default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String, Number], default: void 0 },
    striped: { type: Boolean, default: void 0 },
    stripedColumns: { type: Boolean, default: void 0 },
    variant: { default: void 0 },
    tableAttrs: {},
    tableClass: { default: void 0 }
  },
  emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered"],
  setup(t4, { emit: l }) {
    const o = G(t4, "BTableLite"), a = l, n = (m) => [
      m,
      m._showDetails
    ], r = ref(
      new WeakMap(
        o.items.reduce(
          (m, B) => (et(B) && m.push(n(B)), m),
          []
        )
      )
    );
    watch(
      () => o.items,
      (m) => {
        m.forEach((B) => {
          if (!et(B))
            return;
          const g = n(B);
          r.value.set(g[0], g[1]);
        });
      },
      { deep: true }
    );
    const u = computed(() => [
      o.tableClass,
      {
        [`align-${o.align}`]: o.align !== void 0
      }
    ]), i = computed(() => {
      if (!o.fields.length && o.items.length) {
        const [m] = o.items;
        return et(m) || Array.isArray(m) ? Object.keys(m).map((B) => {
          const g = Fa(B);
          return {
            key: B,
            label: g,
            tdAttr: o.stacked === true ? { "data-label": g } : void 0
          };
        }) : [{ key: "", _noHeader: true }];
      }
      return o.fields.map((m) => {
        if (jt(m))
          return {
            ...m,
            tdAttr: o.stacked === true ? { "data-label": Fa(m.key), ...m.tdAttr } : m.tdAttr
          };
        const B = Fa(m);
        return {
          key: m,
          label: B,
          tdAttr: o.stacked === true ? { "data-label": B } : void 0
        };
      });
    }), d = toRef(() => i.value.length), c = computed(() => !(i.value.length > 0 && i.value.every((m) => m._noHeader === true))), f = (m, B, g) => {
      const A = Ie(m, B);
      return g && typeof g == "function" ? g(A, B, m) : g;
    }, p = (m, B, g = false) => {
      a("head-clicked", m.key, m, B, g);
    }, v = (m) => {
      if (et(m)) {
        const B = r.value.get(m);
        r.value.set(m, !B), m._showDetails = !B;
      }
    }, y = (m) => [
      m.class,
      m.thClass,
      {
        "b-table-sticky-column": m.stickyColumn
      },
      o.fieldColumnClass ? typeof o.fieldColumnClass == "function" ? o.fieldColumnClass(m) : o.fieldColumnClass : null
    ], h2 = (m, B) => {
      var g, A;
      return [
        m.class,
        m.tdClass,
        et(B) && (g = B._cellVariants) != null && g[m.key] ? `table-${(A = B._cellVariants) == null ? void 0 : A[m.key]}` : null,
        {
          "b-table-sticky-column": m.stickyColumn
        }
      ];
    }, w = (m, B) => o.tbodyTrClass ? typeof o.tbodyTrClass == "function" ? o.tbodyTrClass(m, B) : o.tbodyTrClass : null;
    return (m, B) => (openBlock(), createBlock(xo, {
      id: unref(o).id,
      bordered: unref(o).bordered,
      borderless: unref(o).borderless,
      "border-variant": unref(o).borderVariant,
      "caption-top": unref(o).captionTop,
      dark: unref(o).dark,
      fixed: unref(o).fixed,
      hover: unref(o).hover,
      "no-border-collapse": unref(o).noBorderCollapse,
      outlined: unref(o).outlined,
      responsive: unref(o).responsive,
      small: unref(o).small,
      stacked: unref(o).stacked,
      "sticky-header": unref(o).stickyHeader,
      striped: unref(o).striped,
      "table-class": u.value,
      variant: unref(o).variant,
      "striped-columns": unref(o).stripedColumns
    }, {
      default: withCtx(() => [
        withDirectives(createVNode(os, {
          variant: unref(o).headVariant,
          class: normalizeClass(unref(o).theadClass)
        }, {
          default: withCtx(() => [
            m.$slots["thead-top"] ? renderSlot(m.$slots, "thead-top", { key: 0 }) : createCommentVNode("", true),
            createVNode(tt, {
              variant: unref(o).headRowVariant,
              class: normalizeClass(unref(o).theadTrClass)
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (g) => (openBlock(), createBlock(to, mergeProps({
                  key: g.key,
                  scope: "col",
                  class: y(g),
                  title: g.headerTitle,
                  variant: g.variant,
                  abbr: g.headerAbbr,
                  style: g.thStyle,
                  ref_for: true
                }, g.thAttr, {
                  onClick: (A) => p(g, A)
                }), {
                  default: withCtx(() => [
                    renderSlot(m.$slots, m.$slots[`head(${String(g.key)})`] ? `head(${String(g.key)})` : "head()", {
                      label: g.label,
                      column: g.key,
                      field: g,
                      isFoot: false
                    }, () => [
                      createTextVNode(toDisplayString(unref(sa)(g)), 1)
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "variant", "abbr", "style", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"]),
            m.$slots["thead-sub"] ? (openBlock(), createBlock(tt, { key: 1 }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (g) => (openBlock(), createBlock(Ot, {
                  key: g.key,
                  scope: "col",
                  variant: g.variant,
                  class: normalizeClass([g.class, g.thClass])
                }, {
                  default: withCtx(() => [
                    renderSlot(m.$slots, "thead-sub", mergeProps({
                      items: i.value,
                      ref_for: true
                    }, g), () => [
                      createTextVNode(toDisplayString(g.label), 1)
                    ])
                  ]),
                  _: 2
                }, 1032, ["variant", "class"]))), 128))
              ]),
              _: 3
            })) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["variant", "class"]), [
          [vShow, c.value]
        ]),
        createVNode(as, {
          class: normalizeClass(unref(o).tbodyClass)
        }, {
          default: withCtx(() => [
            renderSlot(m.$slots, "custom-body", {
              fields: i.value,
              items: unref(o).items,
              columns: i.value.length
            }, () => [
              !unref(o).stacked && m.$slots["top-row"] ? (openBlock(), createBlock(tt, { key: 0 }, {
                default: withCtx(() => [
                  renderSlot(m.$slots, "top-row")
                ]),
                _: 3
              })) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(o).items, (g, A) => (openBlock(), createElementBlock(Fragment, { key: A }, [
                createVNode(tt, {
                  class: normalizeClass(w(g, "row")),
                  variant: unref(et)(g) ? g._rowVariant : void 0,
                  onClick: (C) => !unref(Qt)(C) && a("row-clicked", g, A, C),
                  onDblclick: (C) => !unref(Qt)(C) && a("row-dbl-clicked", g, A, C),
                  onMouseenter: (C) => !unref(Qt)(C) && a("row-hovered", g, A, C),
                  onMouseleave: (C) => !unref(Qt)(C) && a("row-unhovered", g, A, C)
                }, {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (C) => {
                      var V;
                      return openBlock(), createBlock(Ot, mergeProps({
                        key: C.key,
                        variant: unref(et)(g) && (V = g._cellVariants) != null && V[C.key] ? null : C.variant,
                        class: h2(C, g),
                        ref_for: true
                      }, f(g, String(C.key), C.tdAttr)), {
                        default: withCtx(() => [
                          unref(o).stacked && unref(o).labelStacked ? (openBlock(), createElementBlock("label", Jc, toDisplayString(unref(sa)(C)), 1)) : createCommentVNode("", true),
                          renderSlot(
                            m.$slots,
                            m.$slots[`cell(${String(C.key)})`] ? `cell(${String(C.key)})` : "cell()",
                            {
                              value: unref(Ga)(g, String(C.key), C.formatter),
                              unformatted: unref(Ie)(g, String(C.key)),
                              index: A,
                              item: g,
                              field: C,
                              items: m.items,
                              toggleDetails: () => {
                                v(g);
                              },
                              detailsShowing: unref(et)(g) ? r.value.get(g) ?? false : false
                            },
                            () => [
                              !m.$slots[`cell(${String(C.key)})`] && !m.$slots["cell()"] ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                                createTextVNode(toDisplayString(unref(Ga)(g, String(C.key), C.formatter)), 1)
                              ], 64)) : createCommentVNode("", true)
                            ]
                          )
                        ]),
                        _: 2
                      }, 1040, ["variant", "class"]);
                    }), 128))
                  ]),
                  _: 2
                }, 1032, ["class", "variant", "onClick", "onDblclick", "onMouseenter", "onMouseleave"]),
                unref(et)(g) && r.value.get(g) === true && m.$slots["row-details"] ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createVNode(tt, {
                    "aria-hidden": "true",
                    role: "presentation",
                    class: "d-none"
                  }),
                  createVNode(tt, {
                    class: normalizeClass(w(g, "row-details")),
                    variant: g._rowVariant
                  }, {
                    default: withCtx(() => [
                      createVNode(Ot, { colspan: d.value }, {
                        default: withCtx(() => [
                          renderSlot(m.$slots, "row-details", {
                            item: g,
                            toggleDetails: () => {
                              v(g);
                            },
                            fields: unref(o).fields,
                            index: A
                          })
                        ]),
                        _: 2
                      }, 1032, ["colspan"])
                    ]),
                    _: 2
                  }, 1032, ["class", "variant"])
                ], 64)) : createCommentVNode("", true)
              ], 64))), 128)),
              unref(o).showEmpty && unref(o).items.length === 0 ? (openBlock(), createBlock(tt, {
                key: 1,
                class: "b-table-empty-slot"
              }, {
                default: withCtx(() => [
                  createVNode(Ot, { colspan: d.value }, {
                    default: withCtx(() => [
                      renderSlot(m.$slots, "empty", {
                        items: unref(o).items
                      }, () => [
                        createTextVNode(toDisplayString(unref(o).emptyText), 1)
                      ])
                    ]),
                    _: 3
                  }, 8, ["colspan"])
                ]),
                _: 3
              })) : createCommentVNode("", true),
              !unref(o).stacked && m.$slots["bottom-row"] ? (openBlock(), createBlock(tt, {
                key: 2,
                class: "bottom-row"
              }, {
                default: withCtx(() => [
                  renderSlot(m.$slots, "bottom-row")
                ]),
                _: 3
              })) : createCommentVNode("", true)
            ])
          ]),
          _: 3
        }, 8, ["class"]),
        unref(o).footClone ? (openBlock(), createBlock(eo, {
          key: 0,
          variant: unref(o).footVariant,
          class: normalizeClass(unref(o).tfootClass)
        }, {
          default: withCtx(() => [
            createVNode(tt, {
              variant: unref(o).footRowVariant,
              class: normalizeClass(unref(o).tfootTrClass)
            }, {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(i.value, (g) => (openBlock(), createBlock(to, mergeProps({
                  key: g.key,
                  scope: "col",
                  class: y(g),
                  title: g.headerTitle,
                  abbr: g.headerAbbr,
                  style: g.thStyle,
                  variant: g.variant,
                  ref_for: true
                }, g.thAttr, {
                  onClick: (A) => p(g, A, true)
                }), {
                  default: withCtx(() => [
                    createBaseVNode("div", Qc, [
                      createBaseVNode("div", null, [
                        renderSlot(
                          m.$slots,
                          m.$slots[`foot(${String(g.key)})`] ? `foot(${String(g.key)})` : "foot()",
                          {
                            label: g.label,
                            column: g.key,
                            field: g,
                            isFoot: true
                          },
                          () => [
                            createTextVNode(toDisplayString(unref(sa)(g)), 1)
                          ]
                        )
                      ])
                    ])
                  ]),
                  _: 2
                }, 1040, ["class", "title", "abbr", "style", "variant", "onClick"]))), 128))
              ]),
              _: 3
            }, 8, ["variant", "class"])
          ]),
          _: 3
        }, 8, ["variant", "class"])) : m.$slots["custom-foot"] ? (openBlock(), createBlock(eo, { key: 1 }, {
          default: withCtx(() => [
            renderSlot(m.$slots, "custom-foot", {
              fields: i.value,
              items: unref(o).items,
              columns: i.value.length
            })
          ]),
          _: 3
        })) : createCommentVNode("", true),
        m.$slots["table-caption"] || unref(o).caption ? (openBlock(), createElementBlock("caption", ef, [
          renderSlot(m.$slots, "table-caption", {}, () => [
            createTextVNode(toDisplayString(unref(o).caption), 1)
          ])
        ])) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["id", "bordered", "borderless", "border-variant", "caption-top", "dark", "fixed", "hover", "no-border-collapse", "outlined", "responsive", "small", "stacked", "sticky-header", "striped", "table-class", "variant", "striped-columns"]));
  }
});
var tf = createBaseVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-up-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, [
  createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"
  })
], -1);
var af = createBaseVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-down-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
}, [
  createBaseVNode("path", {
    "fill-rule": "evenodd",
    d: "M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z"
  })
], -1);
var of = {
  style: { opacity: 0.4 },
  xmlns: "http://www.w3.org/2000/svg",
  width: "24",
  height: "24",
  fill: "currentColor",
  class: "bi bi-arrow-up-short",
  viewBox: "0 0 16 16",
  "aria-hidden": ""
};
var lf = createBaseVNode("path", {
  "fill-rule": "evenodd",
  d: "M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"
}, null, -1);
var nf = [
  lf
];
var sf = { class: "d-flex align-items-center gap-2 mt-5" };
var rf = defineComponent({
  __name: "BTable",
  props: mergeModels({
    provider: { default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { type: Boolean, default: false },
    noProviderSorting: { type: Boolean, default: false },
    noProviderFiltering: { type: Boolean, default: false },
    sortBy: {},
    mustSort: { type: [Boolean, Array], default: false },
    selectable: { type: Boolean, default: false },
    multisort: { type: Boolean, default: false },
    stickySelect: { type: Boolean, default: false },
    selectHead: { type: [Boolean, String], default: true },
    selectMode: { default: "multi" },
    selectionVariant: { default: "primary" },
    busy: { type: Boolean },
    busyLoadingText: { default: "Loading..." },
    perPage: { default: Number.POSITIVE_INFINITY },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    noLocalSorting: { type: Boolean, default: false },
    noSelectOnClick: { type: Boolean, default: false },
    selectedItems: {},
    noSortableIcon: { type: Boolean, default: false },
    align: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    detailsTdClass: { default: void 0 },
    emptyFilteredText: { default: void 0 },
    emptyText: { default: void 0 },
    fieldColumnClass: { type: [Function, String, Object, Array], default: void 0 },
    fields: { default: () => [] },
    footClone: { type: Boolean, default: void 0 },
    footRowVariant: { default: void 0 },
    footVariant: { default: void 0 },
    headRowVariant: { default: void 0 },
    headVariant: { default: void 0 },
    items: { default: () => [] },
    labelStacked: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    primaryKey: { default: void 0 },
    showEmpty: { type: Boolean, default: void 0 },
    tbodyClass: { default: void 0 },
    tbodyTrAttrs: {},
    tbodyTrClass: { type: [Function, String, Object, Array], default: void 0 },
    tfootClass: { default: void 0 },
    tfootTrClass: { default: void 0 },
    theadClass: { default: void 0 },
    theadTrClass: { default: void 0 },
    bordered: { type: Boolean, default: void 0 },
    borderless: { type: Boolean, default: void 0 },
    borderVariant: { default: void 0 },
    captionTop: { type: Boolean, default: void 0 },
    dark: { type: Boolean, default: void 0 },
    fixed: { type: Boolean, default: void 0 },
    hover: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    noBorderCollapse: { type: Boolean, default: void 0 },
    outlined: { type: Boolean, default: void 0 },
    responsive: { type: [Boolean, String], default: void 0 },
    small: { type: Boolean, default: void 0 },
    stacked: { type: [Boolean, String], default: void 0 },
    stickyHeader: { type: [Boolean, String, Number], default: void 0 },
    striped: { type: Boolean, default: void 0 },
    stripedColumns: { type: Boolean, default: void 0 },
    variant: { default: void 0 },
    tableAttrs: {}
  }, {
    sortBy: {
      default: void 0
    },
    sortByModifiers: {},
    busy: { type: Boolean, default: false },
    busyModifiers: {},
    selectedItems: {
      default: () => []
    },
    selectedItemsModifiers: {}
  }),
  emits: mergeModels(["filtered", "head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered", "row-selected", "row-unselected", "sorted", "change"], ["update:sortBy", "update:busy", "update:selectedItems"]),
  setup(t4, { expose: l, emit: e }) {
    const a = G(t4, "BTable"), n = e, r = useModel(t4, "sortBy"), u = useModel(t4, "busy"), i = useModel(t4, "selectedItems"), d = computed({
      get: () => /* @__PURE__ */ new Set([...i.value]),
      set: (k) => {
        i.value = [...k];
      }
    }), c = {
      add: (k) => {
        const S = new Set(d.value);
        S.add(k), d.value = S, n("row-selected", k);
      },
      clear: () => {
        d.value.forEach((k) => {
          c.delete(k);
        });
      },
      delete: (k) => {
        const S = new Set(d.value);
        if (a.primaryKey) {
          const E = a.primaryKey;
          i.value.forEach((M, X) => {
            const I = Ie(M, E), z = Ie(k, E);
            I && z && I === z && S.delete(i.value[X]);
          });
        } else
          S.delete(k);
        d.value = S, n("row-unselected", k);
      },
      set: (k) => {
        d.value = new Set(k), d.value.forEach((S) => {
          n("row-unselected", S);
        });
      },
      has: (k) => {
        if (!a.primaryKey)
          return d.value.has(k);
        const S = a.primaryKey;
        for (const E of d.value) {
          const M = Ie(E, S), X = Ie(k, S);
          if (M && X && M === X)
            return true;
        }
        return false;
      }
    }, f = ref([]), p = _e(() => a.perPage, { method: "parseInt" }), v = _e(() => a.currentPage, { method: "parseInt" }), y = toRef(() => !!a.filter), h2 = toRef(() => a.provider !== void 0), w = toRef(() => d.value.size > 0), m = computed(
      () => r.value !== void 0 || a.fields.some(
        (k) => typeof k == "object" && k !== null && k.sortable === true
      )
    ), B = computed(
      () => a.fields.map((k) => {
        var M;
        if (!(typeof k == "object" && k !== null))
          return k;
        const S = (M = r.value) == null ? void 0 : M.find((X) => k.key === X.key), E = m.value === false ? void 0 : S === void 0 ? "none" : S.order === "desc" ? "descending" : S.order === "asc" ? "ascending" : "none";
        return {
          ...k,
          thAttr: {
            "aria-sort": E,
            ...k.thAttr
          }
        };
      })
    ), g = computed(() => ({
      "b-table-busy": u.value,
      "b-table-selectable": a.selectable,
      "user-select-none": a.selectable && w.value
    })), A = computed(() => [
      a.tbodyTrClass ? typeof a.tbodyTrClass == "function" ? a.tbodyTrClass(null, "table-busy") : a.tbodyTrClass : null
    ]), C = (k) => [
      {
        "b-table-sortable-column": m.value && k.sortable
      }
    ], V = (k, S) => [
      {
        [`selected table-${a.selectionVariant}`]: a.selectable && k && c.has(k)
      },
      a.tbodyTrClass ? typeof a.tbodyTrClass == "function" ? a.tbodyTrClass(k, S) : a.tbodyTrClass : null
    ], O = computed(() => {
      const k = (M) => {
        var I;
        const X = (I = r.value) == null ? void 0 : I.filter((z) => !!z.order);
        return !X || X.length === 0 ? M : [...M].sort((z, te) => {
          for (let ae = 0; ae < (X.length ?? 0); ae++) {
            const K = X[ae], ne = (de) => {
              if (!et(de))
                return String(de);
              const me = B.value.find((se) => jt(se) ? se.key === K.key : false), J = Ie(de, K.key);
              if (jt(me) && me.sortByFormatted) {
                const se = typeof me.sortByFormatted == "function" ? me.sortByFormatted : me.formatter;
                if (se)
                  return Ga(de, String(me.key), se);
              }
              return typeof J == "object" && J !== null ? JSON.stringify(J) : (J == null ? void 0 : J.toString()) ?? "";
            }, re = ne(z), Q = ne(te), fe = K.comparer ? K.comparer(re, Q) : re.localeCompare(Q, void 0, { numeric: true });
            if (fe !== 0)
              return K.order === "asc" ? fe : -fe;
          }
          return 0;
        });
      }, S = (M) => M.filter(
        (X) => et(X) ? Object.entries(X).some(([I, z]) => {
          var K, ne, re;
          return z == null || I[0] === "_" || !((K = a.filterable) != null && K.includes(I)) && ((ne = a.filterable) != null && ne.length) ? false : (() => {
            const Q = B.value.find((fe) => jt(fe) ? fe.key === I : false);
            if (jt(Q) && Q.filterByFormatted) {
              const fe = typeof Q.filterByFormatted == "function" ? Q.filterByFormatted : Q.formatter;
              if (fe)
                return fe(z, String(Q.key), X);
            }
            return typeof z == "object" ? JSON.stringify(Object.values(z)) : z.toString();
          })().toLowerCase().includes(((re = a.filter) == null ? void 0 : re.toLowerCase()) ?? "");
        }) : true
      );
      let E = h2.value ? f.value : a.items;
      return E = E.map((M) => {
        if (typeof M == "object" && M !== null && Object.keys(M).some((X) => X.includes("."))) {
          let X = {};
          for (const I in M)
            I.includes(".") ? X = pi(X, I, M[I]) : X[I] = M[I];
          return X;
        }
        return M;
      }), (y.value === true && !h2.value || y.value === true && h2.value && a.noProviderFiltering) && (E = S(E)), (m.value === true && !h2.value && !a.noLocalSorting || m.value === true && h2.value && a.noProviderSorting) && (E = k(E)), E;
    }), Y = computed(() => Number.isNaN(p.value) || h2.value && !a.noProviderPaging ? O.value : O.value.slice(
      (v.value - 1) * (p.value || Number.POSITIVE_INFINITY),
      v.value * (p.value || Number.POSITIVE_INFINITY)
    ));
    watch(Y, (k) => {
      n("change", k);
    });
    const U = (k, S, E = false, M = false, X = false) => {
      if (a.selectable)
        if (a.selectMode === "single" || a.selectMode === "multi") {
          if (E || M)
            return;
          c.has(k) ? c.delete(k) : a.selectMode === "single" ? c.set([k]) : c.add(k);
        } else if (M || X)
          c.has(k) ? c.delete(k) : c.add(k);
        else if (E) {
          const I = [...d.value].pop(), z = a.items.findIndex((ne) => ne === I), te = Math.min(z, S), ae = Math.max(z, S), K = a.items.slice(te, ae + 1);
          c.set(K);
        } else
          c.set([k]);
    }, F = (k, S, E) => {
      a.noSelectOnClick === false && U(k, S, E.shiftKey, E.ctrlKey, E.metaKey), n("row-clicked", k, S, E);
    }, j = (k) => {
      var K, ne;
      if (!m.value)
        return;
      const S = typeof k == "object" && k !== null ? k.key : k, E = typeof k == "object" && k !== null ? k.sortable : false;
      if (!(m.value === true && E === true))
        return;
      const M = (re) => {
        if (re === "asc")
          return "desc";
        if (re === void 0 || a.mustSort === true || Array.isArray(a.mustSort) && a.mustSort.includes(S))
          return "asc";
      }, X = ((K = r.value) == null ? void 0 : K.findIndex((re) => re.key === S)) ?? -1, I = (ne = r.value) == null ? void 0 : ne[X], z = (
        // If value is new, we default to ascending
        // Otherwise we make a temp copy of the value
        X === -1 || !I ? { key: S, order: "asc" } : { ...I }
      ), te = () => {
        var Q, fe;
        let re = z;
        if (X === -1)
          r.value = [...r.value ?? [], z];
        else {
          const de = M(z.order);
          re = { ...z, order: de }, r.value = de ? (Q = r.value) == null ? void 0 : Q.map((me) => me.key === re.key ? re : me) : (fe = r.value) == null ? void 0 : fe.filter((me) => me.key !== re.key);
        }
        return re;
      }, ae = () => {
        const re = {
          ...z,
          order: X === -1 ? z.order : M(z.order)
        };
        return r.value = [re], re;
      };
      n("sorted", a.multisort === true ? te() : ae());
    }, $ = (k, S, E, M = false) => {
      n("head-clicked", k, S, E, M), j(S);
    }, N = async () => {
      if (!h2.value || a.provider === void 0 || u.value)
        return;
      u.value = true;
      const k = a.provider({
        currentPage: v.value,
        filter: a.filter,
        sortBy: r.value,
        perPage: p.value
      });
      try {
        const S = k instanceof Promise ? await k : k;
        if (S === void 0)
          return;
        f.value = S;
      } finally {
        u.value = false;
      }
    }, H = async (k, S, E) => {
      if (S === E)
        return;
      const M = (te) => {
        var ae;
        return ((ae = a.noProvider) == null ? void 0 : ae.includes(te)) === true;
      }, X = (k === "currentPage" || k === "perPage") && (M("paging") || a.noProviderPaging === true), I = k === "filter" && (M("filtering") || a.noProviderFiltering === true), z = (k === "sortBy" || k === "sortDesc") && (M("sorting") || a.noProviderSorting === true);
      X || I || z || (h2.value === true && await N(), k === "currentPage" || k === "perPage" || n("filtered", [...O.value]));
    };
    return watch(
      () => a.filter,
      (k, S) => {
        H("filter", k, S), !(k === S || h2.value) && (k || n("filtered", [...O.value]));
      }
    ), watch(v, (k, S) => {
      H("currentPage", k, S);
    }), watch(p, (k, S) => {
      H("perPage", k, S);
    }), watch(
      r,
      (k, S) => {
        H("sortBy", k, S);
      },
      { deep: true }
    ), watch(
      () => a.provider,
      (k) => {
        if (k === void 0) {
          f.value = [];
          return;
        }
        N();
      }
    ), onMounted(N), l({
      // The row selection methods are really for compat. Users should probably use the v-model though
      clearSelected: () => {
        a.selectable && c.clear();
      },
      refresh: N,
      selectAllRows: () => {
        if (!a.selectable)
          return;
        const k = d.value.size > 0 ? [...d.value] : [];
        d.value = /* @__PURE__ */ new Set([...O.value]), d.value.forEach((S) => {
          k.includes(S) || n("row-selected", S);
        });
      },
      selectRow: (k) => {
        if (!a.selectable)
          return;
        const S = O.value[k];
        !S || c.has(S) || c.add(S);
      },
      unselectRow: (k) => {
        if (!a.selectable)
          return;
        const S = O.value[k];
        !S || !c.has(S) || c.delete(S);
      },
      isRowSelected: (k) => {
        if (!a.selectable)
          return false;
        const S = O.value[k];
        return c.has(S);
      }
    }), (k, S) => (openBlock(), createBlock(ls, mergeProps(unref(a), {
      "aria-busy": u.value,
      items: Y.value,
      fields: B.value,
      "table-class": g.value,
      "tbody-tr-class": V,
      "field-column-class": C,
      onHeadClicked: $,
      onRowDblClicked: S[0] || (S[0] = (E, M, X) => {
        n("row-dbl-clicked", E, M, X);
      }),
      onRowClicked: F,
      onRowHovered: S[1] || (S[1] = (E, M, X) => {
        n("row-hovered", E, M, X);
      }),
      onRowUnhovered: S[2] || (S[2] = (E, M, X) => {
        n("row-unhovered", E, M, X);
      })
    }), createSlots({
      "head()": withCtx((E) => {
        var M, X, I, z;
        return [
          createTextVNode(toDisplayString(unref(sa)(E.field)) + " ", 1),
          m.value && E.field.sortable && unref(a).noSortableIcon === false ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            ((X = (M = r.value) == null ? void 0 : M.find((te) => te.key === E.field.key)) == null ? void 0 : X.order) === "asc" ? renderSlot(
              k.$slots,
              k.$slots[`sortAsc(${String(E.field.key)})`] ? `sortAsc(${String(E.field.key)})` : "sortAsc()",
              normalizeProps(mergeProps({ key: 0 }, { ...E })),
              () => [
                tf
              ]
            ) : ((z = (I = r.value) == null ? void 0 : I.find((te) => te.key === E.field.key)) == null ? void 0 : z.order) === "desc" ? renderSlot(
              k.$slots,
              k.$slots[`sortDesc(${String(E.field.key)})`] ? `sortDesc(${String(E.field.key)})` : "sortDesc()",
              normalizeProps(mergeProps({ key: 1 }, { ...E })),
              () => [
                af
              ]
            ) : renderSlot(
              k.$slots,
              k.$slots[`sortDefault(${String(E.field.key)})`] ? `sortDefault(${String(E.field.key)})` : "sortDefault()",
              normalizeProps(mergeProps({ key: 2 }, { ...E })),
              () => [
                (openBlock(), createElementBlock("svg", of, nf))
              ]
            )
          ], 64)) : createCommentVNode("", true)
        ];
      }),
      "custom-body": withCtx((E) => [
        u.value ? (openBlock(), createBlock(tt, {
          key: 0,
          class: normalizeClass(["b-table-busy-slot", A.value])
        }, {
          default: withCtx(() => [
            createVNode(Ot, {
              colspan: E.fields.length
            }, {
              default: withCtx(() => [
                renderSlot(k.$slots, "table-busy", {}, () => [
                  createVNode(Na, { show: "" }, {
                    overlay: withCtx(() => [
                      createBaseVNode("div", sf, [
                        createVNode(Aa),
                        createBaseVNode("strong", null, toDisplayString(unref(a).busyLoadingText), 1)
                      ])
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 2
            }, 1032, ["colspan"])
          ]),
          _: 2
        }, 1032, ["class"])) : createCommentVNode("", true)
      ]),
      _: 2
    }, [
      renderList(k.$slots, (E, M) => ({
        name: M,
        fn: withCtx((X) => [
          renderSlot(k.$slots, M, normalizeProps(guardReactiveProps(X)))
        ])
      }))
    ]), 1040, ["aria-busy", "items", "fields", "table-class"]));
  }
});
var uf = defineComponent({
  inheritAttrs: false,
  __name: "BTab",
  props: mergeModels({
    active: { type: Boolean },
    buttonId: { default: void 0 },
    disabled: { type: Boolean, default: false },
    id: { default: void 0 },
    lazy: { type: Boolean, default: void 0 },
    lazyOnce: { type: Boolean, default: void 0 },
    noBody: { type: Boolean, default: false },
    tag: { default: "div" },
    title: { default: void 0 },
    titleItemClass: { default: void 0 },
    titleLinkAttrs: { default: void 0 },
    titleLinkClass: { default: void 0 }
  }, {
    active: { type: Boolean, default: false },
    activeModifiers: {}
  }),
  emits: ["update:active"],
  setup(t4) {
    const e = G(t4, "BTab"), o = useSlots(), a = useModel(t4, "active"), n = inject(jl, null), r = ke(() => e.id, "tabpane"), u = ke(() => e.buttonId, "tab"), i = ref(false), d = ref(null), { onClick: c, ...f } = useAttrs(), p = computed(
      () => ({
        id: r.value,
        buttonId: u.value,
        disabled: e.disabled,
        title: e.title,
        titleComponent: o.title,
        titleItemClass: e.titleItemClass,
        titleLinkAttrs: e.titleLinkAttrs,
        titleLinkClass: e.titleLinkClass,
        onClick: c,
        el: d.value
      })
    );
    onMounted(() => {
      n && (n.registerTab(p), e.active && n.activateTab(r.value));
    }), onUnmounted(() => {
      n && n.unregisterTab(r.value);
    });
    const v = toRef(() => (n == null ? void 0 : n.activeId.value) === r.value), y = ref(v.value), h2 = toRef(() => !!(n != null && n.lazy.value || (e.lazyOnce ?? e.lazy))), w = toRef(() => e.lazyOnce !== void 0), m = toRef(() => v.value && !e.disabled), B = toRef(
      () => m.value || !h2.value || h2.value && w.value && i.value
    );
    watch(v, (A) => {
      if (A) {
        a.value = true, setTimeout(() => {
          y.value = true;
        }, 0);
        return;
      }
      y.value = false, a.value = false;
    }), watch(
      () => e.active,
      (A) => {
        if (n) {
          if (!A) {
            v.value && n.activateTab(void 0);
            return;
          }
          n.activateTab(r.value);
        }
      }
    );
    const g = computed(() => [
      {
        active: v.value,
        show: y.value,
        "card-body": (n == null ? void 0 : n.card.value) && e.noBody === false,
        fade: !(n != null && n.noFade.value)
      },
      y.value ? n == null ? void 0 : n.activeTabClass.value : n == null ? void 0 : n.inactiveTabClass.value,
      n == null ? void 0 : n.tabClass.value
    ]);
    return watch(B, (A) => {
      A && !i.value && (i.value = true);
    }), (A, C) => (openBlock(), createBlock(resolveDynamicComponent(unref(e).tag), mergeProps({
      id: unref(r),
      ref_key: "el",
      ref: d,
      class: ["tab-pane", g.value],
      role: "tabpanel",
      "aria-labelledby": unref(u)
    }, f), {
      default: withCtx(() => [
        B.value ? renderSlot(A.$slots, "default", { key: 0 }) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16, ["id", "class", "aria-labelledby"]));
  }
});
var df = ["aria-orientation"];
var cf = ["id", "aria-controls", "aria-selected", "onClick"];
var ff = defineComponent({
  __name: "BTabs",
  props: mergeModels({
    activeId: {},
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    card: { type: Boolean, default: false },
    contentClass: { default: void 0 },
    end: { type: Boolean, default: false },
    fill: { type: Boolean, default: false },
    id: { default: void 0 },
    inactiveNavItemClass: { default: void 0 },
    inactiveTabClass: { default: void 0 },
    justified: { type: Boolean, default: false },
    lazy: { type: Boolean, default: false },
    modelValue: {},
    navClass: { default: void 0 },
    navItemClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { type: Boolean, default: false },
    noNavStyle: { type: Boolean, default: false },
    pills: { type: Boolean, default: false },
    small: { type: Boolean, default: false },
    tag: { default: "div" },
    tabClass: { default: void 0 },
    vertical: { type: Boolean, default: false }
  }, {
    modelValue: {
      default: -1
    },
    modelModifiers: {},
    activeId: {
      default: void 0
    },
    activeIdModifiers: {}
  }),
  emits: mergeModels(["activate-tab", "click"], ["update:modelValue", "update:activeId"]),
  setup(t4, { emit: l }) {
    const o = G(t4, "BTabs"), a = l, n = useModel(t4, "modelValue"), r = useModel(t4, "activeId"), u = pa(), i = ref([]), d = computed(
      () => i.value.map((C) => {
        const V = unref(C), O = V.id === r.value;
        return {
          ...V,
          active: O,
          navItemClasses: [
            {
              active: O,
              disabled: V.disabled
            },
            O ? o.activeNavItemClass : o.inactiveNavItemClass,
            o.navItemClass,
            V.titleLinkClass
          ]
        };
      })
    ), c = toRef(() => !(d != null && d.value && d.value.length > 0)), f = computed(() => ({
      "d-flex": o.vertical,
      "align-items-start": o.vertical
    })), p = Xt(() => o.align), v = computed(() => ({
      "nav-pills": o.pills,
      "flex-column me-3": o.vertical,
      [p.value]: o.align !== void 0,
      "nav-fill": o.fill,
      "card-header-tabs": o.card,
      "nav-justified": o.justified,
      "nav-tabs": !o.noNavStyle && !o.pills,
      small: o.small
    })), y = (C) => {
      var V;
      if (C !== void 0) {
        const O = (V = d.value[C]) == null ? void 0 : V.id;
        if (C > -1 && C < d.value.length && !d.value[C].disabled && (n.value < 0 || r.value !== O || n.value !== C)) {
          const Y = new ut("activate-tab", { cancelable: true });
          a("activate-tab", C, n.value, Y), Y.defaultPrevented || (r.value !== O && (r.value = O), n.value !== C && (n.value = C));
        }
      }
    }, h2 = (C, V) => {
      var O, Y, U;
      y(V), V >= 0 && !d.value[V].disabled && ((O = d.value[V]) != null && O.onClick) && typeof d.value[V].onClick == "function" && ((U = (Y = d.value[V]).onClick) == null || U.call(Y, C));
    }, w = (C) => {
      var V, O;
      d.value.length <= 0 || (n.value = m(n.value + C, C), (O = document.getElementById((V = d.value[n.value]) == null ? void 0 : V.buttonId)) == null || O.focus());
    }, m = (C, V) => {
      let O = C, Y = -1, U = -1;
      for (let F = 0; F < d.value.length; F++)
        d.value[F].disabled || (Y === -1 && (Y = F), U = F);
      for (; O >= Y && O <= U && d.value[O].disabled; )
        O += V;
      return O < Y && (O = Y), O > U && (O = U), O;
    };
    watch(n, (C, V) => {
      if (C === V || d.value.length <= 0)
        return;
      const O = m(C, C > V ? 1 : -1);
      nextTick(() => {
        y(O);
      });
    }), watch(r, (C, V) => {
      const O = d.value.findIndex((Y) => Y.id === C);
      if (C !== V && !(d.value.length <= 0)) {
        if (O === -1) {
          y(m(0, 1));
          return;
        }
        y(O);
      }
    });
    const B = (C) => {
      i.value.find((V) => V.value.id === C.value.id) ? i.value[i.value.findIndex((V) => V.value.id === C.value.id)] = C : i.value.push(C), i.value.sort((V, O) => {
        if (!Node || !V.value.el || !O.value.el)
          return 0;
        const Y = V.value.el.compareDocumentPosition(O.value.el);
        return Y & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : Y & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
      });
    }, g = (C) => {
      i.value = i.value.filter((V) => V.value.id !== C);
    };
    watch(
      i,
      () => {
        A();
      },
      { deep: true }
    );
    const A = () => {
      var C;
      if (d.value.length === 0) {
        n.value = -1, r.value = void 0;
        return;
      }
      if (n.value >= 0 && !r.value && (r.value = (C = d.value[n.value]) == null ? void 0 : C.id), d.value.find((V) => V.id === r.value)) {
        y(d.value.findIndex((V) => V.id === r.value));
        return;
      }
      y(d.value.map((V) => !V.disabled).indexOf(true));
    };
    return provide(jl, {
      lazy: toRef(() => o.lazy),
      card: toRef(() => o.card),
      noFade: toRef(() => o.noFade),
      activeTabClass: toRef(() => o.activeTabClass),
      inactiveTabClass: toRef(() => o.inactiveTabClass),
      tabClass: toRef(() => o.tabClass),
      registerTab: B,
      unregisterTab: g,
      activeId: r,
      activateTab: (C) => {
        const V = d.value.findIndex((O) => O.id === C);
        if (C === void 0 || V === -1) {
          y(m(0, 1));
          return;
        }
        y(V);
      }
    }), (C, V) => (openBlock(), createBlock(resolveDynamicComponent(unref(o).tag), {
      id: unref(o).id,
      class: normalizeClass(["tabs", f.value])
    }, {
      default: withCtx(() => [
        createVNode(unref(u).define, null, {
          default: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["tab-content", unref(o).contentClass])
            }, [
              renderSlot(C.$slots, "default"),
              c.value ? (openBlock(), createElementBlock("div", {
                key: "bv-empty-tab",
                class: normalizeClass(["tab-pane active", { "card-body": unref(o).card }])
              }, [
                renderSlot(C.$slots, "empty")
              ], 2)) : createCommentVNode("", true)
            ], 2)
          ]),
          _: 3
        }),
        unref(o).end ? (openBlock(), createBlock(unref(u).reuse, { key: 0 })) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass([
            unref(o).navWrapperClass,
            { "card-header": unref(o).card, "ms-auto": C.vertical && unref(o).end }
          ])
        }, [
          createBaseVNode("ul", {
            class: normalizeClass(["nav", [v.value, unref(o).navClass]]),
            role: "tablist",
            "aria-orientation": unref(o).vertical ? "vertical" : "horizontal"
          }, [
            renderSlot(C.$slots, "tabs-start"),
            (openBlock(true), createElementBlock(Fragment, null, renderList(d.value, (O, Y) => (openBlock(), createElementBlock("li", {
              key: O.id,
              class: normalizeClass(["nav-item", O.titleItemClass]),
              role: "presentation"
            }, [
              createBaseVNode("button", mergeProps({
                id: O.buttonId,
                class: ["nav-link", O.navItemClasses],
                role: "tab",
                "aria-controls": O.id,
                "aria-selected": O.active,
                ref_for: true
              }, O.titleLinkAttrs, {
                onKeydown: [
                  V[0] || (V[0] = withKeys(withModifiers((U) => w(-1), ["stop", "prevent"]), ["left"])),
                  V[1] || (V[1] = withKeys(withModifiers((U) => w(1), ["stop", "prevent"]), ["right"])),
                  V[2] || (V[2] = withKeys(withModifiers((U) => w(-999), ["stop", "prevent"]), ["page-up"])),
                  V[3] || (V[3] = withKeys(withModifiers((U) => w(999), ["stop", "prevent"]), ["page-down"]))
                ],
                onClick: withModifiers((U) => h2(U, Y), ["stop", "prevent"])
              }), [
                O.titleComponent ? (openBlock(), createBlock(resolveDynamicComponent(O.titleComponent), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(O.title), 1)
                ], 64))
              ], 16, cf)
            ], 2))), 128)),
            renderSlot(C.$slots, "tabs-end")
          ], 10, df)
        ], 2),
        unref(o).end ? createCommentVNode("", true) : (openBlock(), createBlock(unref(u).reuse, { key: 1 }))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
});
var vf = { id: "__BVID__toaster-container" };
var pf = defineComponent({
  __name: "BToastOrchestrator",
  props: {
    appendToast: { type: Boolean, default: false },
    teleportDisabled: { default: false },
    teleportTo: { default: "body" }
  },
  setup(t4, { expose: l }) {
    const o = G(t4, "BToastOrchestrator"), { remove: a, toasts: n, show: r, _setIsAppend: u, leave: i } = hn();
    watch(
      () => o.appendToast,
      (c) => {
        u == null || u(c);
      },
      { immediate: true }
    );
    const d = (c) => $a(c, ["_modelValue", "_self", "pos"]);
    return l({
      remove: a,
      show: r,
      toasts: n
    }), (c, f) => (openBlock(), createBlock(Teleport, {
      to: unref(o).teleportTo,
      disabled: unref(o).teleportDisabled
    }, [
      createBaseVNode("div", vf, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(mi), (p, v) => (openBlock(), createElementBlock("div", {
          key: v,
          class: normalizeClass([p, "toast-container position-fixed p-3"])
        }, [
          createVNode(TransitionGroup, { name: "b-list" }, {
            default: withCtx(() => {
              var y;
              return [
                (openBlock(true), createElementBlock(Fragment, null, renderList((y = unref(n)) == null ? void 0 : y.filter((h2) => h2.value.props.pos === v), (h2) => (openBlock(), createBlock(resolveDynamicComponent(h2.value.component), mergeProps({
                  key: h2.value.props._self,
                  ref_for: true
                }, d(h2.value.props), {
                  "model-value": h2.value.props._modelValue,
                  "trans-props": { ...h2.value.props.transProps, appear: true },
                  "onUpdate:modelValue": (w) => {
                    var m;
                    return (m = unref(i)) == null ? void 0 : m(h2.value.props._self);
                  },
                  onHide: (w) => {
                    var m;
                    return (m = unref(a)) == null ? void 0 : m(h2.value.props._self);
                  }
                }), null, 16, ["model-value", "trans-props", "onUpdate:modelValue", "onHide"]))), 128))
              ];
            }),
            _: 2
          }, 1024)
        ], 2))), 128))
      ])
    ], 8, ["to", "disabled"]));
  }
});
var mf = defineComponent({
  __name: "BTooltip",
  props: mergeModels({
    interactive: { type: Boolean, default: void 0 },
    boundary: {},
    boundaryPadding: {},
    click: { type: Boolean, default: void 0 },
    content: { default: void 0 },
    customClass: { default: void 0 },
    delay: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    html: { type: Boolean, default: void 0 },
    id: { default: void 0 },
    inline: { type: Boolean, default: void 0 },
    manual: { type: Boolean, default: void 0 },
    modelValue: { type: Boolean },
    noAutoClose: { type: Boolean, default: void 0 },
    noFade: { type: Boolean, default: void 0 },
    noFlip: { type: Boolean, default: void 0 },
    noHide: { type: Boolean, default: void 0 },
    noShift: { type: Boolean, default: void 0 },
    noSize: { type: Boolean },
    noninteractive: { type: Boolean, default: void 0 },
    offset: { default: void 0 },
    placement: { default: void 0 },
    persistent: { type: Boolean },
    realtime: { type: Boolean, default: void 0 },
    reference: { default: void 0 },
    strategy: { default: void 0 },
    target: { default: void 0 },
    title: { default: void 0 },
    variant: { default: void 0 },
    teleportDisabled: { default: void 0 },
    teleportTo: { default: void 0 }
  }, {
    modelValue: { type: Boolean, default: void 0 },
    modelModifiers: {}
  }),
  emits: ["update:modelValue"],
  setup(t4, { expose: l }) {
    var u, i, d;
    const o = G(t4, "BTooltip"), a = useModel(t4, "modelValue"), n = computed(() => {
      const { interactive: c, noninteractive: f, ...p } = o;
      return { noninteractive: f !== void 0 ? f : !c, ...p };
    }), r = ref(null);
    return l({
      hide: (u = r.value) == null ? void 0 : u.hide,
      show: (i = r.value) == null ? void 0 : i.show,
      toggle: (d = r.value) == null ? void 0 : d.toggle
    }), (c, f) => (openBlock(), createBlock(go, mergeProps({
      ref_key: "popover",
      ref: r
    }, n.value, {
      modelValue: a.value,
      "onUpdate:modelValue": f[0] || (f[0] = (p) => a.value = p),
      tooltip: ""
    }), createSlots({ _: 2 }, [
      renderList(c.$slots, (p, v) => ({
        name: v,
        fn: withCtx((y) => [
          renderSlot(c.$slots, v, normalizeProps(guardReactiveProps(y)))
        ])
      }))
    ]), 1040, ["modelValue"]));
  }
});
var ua = Object.freeze(Object.defineProperty({
  __proto__: null,
  BAccordion: du,
  BAccordionItem: fu,
  BAlert: pu,
  BAvatar: gu,
  BAvatarGroup: hu,
  BBadge: Rn,
  BBreadcrumb: wu,
  BBreadcrumbItem: zn,
  BButton: vt,
  BButtonGroup: Cu,
  BButtonToolbar: Tu,
  BCard: Gn,
  BCardBody: qn,
  BCardFooter: Wn,
  BCardGroup: xu,
  BCardHeader: Hn,
  BCardImg: To,
  BCardSubtitle: jn,
  BCardText: $u,
  BCardTitle: Dn,
  BCarousel: Iu,
  BCarouselSlide: Hu,
  BCloseButton: zt,
  BCol: Dt,
  BCollapse: Ln,
  BContainer: Du,
  BDropdown: Un,
  BDropdownDivider: Gu,
  BDropdownForm: Ku,
  BDropdownGroup: Zu,
  BDropdownHeader: Qu,
  BDropdownItem: ed,
  BDropdownItemButton: od,
  BDropdownText: nd,
  BForm: Kn,
  BFormCheckbox: Xn,
  BFormCheckboxGroup: pd,
  BFormFile: yd,
  BFormFloatingLabel: ud,
  BFormGroup: Td,
  BFormInput: el,
  BFormInvalidFeedback: Xa,
  BFormRadio: Zn,
  BFormRadioGroup: Nd,
  BFormRow: ia,
  BFormSelect: Ld,
  BFormSelectOption: So,
  BFormSelectOptionGroup: Jn,
  BFormSpinbutton: Hd,
  BFormTag: Qn,
  BFormTags: ac,
  BFormText: Ya,
  BFormTextarea: lc,
  BFormValidFeedback: Za,
  BImg: ko,
  BInput: el,
  BInputGroup: cc,
  BInputGroupText: fc,
  BLink: it,
  BListGroup: vc,
  BListGroupItem: pc,
  BModal: Ka,
  BModalOrchestrator: bc,
  BNav: yc,
  BNavForm: hc,
  BNavItem: _c,
  BNavItemDropdown: Cc,
  BNavText: Tc,
  BNavbar: Sc,
  BNavbarBrand: xc,
  BNavbarNav: $c,
  BNavbarToggle: Lc,
  BOffcanvas: Mc,
  BOverlay: Na,
  BPagination: Dc,
  BPlaceholder: Xe,
  BPlaceholderButton: ts,
  BPlaceholderCard: jc,
  BPlaceholderTable: Wc,
  BPlaceholderWrapper: Gc,
  BPopover: go,
  BProgress: _n,
  BProgressBar: Bn,
  BRow: Uc,
  BSpinner: Aa,
  BTab: uf,
  BTable: rf,
  BTableLite: ls,
  BTableSimple: xo,
  BTabs: ff,
  BTbody: as,
  BTd: Ot,
  BTfoot: eo,
  BTh: to,
  BThead: os,
  BToast: wn,
  BToastOrchestrator: pf,
  BTooltip: mf,
  BTr: tt,
  BTransition: Va
}, Symbol.toStringTag, { value: "Module" }));
var hf = Object.freeze(Object.defineProperty({
  __proto__: null,
  useBreadcrumb: ln,
  useColorMode: bi,
  useModal: ki,
  useModalController: bn,
  useScrollspy: gn,
  useToast: hn
}, Symbol.toStringTag, { value: "Module" }));
var Bf = Object.freeze(Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: pl,
  BvEvent: ut,
  BvTriggerableEvent: Ct
}, Symbol.toStringTag, { value: "Module" }));
var _f = Object.freeze(Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
var ns = (t4) => t4.toLowerCase().startsWith("v") ? t4.slice(1) : t4;
var wf = ({
  components: t4 = false,
  directives: l = false,
  plugins: e = {},
  aliases: o = {}
} = {}) => ({
  install(a) {
    const n = typeof t4 == "boolean" ? { all: t4 } : t4, r = Object.keys(ua);
    ha(n, r).forEach((d) => {
      const c = ua[d];
      a.component(d, c);
    });
    const u = typeof l == "boolean" ? { all: l } : l, i = Object.keys(Qa);
    ha(u, i).forEach((d) => {
      const c = ns(d), f = Qa[d];
      a.directive(c, f);
    }), Object.entries(o).forEach(([d, c]) => {
      const f = typeof c == "string" ? ua[c] : c;
      a.component(d, f);
    }), ((e == null ? void 0 : e.breadcrumb) ?? true) && a.use(kn), (((e == null ? void 0 : e.id) ?? true) || typeof e.id == "object") && a.use(Tn, e), ((e == null ? void 0 : e.modalController) ?? true) && a.use(Pn), ((e == null ? void 0 : e.modalManager) ?? true) && a.use(En), (((e == null ? void 0 : e.rtl) ?? true) || typeof e.rtl == "object") && a.use(Fn, e), ((e == null ? void 0 : e.toast) ?? true) && a.use(Cn), a.use(In, e);
  }
});
var Cf = ({
  aliases: t4 = {},
  directives: l = true,
  components: e = true
} = {}) => {
  const o = typeof e == "boolean" ? { all: e } : e, a = Object.keys(ua), n = new Set(ha(o, a)), r = typeof l == "boolean" ? { all: l } : l, u = Object.keys(Qa), i = new Set(ha(r, u).map(ns));
  return [
    {
      type: "component",
      resolve: (c) => {
        if (n.has(c) || t4[c])
          return {
            name: t4[c] || c,
            from: "bootstrap-vue-next"
          };
      }
    },
    {
      type: "directive",
      resolve: (c) => {
        if (i.has(c))
          return {
            name: `v${c}`,
            from: "bootstrap-vue-next"
          };
      }
    }
  ];
};
export {
  du as BAccordion,
  fu as BAccordionItem,
  pu as BAlert,
  gu as BAvatar,
  hu as BAvatarGroup,
  Rn as BBadge,
  wu as BBreadcrumb,
  zn as BBreadcrumbItem,
  vt as BButton,
  Cu as BButtonGroup,
  Tu as BButtonToolbar,
  Gn as BCard,
  qn as BCardBody,
  Wn as BCardFooter,
  xu as BCardGroup,
  Hn as BCardHeader,
  To as BCardImg,
  jn as BCardSubtitle,
  $u as BCardText,
  Dn as BCardTitle,
  Iu as BCarousel,
  Hu as BCarouselSlide,
  zt as BCloseButton,
  Dt as BCol,
  Ln as BCollapse,
  Du as BContainer,
  Un as BDropdown,
  Gu as BDropdownDivider,
  Ku as BDropdownForm,
  Zu as BDropdownGroup,
  Qu as BDropdownHeader,
  ed as BDropdownItem,
  od as BDropdownItemButton,
  nd as BDropdownText,
  Kn as BForm,
  Xn as BFormCheckbox,
  pd as BFormCheckboxGroup,
  yd as BFormFile,
  ud as BFormFloatingLabel,
  Td as BFormGroup,
  el as BFormInput,
  Xa as BFormInvalidFeedback,
  Zn as BFormRadio,
  Nd as BFormRadioGroup,
  ia as BFormRow,
  Ld as BFormSelect,
  So as BFormSelectOption,
  Jn as BFormSelectOptionGroup,
  Hd as BFormSpinbutton,
  Qn as BFormTag,
  ac as BFormTags,
  Ya as BFormText,
  lc as BFormTextarea,
  Za as BFormValidFeedback,
  ko as BImg,
  el as BInput,
  cc as BInputGroup,
  fc as BInputGroupText,
  it as BLink,
  vc as BListGroup,
  pc as BListGroupItem,
  Ka as BModal,
  bc as BModalOrchestrator,
  yc as BNav,
  hc as BNavForm,
  _c as BNavItem,
  Cc as BNavItemDropdown,
  Tc as BNavText,
  Sc as BNavbar,
  xc as BNavbarBrand,
  $c as BNavbarNav,
  Lc as BNavbarToggle,
  Mc as BOffcanvas,
  Na as BOverlay,
  Dc as BPagination,
  Xe as BPlaceholder,
  ts as BPlaceholderButton,
  jc as BPlaceholderCard,
  Wc as BPlaceholderTable,
  Gc as BPlaceholderWrapper,
  go as BPopover,
  _n as BProgress,
  Bn as BProgressBar,
  Uc as BRow,
  Aa as BSpinner,
  uf as BTab,
  rf as BTable,
  ls as BTableLite,
  xo as BTableSimple,
  ff as BTabs,
  as as BTbody,
  Ot as BTd,
  eo as BTfoot,
  to as BTh,
  os as BThead,
  wn as BToast,
  pf as BToastOrchestrator,
  mf as BTooltip,
  tt as BTr,
  Va as BTransition,
  Cf as BootstrapVueNextResolver,
  pl as BvCarouselEvent,
  ut as BvEvent,
  Ct as BvTriggerableEvent,
  ua as Components,
  hf as Composables,
  Qa as Directives,
  gf as Plugins,
  _f as Types,
  Bf as Utils,
  kn as breadcrumb,
  wf as createBootstrap,
  wf as default,
  In as defaults,
  Tn as id,
  Pn as modalController,
  En as modalManager,
  Fn as rtl,
  Cn as toast,
  ln as useBreadcrumb,
  bi as useColorMode,
  ki as useModal,
  bn as useModalController,
  gn as useScrollspy,
  hn as useToast,
  Vc as vBColorMode,
  Ja as vBModal,
  Oc as vBPopover,
  Pc as vBScrollspy,
  Ja as vBToggle,
  Ec as vBTooltip
};
/*! Bundled license information:

bootstrap-vue-next/dist/bootstrap-vue-next.mjs:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
  (*!
  * focus-trap 7.5.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=bootstrap-vue-next.js.map
